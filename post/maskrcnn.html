<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>经典实例分割模型Mask RCNN | 马浩飞丨博客</title><meta name="keywords" content="深度学习,实验,视觉,实例分割"><meta name="author" content="马浩飞"><meta name="copyright" content="马浩飞"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Mask R-CNN是He Kaiming大神2017年的力作，其在进行目标检测的同时进行实例分割，取得了出色的效果。">
<meta property="og:type" content="article">
<meta property="og:title" content="经典实例分割模型Mask RCNN">
<meta property="og:url" content="https://www.mahaofei.com/post/maskrcnn.html">
<meta property="og:site_name" content="马浩飞丨博客">
<meta property="og:description" content="Mask R-CNN是He Kaiming大神2017年的力作，其在进行目标检测的同时进行实例分割，取得了出色的效果。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.mahaofei.com/img/20220515154938.png">
<meta property="article:published_time" content="2022-06-11T00:47:32.000Z">
<meta property="article:modified_time" content="2022-06-11T00:47:32.000Z">
<meta property="article:author" content="马浩飞">
<meta property="article:tag" content="深度学习">
<meta property="article:tag" content="实验">
<meta property="article:tag" content="视觉">
<meta property="article:tag" content="实例分割">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.mahaofei.com/img/20220515154938.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.mahaofei.com/post/maskrcnn"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="code-bB89NudWgv"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?439a0d0abeb31dd8f338efd8266c999b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"ABY1KMOQQM","apiKey":"d3f3a4fbb355106e6bf265cf8da1863b","indexName":"hexo","hits":{"per_page":4},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '经典实例分割模型Mask RCNN',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-11 08:47:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="/css/custom/MainColor.css"><link rel="stylesheet" href="/css/custom/categoryBar.css"><link rel="stylesheet" href="/css/custom/404.css"><link rel="stylesheet" href="/css/custom/cardHistory.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="/css/custom/custom.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="马浩飞丨博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">250</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">79</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book-open"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-history"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-envelope-open-text"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 本站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fa-solid fa-blog"></i><span> 个人博客</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://academic.mahaofei.com/"><i class="fa-fw fa-solid fa-graduation-cap"></i><span> 学术主页</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://nav.mahaofei.com/"><i class="fa-fw fas fa-compass"></i><span> 导航网站</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img.mahaofei.com/img/20220515154938.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">马浩飞丨博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book-open"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-history"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-envelope-open-text"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 本站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fa-solid fa-blog"></i><span> 个人博客</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://academic.mahaofei.com/"><i class="fa-fw fa-solid fa-graduation-cap"></i><span> 学术主页</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://nav.mahaofei.com/"><i class="fa-fw fas fa-compass"></i><span> 导航网站</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">经典实例分割模型Mask RCNN</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-11T00:47:32.000Z" title="发表于 2022-06-11 08:47:32">2022-06-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-11T00:47:32.000Z" title="更新于 2022-06-11 08:47:32">2022-06-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/2D%E8%A7%86%E8%A7%89%E7%AE%97%E6%B3%95/">2D视觉算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="经典实例分割模型Mask RCNN"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/maskrcnn.html#post-comment"><span id="twikoo-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>一、Mask RCNN简介</h1>
<p>区域卷积神经网络 RCNN（Region-Convolutional Neural Networks）为两阶段目标检测器。通过对图像生成候选区域，提取特征，判别特征类别并修正候选框位置。 RCNN系列目前包含两个代表模型：Faster RCNN，Mask RCNN。</p>
<p>Mask R-CNN是He Kaiming大神2017年的力作，其在进行目标检测的同时进行实例分割，取得了出色的效果。</p>
<p><img src="https://img.mahaofei.com/img/20220515154938.png" alt=""></p>
<p>Mask-RCNN使用Resnet101作为主干特征提取网络，也就是图中的CNN部分，其对输入的图像image要求其是正方形且宽高可以整除2的6次方，不足的将会在外侧添加灰色区域。</p>
<ol>
<li><strong>Resnet101主干特征提取（CNN）</strong></li>
</ol>
<p>一张图像image传入到 <strong>Resnet101(CNN)</strong> 之后，会对其进行特征提取，然后将图像长宽压缩两次、三次、四次、五次来构造特征金字塔，目的是为了实现特征多尺度融合。</p>
<p><img src="https://img.mahaofei.com/img/20220515161629.png" alt=""></p>
<p>也就是下图中的左侧部分，分别得到了C2、C3、C4、C5五种特征层（五种尺寸的图像）。</p>
<p><img src="https://img.mahaofei.com/img/20220515162541.png" alt=""></p>
<ul>
<li>P5：对最小的C5(32,32)图像进行二维卷积，然后再次卷积作为一个有效特征层P5(32,32)（下方绿色框）</li>
<li>P6：将P5(32,32)最大池化得到有效特征层P6(16,16)。</li>
<li>P4：将C5(32,32)一次卷积的结果上采样得到(64,64)图像，与C4(64,64)进行Add运算，然后再次卷积得到另一个有效特征层P4。</li>
<li>P3：将C4一次卷积结果上采样，并与C3进行Add运算，然后再次卷积得到有效特征层P3。</li>
<li>P2：将C3一次卷积结果上采样，并与C2进行Add运算，再次卷积得到有效特征层P2。</li>
</ul>
<p>提取到的P2、P3、P4、P5、P6五个有效特征层，就是Resent101的输出feature maps，可以用于接下来RPN建议网络获取建议框。</p>
<ol start="2">
<li><strong>RPN区域建议网络（Region Proposal）</strong></li>
</ol>
<p>对有效特征层使用RPN建议网络（region proposal），获得许多建议框regions，这些建议框可能包含物体，可能没包含物体。不管包括没包括，接下来都会利用这些建议框截取P2~P5的图像，得到一个个可能存在目标的截取图像（P6不截取）。</p>
<ol start="3">
<li><strong>ROI区域对齐（ROI Align）</strong></li>
</ol>
<p>对于所有建议框截取图像，RoI Align都会将其调整图像尺寸为一个正方形，便于后续特征的匹配操作。</p>
<ol start="4">
<li><strong>FC Layers</strong></li>
</ol>
<p>根据截取出的建议框图像，利用Classifier回归模型判断截取的区域是否有物体，然后利用Classifier预测框网络对有效特征层进行解码获得最终的预测框。</p>
<ol start="5">
<li><strong>Mask语义分割网络</strong></li>
</ol>
<p>利用获取的最终预测框，再次在有效特征层P2~P5中截取目标图像（这次由于相当于进行了以便筛选，截取出的图像数量会少很多），将这次截取出的图像传给Mask语义分割网络进行语义分割。</p>
<h1>二、Mask R-CNN实现过程</h1>
<h2 id="2-1-Resnet101-主干特征提取网络">2.1 Resnet101-主干特征提取网络</h2>
<p>ResNet101有两个基本的块，分别是<code>Conv Block</code>和<code>Identity Block</code>。其中<code>Conv Block</code>的输入和输出维度不同，不能持续串联，它的作用是改变网络的维度；<code>Identity Block</code>的输入维度和输出维度相同，可以串联，用于加深网络。</p>
<p><img src="https://img.mahaofei.com/img/20220515195957.png" alt=""></p>
<p><img src="https://img.mahaofei.com/img/20220515195949.png" alt=""></p>
<p>以coco数据集中输入的shape为例，输入的shape为1024x1024，shape变化如下：</p>
<p><img src="https://img.mahaofei.com/img/20220515200117.png" alt=""></p>
<p>我们取出长宽压缩了两次、三次、四次、五次的结果来进行下面特征金字塔结构的构造。</p>
<p>相关代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> ZeroPadding2D,Conv2D,MaxPooling2D,BatchNormalization,Activation,Add</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">identity_block</span>(<span class="params">input_tensor, kernel_size, filters, stage, block,</span></span><br><span class="line"><span class="params">                   use_bias=<span class="literal">True</span>, train_bn=<span class="literal">True</span></span>):</span><br><span class="line">    nb_filter1, nb_filter2, nb_filter3 = filters</span><br><span class="line">    conv_name_base = <span class="string">&#x27;res&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_branch&#x27;</span></span><br><span class="line">    bn_name_base = <span class="string">&#x27;bn&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_branch&#x27;</span></span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter1, (<span class="number">1</span>, <span class="number">1</span>), name=conv_name_base + <span class="string">&#x27;2a&#x27;</span>,</span><br><span class="line">                  use_bias=use_bias)(input_tensor)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2a&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter2, (kernel_size, kernel_size), padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                  name=conv_name_base + <span class="string">&#x27;2b&#x27;</span>, use_bias=use_bias)(x)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2b&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter3, (<span class="number">1</span>, <span class="number">1</span>), name=conv_name_base + <span class="string">&#x27;2c&#x27;</span>,</span><br><span class="line">                  use_bias=use_bias)(x)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2c&#x27;</span>)(x, training=train_bn)</span><br><span class="line"></span><br><span class="line">    x = Add()([x, input_tensor])</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;res&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_out&#x27;</span>)(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">conv_block</span>(<span class="params">input_tensor, kernel_size, filters, stage, block,</span></span><br><span class="line"><span class="params">               strides=(<span class="params"><span class="number">2</span>, <span class="number">2</span></span>), use_bias=<span class="literal">True</span>, train_bn=<span class="literal">True</span></span>):</span><br><span class="line"></span><br><span class="line">    nb_filter1, nb_filter2, nb_filter3 = filters</span><br><span class="line">    conv_name_base = <span class="string">&#x27;res&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_branch&#x27;</span></span><br><span class="line">    bn_name_base = <span class="string">&#x27;bn&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_branch&#x27;</span></span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter1, (<span class="number">1</span>, <span class="number">1</span>), strides=strides,</span><br><span class="line">                  name=conv_name_base + <span class="string">&#x27;2a&#x27;</span>, use_bias=use_bias)(input_tensor)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2a&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter2, (kernel_size, kernel_size), padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                  name=conv_name_base + <span class="string">&#x27;2b&#x27;</span>, use_bias=use_bias)(x)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2b&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter3, (<span class="number">1</span>, <span class="number">1</span>), name=conv_name_base +</span><br><span class="line">                  <span class="string">&#x27;2c&#x27;</span>, use_bias=use_bias)(x)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2c&#x27;</span>)(x, training=train_bn)</span><br><span class="line"></span><br><span class="line">    shortcut = Conv2D(nb_filter3, (<span class="number">1</span>, <span class="number">1</span>), strides=strides,</span><br><span class="line">                         name=conv_name_base + <span class="string">&#x27;1&#x27;</span>, use_bias=use_bias)(input_tensor)</span><br><span class="line">    shortcut = BatchNormalization(name=bn_name_base + <span class="string">&#x27;1&#x27;</span>)(shortcut, training=train_bn)</span><br><span class="line"></span><br><span class="line">    x = Add()([x, shortcut])</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;res&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_out&#x27;</span>)(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_resnet</span>(<span class="params">input_image,stage5=<span class="literal">False</span>, train_bn=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="comment"># Stage 1</span></span><br><span class="line">    x = ZeroPadding2D((<span class="number">3</span>, <span class="number">3</span>))(input_image)</span><br><span class="line">    x = Conv2D(<span class="number">64</span>, (<span class="number">7</span>, <span class="number">7</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;conv1&#x27;</span>, use_bias=<span class="literal">True</span>)(x)</span><br><span class="line">    x = BatchNormalization(name=<span class="string">&#x27;bn_conv1&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    <span class="comment"># Height/4,Width/4,64</span></span><br><span class="line">    C1 = x = MaxPooling2D((<span class="number">3</span>, <span class="number">3</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">&quot;same&quot;</span>)(x)</span><br><span class="line">    <span class="comment"># Stage 2</span></span><br><span class="line">    x = conv_block(x, <span class="number">3</span>, [<span class="number">64</span>, <span class="number">64</span>, <span class="number">256</span>], stage=<span class="number">2</span>, block=<span class="string">&#x27;a&#x27;</span>, strides=(<span class="number">1</span>, <span class="number">1</span>), train_bn=train_bn)</span><br><span class="line">    x = identity_block(x, <span class="number">3</span>, [<span class="number">64</span>, <span class="number">64</span>, <span class="number">256</span>], stage=<span class="number">2</span>, block=<span class="string">&#x27;b&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Height/4,Width/4,256</span></span><br><span class="line">    C2 = x = identity_block(x, <span class="number">3</span>, [<span class="number">64</span>, <span class="number">64</span>, <span class="number">256</span>], stage=<span class="number">2</span>, block=<span class="string">&#x27;c&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Stage 3</span></span><br><span class="line">    x = conv_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">&#x27;a&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    x = identity_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">&#x27;b&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    x = identity_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">&#x27;c&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Height/8,Width/8,512</span></span><br><span class="line">    C3 = x = identity_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">&#x27;d&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Stage 4</span></span><br><span class="line">    x = conv_block(x, <span class="number">3</span>, [<span class="number">256</span>, <span class="number">256</span>, <span class="number">1024</span>], stage=<span class="number">4</span>, block=<span class="string">&#x27;a&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    block_count = <span class="number">22</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(block_count):</span><br><span class="line">        x = identity_block(x, <span class="number">3</span>, [<span class="number">256</span>, <span class="number">256</span>, <span class="number">1024</span>], stage=<span class="number">4</span>, block=<span class="built_in">chr</span>(<span class="number">98</span> + i), train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Height/16,Width/16,1024</span></span><br><span class="line">    C4 = x</span><br><span class="line">    <span class="comment"># Stage 5</span></span><br><span class="line">    <span class="keyword">if</span> stage5:</span><br><span class="line">        x = conv_block(x, <span class="number">3</span>, [<span class="number">512</span>, <span class="number">512</span>, <span class="number">2048</span>], stage=<span class="number">5</span>, block=<span class="string">&#x27;a&#x27;</span>, train_bn=train_bn)</span><br><span class="line">        x = identity_block(x, <span class="number">3</span>, [<span class="number">512</span>, <span class="number">512</span>, <span class="number">2048</span>], stage=<span class="number">5</span>, block=<span class="string">&#x27;b&#x27;</span>, train_bn=train_bn)</span><br><span class="line">        <span class="comment"># Height/32,Width/32,2048</span></span><br><span class="line">        C5 = x = identity_block(x, <span class="number">3</span>, [<span class="number">512</span>, <span class="number">512</span>, <span class="number">2048</span>], stage=<span class="number">5</span>, block=<span class="string">&#x27;c&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        C5 = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> [C1, C2, C3, C4, C5]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关于残差神经网络，可以参考此文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/349717627">ResNet：残差神经网络</a></p>
<h2 id="2-2-Feature-Pyramid-FPN构建特征金字塔">2.2 Feature Pyramid-FPN构建特征金字塔</h2>
<p>上文经过主干特征提取后可以得到长宽压缩了两次C2、三次C3、四次C4、五次C5的结果，用这些结果进行特征金字塔的构造，主要是为了得到P2~P6五个有效特征层。</p>
<p><img src="https://img.mahaofei.com/img/20220515162541.png" alt=""></p>
<p>具体过程为：</p>
<ul>
<li>P5：对【C5】进行一次256通道的卷积，再进行一次256通道的卷积，得到P5。</li>
<li>P6：将P5进行最大池化得到P6。</li>
<li>P4：将【C5一次卷积的结果】进行上采样，再与【C4进行256通道卷积的结果】的进行Add运算，再进行一次256通道的卷积，得到P4。</li>
<li>P3、P2过程类似P4。</li>
</ul>
<p>提取到的P2、P3、P4、P5、P6可以作为RPN网络的有效特征层，利用RPN建议框网络对有效特征层进行下一步的操作，对先验框进行解码获得建议框。</p>
<p>提取到的P2、P3、P4、P5可以作为Classifier和Mask网络的有效特征层，利用Classifier预测框网络对有效特征层进行下一步的操作，对建议框解码获得最终预测框；利用Mask语义分割网络对有效特征层进行下一步的操作，获得每一个预测框内部的语义分割结果。</p>
<p>具体代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获得Resnet里的压缩程度不同的一些层</span></span><br><span class="line">_, C2, C3, C4, C5 = get_resnet(input_image, stage5=<span class="literal">True</span>, train_bn=config.TRAIN_BN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合成特征金字塔的结构</span></span><br><span class="line"><span class="comment"># P5长宽共压缩了5次</span></span><br><span class="line"><span class="comment"># Height/32,Width/32,256</span></span><br><span class="line">P5 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">&#x27;fpn_c5p5&#x27;</span>)(C5)</span><br><span class="line"><span class="comment"># P4长宽共压缩了4次</span></span><br><span class="line"><span class="comment"># Height/16,Width/16,256</span></span><br><span class="line">P4 = Add(name=<span class="string">&quot;fpn_p4add&quot;</span>)([</span><br><span class="line">    UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&quot;fpn_p5upsampled&quot;</span>)(P5),</span><br><span class="line">    Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">&#x27;fpn_c4p4&#x27;</span>)(C4)])</span><br><span class="line"><span class="comment"># P4长宽共压缩了3次</span></span><br><span class="line"><span class="comment"># Height/8,Width/8,256</span></span><br><span class="line">P3 = Add(name=<span class="string">&quot;fpn_p3add&quot;</span>)([</span><br><span class="line">    UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&quot;fpn_p4upsampled&quot;</span>)(P4),</span><br><span class="line">    Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">&#x27;fpn_c3p3&#x27;</span>)(C3)])</span><br><span class="line"><span class="comment"># P4长宽共压缩了2次</span></span><br><span class="line"><span class="comment"># Height/4,Width/4,256</span></span><br><span class="line">P2 = Add(name=<span class="string">&quot;fpn_p2add&quot;</span>)([</span><br><span class="line">    UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&quot;fpn_p3upsampled&quot;</span>)(P3),</span><br><span class="line">    Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">&#x27;fpn_c2p2&#x27;</span>)(C2)])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 各自进行一次256通道的卷积，此时P2、P3、P4、P5通道数相同</span></span><br><span class="line"><span class="comment"># Height/4,Width/4,256</span></span><br><span class="line">P2 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;SAME&quot;</span>, name=<span class="string">&quot;fpn_p2&quot;</span>)(P2)</span><br><span class="line"><span class="comment"># Height/8,Width/8,256</span></span><br><span class="line">P3 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;SAME&quot;</span>, name=<span class="string">&quot;fpn_p3&quot;</span>)(P3)</span><br><span class="line"><span class="comment"># Height/16,Width/16,256</span></span><br><span class="line">P4 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;SAME&quot;</span>, name=<span class="string">&quot;fpn_p4&quot;</span>)(P4)</span><br><span class="line"><span class="comment"># Height/32,Width/32,256</span></span><br><span class="line">P5 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;SAME&quot;</span>, name=<span class="string">&quot;fpn_p5&quot;</span>)(P5)</span><br><span class="line"><span class="comment"># 在建议框网络里面还有一个P6用于获取建议框</span></span><br><span class="line"><span class="comment"># Height/64,Width/64,256</span></span><br><span class="line">P6 = MaxPooling2D(pool_size=(<span class="number">1</span>, <span class="number">1</span>), strides=<span class="number">2</span>, name=<span class="string">&quot;fpn_p6&quot;</span>)(P5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># P2, P3, P4, P5, P6可以用于获取建议框</span></span><br><span class="line">rpn_feature_maps = [P2, P3, P4, P5, P6]</span><br><span class="line"><span class="comment"># P2, P3, P4, P5用于获取mask信息</span></span><br><span class="line">mrcnn_feature_maps = [P2, P3, P4, P5]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-3-构建RPN建议网络模型">2.3 构建RPN建议网络模型</h2>
<p>RPN建议网络的模型</p>
<ul>
<li>首先进行一次3x3的通道为512的卷积</li>
<li>然后分别进行一次<code>anchors_per_location x 2</code>的卷积和<code>anchors_per_location x 4</code>的卷积。
<ul>
<li><code>anchors_per_location x 2</code>的卷积用于预测<strong>公共特征层上 每一个网格点上 每一个预测框</strong>内部是否包含物体。</li>
<li><code>anchors_per_location x 4</code>的卷积用于预测<strong>公共特征层上 每一个网格点上 每一个先验框</strong>的变化情况。</li>
</ul>
</li>
</ul>
<p>例如输入图片的shape是1024x1024x3时，公共特征层的shape就是256x256x256、128x128x256、64x64x256、32x32x256、16x16x256。这些公共特征层上的每一个点，映射到原始图片上就是间隔不同的网格点，每个网格默认存在3(anchors_per_location)个先验框，这些先验框有不同的大小。</p>
<p><img src="https://img.mahaofei.com/img/20220516162352.png" alt=""></p>
<p><strong>anchors_per_location x 4的卷积</strong>的结果会对这些先验框进行调整，获得一个新的框。<br>
<strong>anchors_per_location x 2的卷积</strong>会判断上述获得的新框是否包含物体。</p>
<p>到这里我们可以获得了一些有用的框，这些框会利用<strong>anchors_per_location x 2的卷积</strong>判断是否存在物体。</p>
<p>实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="comment">#   五个不同大小的特征层会传入到</span></span><br><span class="line"><span class="comment">#   RPN当中，获得建议框</span></span><br><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rpn_graph</span>(<span class="params">feature_map, anchors_per_location</span>):</span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    <span class="comment">#   利用一个3x3卷积进行特征整合，基础的层</span></span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    shared = Conv2D(<span class="number">512</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;rpn_conv_shared&#x27;</span>)(feature_map)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    <span class="comment">#   batch_size, num_anchors, 2</span></span><br><span class="line">    <span class="comment">#   代表这个先验框是否包含物体</span></span><br><span class="line">    <span class="comment">#   anchor_per_location的默认值是3</span></span><br><span class="line">    <span class="comment">#   意味着特征层对图像进行网格的划分后，每个网格上先验框的数量是3</span></span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    x = Conv2D(anchors_per_location * <span class="number">2</span>, (<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">&#x27;valid&#x27;</span>, activation=<span class="string">&#x27;linear&#x27;</span>, name=<span class="string">&#x27;rpn_class_raw&#x27;</span>)(shared)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># reshape到最后一个维度是2的维度，是一个分类网络，有非常多先验框</span></span><br><span class="line">    rpn_class_logits = Reshape([-<span class="number">1</span>,<span class="number">2</span>])(x)</span><br><span class="line">    rpn_probs = Activation(<span class="string">&quot;softmax&quot;</span>, name=<span class="string">&quot;rpn_class_xxx&quot;</span>)(rpn_class_logits)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    <span class="comment">#   batch_size, num_anchors, 4</span></span><br><span class="line">    <span class="comment">#   这个先验框的调整参数</span></span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    x = Conv2D(anchors_per_location * <span class="number">4</span>, (<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">&quot;valid&quot;</span>, activation=<span class="string">&#x27;linear&#x27;</span>, name=<span class="string">&#x27;rpn_bbox_pred&#x27;</span>)(shared)</span><br><span class="line">    rpn_bbox = Reshape([-<span class="number">1</span>, <span class="number">4</span>])(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出包括：</span></span><br><span class="line">    <span class="comment"># 先验框是否真实的包含物体</span></span><br><span class="line">    <span class="comment"># bbox先验框的调整参数</span></span><br><span class="line">    <span class="keyword">return</span> [rpn_class_logits, rpn_probs, rpn_bbox]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="comment">#   建立建议框网络模型</span></span><br><span class="line"><span class="comment">#   RPN模型</span></span><br><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_rpn_model</span>(<span class="params">anchors_per_location, depth</span>):</span><br><span class="line">    <span class="comment"># 输入的长和宽都是None，代表输入的有效特征层大小是变化的，256、64等都可以</span></span><br><span class="line">    <span class="comment"># 输入的depth是256</span></span><br><span class="line">    input_feature_map = Input(shape=[<span class="literal">None</span>, <span class="literal">None</span>, depth], name=<span class="string">&quot;input_rpn_feature_map&quot;</span>)</span><br><span class="line">    <span class="comment"># 将输入的图像传入到rpn_graph中</span></span><br><span class="line">    outputs = rpn_graph(input_feature_map, anchors_per_location)</span><br><span class="line">    <span class="keyword">return</span> Model([input_feature_map], outputs, name=<span class="string">&quot;rpn_model&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="2-4-Anchors先验框的获取">2.4 Anchors先验框的获取</h2>
<p><strong>先验框就是图像上的一定的区域，这些区域是人为规定好的</strong>，这些区域可能包含物体，可能不包含物体，我们网络的预测结果就会判断哪些先验框是包含物体的，然后对先验框进行调整。</p>
<p>在MaskRCNN中，建议框网络的预测结果就会对这些先验框进行调整，获得建议框，并判断哪些先验框是包含物体的。</p>
<p>本节介绍如何获得<strong>先验框</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#  Anchors</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_anchors</span>(<span class="params">scales, ratios, shape, feature_stride, anchor_stride</span>):</span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   获得所有框的长度和比例的组合</span></span><br><span class="line">    <span class="comment">#   相当于在每一个网格点上获得了两个长方形(1:2)、(2:1)和一个正方形</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    scales, ratios = np.meshgrid(np.array(scales), np.array(ratios))</span><br><span class="line">    scales = scales.flatten()</span><br><span class="line">    ratios = ratios.flatten()</span><br><span class="line">    heights = scales / np.sqrt(ratios)</span><br><span class="line">    widths = scales * np.sqrt(ratios)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   生成网格中心</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    shifts_y = np.arange(<span class="number">0</span>, shape[<span class="number">0</span>], anchor_stride) * feature_stride</span><br><span class="line">    shifts_x = np.arange(<span class="number">0</span>, shape[<span class="number">1</span>], anchor_stride) * feature_stride</span><br><span class="line">    shifts_x, shifts_y = np.meshgrid(shifts_x, shifts_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   获得先验框的中心和宽高</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    box_widths, box_centers_x = np.meshgrid(widths, shifts_x)</span><br><span class="line">    box_heights, box_centers_y = np.meshgrid(heights, shifts_y)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   更变格式</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment"># 对先验框的中心堆叠，然后reshape，reshape后的结果代表每一个先验框的中心坐标</span></span><br><span class="line">    box_centers = np.stack([box_centers_y, box_centers_x], axis=<span class="number">2</span>).reshape([-<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="comment"># 对先验框的高和宽堆叠，然后reshape，reshape后的结果代表每一个先验框的高和宽</span></span><br><span class="line">    box_sizes = np.stack([box_heights, box_widths], axis=<span class="number">2</span>).reshape([-<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   计算出(y1, x1, y2, x2)</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    boxes = np.concatenate([box_centers - <span class="number">0.5</span> * box_sizes, box_centers + <span class="number">0.5</span> * box_sizes], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> boxes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成特征金字塔先验框</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_pyramid_anchors</span>(<span class="params">scales, ratios, feature_shapes, feature_strides,  anchor_stride</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成不同特征层的anchors，并利用concatenate进行堆叠</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   Anchors</span></span><br><span class="line">    <span class="comment">#   [anchor_count, (y1, x1, y2, x2)]</span></span><br><span class="line">    <span class="comment">#   P2对应的scale是32</span></span><br><span class="line">    <span class="comment">#   P3对应的scale是64</span></span><br><span class="line">    <span class="comment">#   P4对应的scale是128</span></span><br><span class="line">    <span class="comment">#   P5对应的scale是256</span></span><br><span class="line">    <span class="comment">#   P6对应的scale是512</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    anchors = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对scales进行for循环，是传入的anchor_scales，是32、64、128、256、512</span></span><br><span class="line">    <span class="comment"># 对应不同特征层上先验框的基础大小，再在此基础上获得调整，获得不同长宽大小的先验框</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scales)):</span><br><span class="line">        <span class="comment"># ratio的值是0.5、1、2，对应每个网格点上三个先验框</span></span><br><span class="line">        <span class="comment"># feature_shapes就是获得的每一个有效特征层的大小，代表我们要将图片分割成多少网格</span></span><br><span class="line">        <span class="comment"># feature_strides对应backbone_strides，是4、8、16、32、64</span></span><br><span class="line">        <span class="comment"># anchor_stride的值为1</span></span><br><span class="line">        anchors.append(generate_anchors(scales[i], ratios, feature_shapes[i], feature_strides[i], anchor_stride))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.concatenate(anchors, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_backbone_shapes</span>(<span class="params">config, image_shape</span>):</span><br><span class="line">    <span class="keyword">return</span> np.array( [[<span class="built_in">int</span>(math.ceil(image_shape[<span class="number">0</span>] / stride)), <span class="built_in">int</span>(math.ceil(image_shape[<span class="number">1</span>] / stride))] <span class="keyword">for</span> stride <span class="keyword">in</span> config.BACKBONE_STRIDES])</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用下面的函数获取先验框</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_anchors</span>(<span class="params">config, image_shape</span>):</span><br><span class="line">    <span class="comment"># 计算主干特征提取网络获得的有效特征层的shape</span></span><br><span class="line">    <span class="comment"># 为了事先放置先验框，我们需要知道网格大小，因此需要先获得有效特征层的shape</span></span><br><span class="line">    backbone_shapes = compute_backbone_shapes(config, image_shape)</span><br><span class="line">    anchor_cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">tuple</span>(image_shape) <span class="keyword">in</span> anchor_cache:</span><br><span class="line">        <span class="comment"># 将backbone_shapes传入下面的函数</span></span><br><span class="line">        <span class="comment"># 生成特征金字塔的先验框</span></span><br><span class="line">        a = generate_pyramid_anchors(</span><br><span class="line">            config.RPN_ANCHOR_SCALES,</span><br><span class="line">            config.RPN_ANCHOR_RATIOS,</span><br><span class="line">            backbone_shapes,</span><br><span class="line">            config.BACKBONE_STRIDES,</span><br><span class="line">            config.RPN_ANCHOR_STRIDE)</span><br><span class="line">        anchor_cache[<span class="built_in">tuple</span>(image_shape)] = norm_boxes(a, image_shape[:<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> anchor_cache[<span class="built_in">tuple</span>(image_shape)]</span><br></pre></td></tr></table></figure>
<h2 id="2-5-先验框调整获得建议框">2.5 先验框调整获得建议框</h2>
<p>利用<code>ProposalLayer</code>对先验框解码获取建议框。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   对先验框进行解码，获得先验框解码后的建议框的坐标</span></span><br><span class="line">    <span class="comment">#   rpn_rois            : Batch_size, proposal_count, 4</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line">    proposal_count = config.POST_NMS_ROIS_TRAINING</span><br><span class="line">    rpn_rois = ProposalLayer(proposal_count=proposal_count, nms_threshold=config.RPN_NMS_THRESHOLD, name=<span class="string">&quot;ROI&quot;</span>, config=config)([rpn_class, rpn_bbox, anchors])</span><br><span class="line">    active_class_ids = Lambda(<span class="keyword">lambda</span> x: parse_image_meta_graph(x)[<span class="string">&quot;active_class_ids&quot;</span>])(input_image_meta)</span><br></pre></td></tr></table></figure>
<p>输入参数有三个分别是<code>rpn_class</code>、<code>rpn_bbox</code>、<code>anchors</code>，这里的<code>rpn_class</code>代表所有先验框是否包含物体的置信度，<code>rpn_bbox</code>代表所有先验框的调整参数，<code>anchors</code>之前获得的所有先验框。</p>
<p>其中<code>ProposalLayer</code>的具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   Proposal Layer</span></span><br><span class="line"><span class="comment">#   该部分代码用于将先验框转化成建议框</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProposalLayer</span>(<span class="title class_ inherited__">Layer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, proposal_count, nms_threshold, config=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(ProposalLayer, self).__init__(**kwargs)</span><br><span class="line">        self.config = config</span><br><span class="line">        self.proposal_count = proposal_count</span><br><span class="line">        self.nms_threshold = nms_threshold</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   输入的inputs有三个内容</span></span><br><span class="line">        <span class="comment">#   inputs[0]   rpn_class   : Batch_size, num_anchors, 2</span></span><br><span class="line">        <span class="comment">#   inputs[1]   rpn_bbox    : Batch_size, num_anchors, 4</span></span><br><span class="line">        <span class="comment">#   inputs[2]   anchors     : Batch_size, num_anchors, 4</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得先验框内部是否有物体[Batch_size, num_anchors, 1]</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        scores = inputs[<span class="number">0</span>][:, :, <span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得先验框的调整参数[batch, num_rois, 4]</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        deltas = inputs[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得先验框的坐标</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        anchors = inputs[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   RPN_BBOX_STD_DEV[0.1 0.1 0.2 0.2] 改变数量级</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        deltas = deltas * np.reshape(self.config.RPN_BBOX_STD_DEV, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   筛选出得分前6000个的框</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        pre_nms_limit = tf.minimum(self.config.PRE_NMS_LIMIT, tf.shape(anchors)[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得这些框的索引</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        ix = tf.nn.top_k(scores, pre_nms_limit, <span class="built_in">sorted</span>=<span class="literal">True</span>, name=<span class="string">&quot;top_anchors&quot;</span>).indices</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得先验框、及其得分与调整参数</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        scores = batch_slice([scores, ix], <span class="keyword">lambda</span> x, y: tf.gather(x, y), self.config.IMAGES_PER_GPU)</span><br><span class="line">        deltas = batch_slice([deltas, ix], <span class="keyword">lambda</span> x, y: tf.gather(x, y), self.config.IMAGES_PER_GPU)</span><br><span class="line">        pre_nms_anchors = batch_slice([anchors, ix], <span class="keyword">lambda</span> a, x: tf.gather(a, x), self.config.IMAGES_PER_GPU, names=[<span class="string">&quot;pre_nms_anchors&quot;</span>])</span><br><span class="line">  </span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   [batch, pre_nms_limit, (y1, x1, y2, x2)]</span></span><br><span class="line">        <span class="comment">#   对先验框进行解码</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        boxes = batch_slice([pre_nms_anchors, deltas], <span class="keyword">lambda</span> x, y: apply_box_deltas_graph(x, y), self.config.IMAGES_PER_GPU, names=[<span class="string">&quot;refined_anchors&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   [batch, pre_nms_limit, (y1, x1, y2, x2)]</span></span><br><span class="line">        <span class="comment">#   防止超出图片范围</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        window = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], dtype=np.float32)</span><br><span class="line">        boxes = batch_slice(boxes, <span class="keyword">lambda</span> x: clip_boxes_graph(x, window), self.config.IMAGES_PER_GPU, names=[<span class="string">&quot;refined_anchors_clipped&quot;</span>])</span><br><span class="line">  </span><br><span class="line">        <span class="comment">#---------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   在非极大抑制后</span></span><br><span class="line">        <span class="comment">#   获得一个shape为[batch, NMS_ROIS, 4]的proposals</span></span><br><span class="line">        <span class="comment">#---------------------------------------------------------#</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">nms</span>(<span class="params">boxes, scores</span>):</span><br><span class="line">            indices = tf.image.non_max_suppression(boxes, scores, self.proposal_count, self.nms_threshold, name=<span class="string">&quot;rpn_non_max_suppression&quot;</span>)</span><br><span class="line">            proposals = tf.gather(boxes, indices)</span><br><span class="line">            padding = tf.maximum(self.proposal_count - tf.shape(proposals)[<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">            proposals = tf.pad(proposals, [(<span class="number">0</span>, padding), (<span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line">            <span class="keyword">return</span> proposals</span><br><span class="line">        proposals = batch_slice([boxes, scores], nms, self.config.IMAGES_PER_GPU)</span><br><span class="line">        <span class="keyword">return</span> proposals</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute_output_shape</span>(<span class="params">self, input_shape</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">None</span>, self.proposal_count, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>其中利用到了下面的函数对建议框的位置和长宽进行调整</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   利用先验框调整参数调整先验框，获得建议框的坐标</span></span><br><span class="line"><span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply_box_deltas_graph</span>(<span class="params">boxes, deltas</span>):</span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    <span class="comment">#   计算先验框的中心和宽高</span></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    height = boxes[:, <span class="number">2</span>] - boxes[:, <span class="number">0</span>]</span><br><span class="line">    width = boxes[:, <span class="number">3</span>] - boxes[:, <span class="number">1</span>]</span><br><span class="line">    center_y = boxes[:, <span class="number">0</span>] + <span class="number">0.5</span> * height</span><br><span class="line">    center_x = boxes[:, <span class="number">1</span>] + <span class="number">0.5</span> * width</span><br><span class="line"></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    <span class="comment">#   计算出调整后的先验框的中心和宽高</span></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    center_y += deltas[:, <span class="number">0</span>] * height</span><br><span class="line">    center_x += deltas[:, <span class="number">1</span>] * width</span><br><span class="line">    height *= tf.exp(deltas[:, <span class="number">2</span>])</span><br><span class="line">    width *= tf.exp(deltas[:, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    <span class="comment">#   计算左上角和右下角的点的坐标</span></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    y1 = center_y - <span class="number">0.5</span> * height</span><br><span class="line">    x1 = center_x - <span class="number">0.5</span> * width</span><br><span class="line">    y2 = y1 + height</span><br><span class="line">    x2 = x1 + width</span><br><span class="line"></span><br><span class="line">    result = tf.stack([y1, x1, y2, x2], axis=<span class="number">1</span>, name=<span class="string">&quot;apply_box_deltas_out&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="2-6-利用建议框对共享特征层进行截取">2.6 利用建议框对共享特征层进行截取</h2>
<p>ROI Align层的作用就是根据建议框对不同的特征层进行截取。主要代码如下，其功能就是根据建议框的大小，判断建议框属于哪一个特征层，然后利用建议框对对应的特征层进行截取。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">#---------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   ROI Pooling，利用建议框在特征层上进行截取</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, POOL_SIZE, POOL_SIZE, channels]</span></span><br><span class="line">    <span class="comment">#   pool_size 是对共享特征层截取后resize后的局部特征层的大小</span></span><br><span class="line">    <span class="comment">#   rois是初步筛选后的建议框</span></span><br><span class="line">    <span class="comment">#   image_meta是保存了图片的必要信息</span></span><br><span class="line">    <span class="comment">#   feature_maps共享特征层</span></span><br><span class="line">    <span class="comment">#---------------------------------------------------------------#</span></span><br><span class="line">    x = PyramidROIAlign([pool_size, pool_size], name=<span class="string">&quot;roi_align_classifier&quot;</span>)([rois, image_meta] + feature_maps)</span><br></pre></td></tr></table></figure>
<p>其中<code>PyramidROIAlign</code>函数的定义如下：</p>
<p>首先获取建议框的坐标、图片信息、特征层。然后根据建议框的大小，判断建议框属于哪一个特征层（较大的特征层比如256x256的，网格划分密集，每一个建议框大小比较小，以此判断）。利用循环对于P2~P5五个特征层进行截取。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   ROIAlign Layer</span></span><br><span class="line"><span class="comment">#   利用建议框在特征层上截取内容</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyramidROIAlign</span>(<span class="title class_ inherited__">Layer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, pool_shape, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(PyramidROIAlign, self).__init__(**kwargs)</span><br><span class="line">        self.pool_shape = <span class="built_in">tuple</span>(pool_shape)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得建议框的坐标</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        boxes = inputs[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   image_meta包含了一些必要的图片信息</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        image_meta = inputs[<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   取出所有的特征层[batch, height, width, channels]</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        feature_maps = inputs[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得建议框的宽高</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        y1, x1, y2, x2 = tf.split(boxes, <span class="number">4</span>, axis=<span class="number">2</span>)</span><br><span class="line">        h = y2 - y1</span><br><span class="line">        w = x2 - x1</span><br><span class="line">  </span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得输入进来的图像的大小，对image的内容进行分割</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        image_shape = parse_image_meta_graph(image_meta)[<span class="string">&#x27;image_shape&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   通过建议框的大小找到这个建议框属于哪个特征层，第一层256划分区域多建议框较小32</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        image_area = tf.cast(image_shape[<span class="number">0</span>] * image_shape[<span class="number">1</span>], tf.float32)</span><br><span class="line">        roi_level = log2_graph(tf.sqrt(h * w) / (<span class="number">224.0</span> / tf.sqrt(image_area)))</span><br><span class="line">        roi_level = tf.minimum(<span class="number">5</span>, tf.maximum(<span class="number">2</span>, <span class="number">4</span> + tf.cast(tf.<span class="built_in">round</span>(roi_level), tf.int32)))</span><br><span class="line">        <span class="comment"># roi_level是每张图片里每个建议框对应的特征层是哪个</span></span><br><span class="line">        roi_level = tf.squeeze(roi_level, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        pooled = []</span><br><span class="line">        box_to_level = []</span><br><span class="line">        <span class="comment"># 分别在P2-P5中进行截取</span></span><br><span class="line">        <span class="keyword">for</span> i, level <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">6</span>)):</span><br><span class="line">            <span class="comment">#-----------------------------------------------#</span></span><br><span class="line">            <span class="comment">#   找到每个特征层对应的建议框</span></span><br><span class="line">            <span class="comment">#   level_boxes存放所有属于该特征层的建议框</span></span><br><span class="line">            <span class="comment">#-----------------------------------------------#</span></span><br><span class="line">            ix = tf.where(tf.equal(roi_level, level))</span><br><span class="line">            level_boxes = tf.gather_nd(boxes, ix)</span><br><span class="line">            box_to_level.append(ix)</span><br><span class="line">  </span><br><span class="line">            <span class="comment">#-----------------------------------------------#</span></span><br><span class="line">            <span class="comment">#    获得这些建议框所属的图片</span></span><br><span class="line">            <span class="comment">#-----------------------------------------------#</span></span><br><span class="line">            box_indices = tf.cast(ix[:, <span class="number">0</span>], tf.int32)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 停止梯度下降</span></span><br><span class="line">            level_boxes = tf.stop_gradient(level_boxes)</span><br><span class="line">            box_indices = tf.stop_gradient(box_indices)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">            <span class="comment">#   利用建议框对特征层进行截取  </span></span><br><span class="line">            <span class="comment">#   [batch * num_boxes, pool_height, pool_width, channels]</span></span><br><span class="line">            <span class="comment">#   box_indices表示是截取哪张图片里的特征层</span></span><br><span class="line">            <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">            pooled.append(tf.image.crop_and_resize(</span><br><span class="line">                feature_maps[i], level_boxes, box_indices, self.pool_shape,</span><br><span class="line">                method=<span class="string">&quot;bilinear&quot;</span>))</span><br><span class="line"></span><br><span class="line">        pooled = tf.concat(pooled, axis=<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   将顺序和所属的图片进行堆叠</span></span><br><span class="line">        <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">        box_to_level = tf.concat(box_to_level, axis=<span class="number">0</span>)</span><br><span class="line">        box_range = tf.expand_dims(tf.<span class="built_in">range</span>(tf.shape(box_to_level)[<span class="number">0</span>]), <span class="number">1</span>)</span><br><span class="line">        box_to_level = tf.concat([tf.cast(box_to_level, tf.int32), box_range], axis=<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">        <span class="comment"># box_to_level[:, 0]表示第几张图</span></span><br><span class="line">        <span class="comment"># box_to_level[:, 1]表示第几张图里的第几个框</span></span><br><span class="line">        sorting_tensor = box_to_level[:, <span class="number">0</span>] * <span class="number">100000</span> + box_to_level[:, <span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 进行排序，将同一张图里的某一些聚集在一起</span></span><br><span class="line">        ix = tf.nn.top_k(sorting_tensor, k=tf.shape(</span><br><span class="line">            box_to_level)[<span class="number">0</span>]).indices[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按顺序获得图片的索引</span></span><br><span class="line">        ix = tf.gather(box_to_level[:, <span class="number">2</span>], ix)</span><br><span class="line">        pooled = tf.gather(pooled, ix)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   重新reshape为如下</span></span><br><span class="line">        <span class="comment">#   [batch, num_rois, POOL_SIZE, POOL_SIZE, channels]</span></span><br><span class="line">        <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">        shape = tf.concat([tf.shape(boxes)[:<span class="number">2</span>], tf.shape(pooled)[<span class="number">1</span>:]], axis=<span class="number">0</span>)</span><br><span class="line">        pooled = tf.reshape(pooled, shape)</span><br><span class="line">        <span class="keyword">return</span> pooled</span><br></pre></td></tr></table></figure>
<h2 id="2-7-局部公用特征层到预测结果">2.7 局部公用特征层到预测结果</h2>
<p>如何利用调整后的局部特征层获得预测结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    mrcnn_class_logits, mrcnn_class, mrcnn_bbox =\</span><br><span class="line"></span><br><span class="line">        fpn_classifier_graph(rpn_rois, mrcnn_feature_maps, input_image_meta,</span><br><span class="line"></span><br><span class="line">                                config.POOL_SIZE, config.NUM_CLASSES,</span><br><span class="line"></span><br><span class="line">                                train_bn=config.TRAIN_BN,</span><br><span class="line"></span><br><span class="line">                                fc_layers_size=config.FPN_CLASSIF_FC_LAYERS_SIZE)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="comment">#   建立classifier模型，该函数主要实现目标检测功能</span></span><br><span class="line"><span class="comment">#   这个模型的预测结果会调整建议框</span></span><br><span class="line"><span class="comment">#   获得最终的预测框</span></span><br><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fpn_classifier_graph</span>(<span class="params">rois, feature_maps, image_meta,</span></span><br><span class="line"><span class="params">                         pool_size, num_classes, train_bn=<span class="literal">True</span>,</span></span><br><span class="line"><span class="params">                         fc_layers_size=<span class="number">1024</span></span>):</span><br><span class="line">    <span class="comment">#---------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   ROI Pooling，利用建议框在特征层上进行截取</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, POOL_SIZE, POOL_SIZE, channels]，调整后的局部特征层</span></span><br><span class="line">    <span class="comment">#   pool_size 是对共享特征层截取后resize后的局部特征层的大小</span></span><br><span class="line">    <span class="comment">#   rois是初步筛选后的建议框</span></span><br><span class="line">    <span class="comment">#   image_meta是保存了图片的必要信息</span></span><br><span class="line">    <span class="comment">#   feature_maps共享特征层</span></span><br><span class="line">    <span class="comment">#---------------------------------------------------------------#</span></span><br><span class="line">    x = PyramidROIAlign([pool_size, pool_size], name=<span class="string">&quot;roi_align_classifier&quot;</span>)([rois, image_meta] + feature_maps)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   利用卷积进行特征整合，首先进行7x7的卷积，相当于两次全连接</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, 1, 1, fc_layers_size]</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(fc_layers_size, (pool_size, pool_size), padding=<span class="string">&quot;valid&quot;</span>),  name=<span class="string">&quot;mrcnn_class_conv1&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_class_bn1&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, 1, 1, fc_layers_size]</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(fc_layers_size, (<span class="number">1</span>, <span class="number">1</span>)), name=<span class="string">&quot;mrcnn_class_conv2&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_class_bn2&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, fc_layers_size]</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    shared = Lambda(<span class="keyword">lambda</span> x: K.squeeze(K.squeeze(x, <span class="number">3</span>), <span class="number">2</span>),  name=<span class="string">&quot;pool_squeeze&quot;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   Classifier head</span></span><br><span class="line">    <span class="comment">#   这个的预测结果代表这个先验框内部的物体的种类</span></span><br><span class="line">    <span class="comment">#   mrcnn_probs   : [batch, num_rois, num_classes]，每一张图片里，每一个先验框里面，物体的种类</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    mrcnn_class_logits = TimeDistributed(Dense(num_classes), name=<span class="string">&#x27;mrcnn_class_logits&#x27;</span>)(shared)</span><br><span class="line">    mrcnn_probs = TimeDistributed(Activation(<span class="string">&quot;softmax&quot;</span>), name=<span class="string">&quot;mrcnn_class&quot;</span>)(mrcnn_class_logits)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   BBox head</span></span><br><span class="line">    <span class="comment">#   这个的预测结果会对先验框进行调整</span></span><br><span class="line">    <span class="comment">#   mrcnn_bbox : [batch, num_rois, num_classes, 4]</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Dense(num_classes * <span class="number">4</span>, activation=<span class="string">&#x27;linear&#x27;</span>), name=<span class="string">&#x27;mrcnn_bbox_fc&#x27;</span>)(shared)</span><br><span class="line">    mrcnn_bbox = Reshape((-<span class="number">1</span>, num_classes, <span class="number">4</span>), name=<span class="string">&quot;mrcnn_bbox&quot;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mrcnn_class_logits, mrcnn_probs, mrcnn_bbox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------#</span></span><br><span class="line"><span class="comment">#   建立mask模型</span></span><br><span class="line"><span class="comment">#   这个模型会利用预测框对特征层进行ROIAlign</span></span><br><span class="line"><span class="comment">#   根据截取下来的特征层进行语义分割</span></span><br><span class="line"><span class="comment">#----------------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_fpn_mask_graph</span>(<span class="params">rois, feature_maps, image_meta,</span></span><br><span class="line"><span class="params">                         pool_size, num_classes, train_bn=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   ROI Pooling，利用预测框在特征层上进行截取</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, channels</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = PyramidROIAlign([pool_size, pool_size], name=<span class="string">&quot;roi_align_mask&quot;</span>)([rois, image_meta] + feature_maps)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;same&quot;</span>), name=<span class="string">&quot;mrcnn_mask_conv1&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_mask_bn1&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;same&quot;</span>), name=<span class="string">&quot;mrcnn_mask_conv2&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_mask_bn2&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;same&quot;</span>), name=<span class="string">&quot;mrcnn_mask_conv3&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_mask_bn3&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;same&quot;</span>), name=<span class="string">&quot;mrcnn_mask_conv4&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_mask_bn4&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, 2xMASK_POOL_SIZE, 2xMASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2DTranspose(<span class="number">256</span>, (<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>, activation=<span class="string">&quot;relu&quot;</span>), name=<span class="string">&quot;mrcnn_mask_deconv&quot;</span>)(x)</span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   反卷积后再次进行一个1x1卷积调整通道，</span></span><br><span class="line">    <span class="comment">#   使其最终数量为numclasses，代表分的类</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, 2xMASK_POOL_SIZE, 2xMASK_POOL_SIZE, numclasses</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(num_classes, (<span class="number">1</span>, <span class="number">1</span>), strides=<span class="number">1</span>, activation=<span class="string">&quot;sigmoid&quot;</span>), name=<span class="string">&quot;mrcnn_mask&quot;</span>)(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h2 id="2-8-建议框调整获得预测框">2.8 建议框调整获得预测框</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   detections          : Batch_size, num_detections, 6</span></span><br><span class="line"><span class="comment">#   detection_boxes     : Batch_size, num_detections, 4</span></span><br><span class="line"><span class="comment">#------------------------------------------------------------#</span></span><br><span class="line">detections = DetectionLayer(config, name=<span class="string">&quot;mrcnn_detection&quot;</span>)([rpn_rois, mrcnn_class, mrcnn_bbox, input_image_meta])</span><br><span class="line">detection_boxes = Lambda(<span class="keyword">lambda</span> x: x[..., :<span class="number">4</span>])(detections)</span><br></pre></td></tr></table></figure>
<p>我们的工作都发生在<code>DetectionLayer</code>四个参数分别是rpn_rois建议框、mrcnn_class建议内部物体的置信度、mrcnn_bbox建议框的调整参数、input_image_meta输入图片的基本信息。</p>
<p>其中<code>DetectionLayer</code>的定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   Detection Layer</span></span><br><span class="line"><span class="comment">#   利用classifier的预测结果对建议框进行调整获得预测框</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DetectionLayer</span>(<span class="title class_ inherited__">Layer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(DetectionLayer, self).__init__(**kwargs)</span><br><span class="line">        self.config = config</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得的inputs</span></span><br><span class="line">        <span class="comment">#   rpn_rois            : Batch_size, proposal_count, 4</span></span><br><span class="line">        <span class="comment">#   mrcnn_class         : Batch_size, num_rois, num_classes</span></span><br><span class="line">        <span class="comment">#   mrcnn_bbox          : Batch_size, num_rois, num_classes, </span></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        rois = inputs[<span class="number">0</span>]</span><br><span class="line">        mrcnn_class = inputs[<span class="number">1</span>]</span><br><span class="line">        mrcnn_bbox = inputs[<span class="number">2</span>]</span><br><span class="line">        image_meta = inputs[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   找到window的小数形式，指出原始的图片在调整后（加灰条）图片中的位置</span></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        m = parse_image_meta_graph(image_meta)</span><br><span class="line">        image_shape = m[<span class="string">&#x27;image_shape&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        window = norm_boxes_graph(m[<span class="string">&#x27;window&#x27;</span>], image_shape[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   对每一张图的结果进行解码</span></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        detections_batch = batch_slice(</span><br><span class="line">            [rois, mrcnn_class, mrcnn_bbox, window],</span><br><span class="line">            <span class="keyword">lambda</span> x, y, w, z: refine_detections_graph(x, y, w, z, self.config),</span><br><span class="line">            self.config.IMAGES_PER_GPU)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   最终输出的shape为</span></span><br><span class="line">        <span class="comment">#   Batch_size, num_detections, 6] </span></span><br><span class="line">        <span class="comment">#------------------------------------------------------------#</span></span><br><span class="line">        <span class="keyword">return</span> tf.reshape(</span><br><span class="line">            detections_batch,</span><br><span class="line">            [self.config.BATCH_SIZE, self.config.DETECTION_MAX_INSTANCES, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>
<h1>三、创建自己的数据集</h1>
<h2 id="3-1-安装labelme">3.1 安装labelme</h2>
<p>打开cmd窗口，输入<code>activate tensorflow2</code>激活自己的anaconda环境。</p>
<p>然后安装labelme</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install labelme</span><br></pre></td></tr></table></figure>
<p>安装完成后直接在命令行输入<code>labelme</code>即可打开。</p>
<p>使用label进行标注，将生成的json文件和原始图像jpg，放入同一个文件夹中。</p>
<h2 id="3-2-转换coco格式">3.2 转换coco格式</h2>
<p>参考<a target="_blank" rel="noopener" href="https://pypi.org/project/labelme2coco/">pypi的labelme2coco包</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install labelme2coco</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者使用清华源</span></span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple labelme2coco</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">labelme2coco path/to/labelme/dir --train_split_rate 0.85</span><br></pre></td></tr></table></figure>
<h2 id="3-2-或者转换成mask掩码图，再数据增广，再转换coco格式">3.2 或者转换成mask掩码图，再数据增广，再转换coco格式</h2>
<p><strong>（1）labelme结果转mask掩码图</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">从./images文件夹中读取图片和json文件</span></span><br><span class="line"><span class="string">生成01_my0003.png和对应的01_my0003.png</span></span><br><span class="line"><span class="string">分别保存在./images/rgb和./images/label文件夹下（先新建）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">obj_dic = &#123;<span class="number">1</span>: <span class="string">&#x27;ammeter&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;realsensebox&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;coffeebox&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;sucker&#x27;</span>&#125;</span><br><span class="line">obj_list = <span class="built_in">list</span>(obj_dic.values())</span><br><span class="line"></span><br><span class="line">dataset_dir = <span class="string">&quot;./MaskRCNN&quot;</span></span><br><span class="line">file_list = os.listdir(dataset_dir)</span><br><span class="line">file_list.sort()</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> file_list:</span><br><span class="line">    <span class="keyword">if</span> filename[-<span class="number">4</span>:] != <span class="string">&#x27;json&#x27;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    img = cv2.imread(os.path.join(dataset_dir, filename[:-<span class="number">5</span>] + <span class="string">&quot;.jpg&quot;</span>))</span><br><span class="line">    json_path = os.path.join(dataset_dir, filename)</span><br><span class="line">    <span class="comment"># 读取标注数据</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(json_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 针对每个标注，将其表示为掩码图像</span></span><br><span class="line">    <span class="keyword">for</span> shape <span class="keyword">in</span> data[<span class="string">&#x27;shapes&#x27;</span>]:</span><br><span class="line">        <span class="comment"># 新建空白图像</span></span><br><span class="line">        mask_img = Image.new(<span class="string">&#x27;L&#x27;</span>, (<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>)    <span class="comment"># 注意！修改成自己图片的分辨率</span></span><br><span class="line">        <span class="comment"># 读取标签点</span></span><br><span class="line">        label_name = shape[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">        label_index = <span class="string">&quot;%02d&quot;</span> % (obj_list.index(label_name) + <span class="number">1</span>)</span><br><span class="line">        polygon_points = shape[<span class="string">&#x27;points&#x27;</span>]</span><br><span class="line">        <span class="comment"># 绘制区域</span></span><br><span class="line">        mask_img_draw = ImageDraw.Draw(mask_img)</span><br><span class="line">        <span class="comment"># mask_img_draw.polygon(polygon_points, outline=1, fill=1)</span></span><br><span class="line">        mask_img_draw.polygon(<span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, polygon_points)), outline=<span class="number">1</span>, fill=<span class="number">1</span>)</span><br><span class="line">        mask_img = cv2.cvtColor(np.array(mask_img)*<span class="number">255</span>, cv2.COLOR_GRAY2BGR)</span><br><span class="line">        <span class="comment"># 将掩码图像保存为PNG文件</span></span><br><span class="line">        mask_path = os.path.join(dataset_dir + <span class="string">&quot;/label&quot;</span>, label_index + <span class="string">&quot;_&quot;</span> + filename)[:-<span class="number">5</span>] + <span class="string">&quot;.png&quot;</span></span><br><span class="line">        img_path = os.path.join(dataset_dir + <span class="string">&quot;/rgb&quot;</span>, label_index + <span class="string">&quot;_&quot;</span> + filename)[:-<span class="number">5</span>] + <span class="string">&quot;.png&quot;</span></span><br><span class="line">        cv2.imwrite(mask_path, mask_img)</span><br><span class="line">        cv2.imwrite(img_path, img)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>（2）数据增广</strong></p>
<p>将rgb图和mask掩码图做同样的变换，得到数据增广的rgb和mask掩码图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> imgaug.augmenters <span class="keyword">as</span> iaa</span><br><span class="line"><span class="keyword">from</span> imgaug.augmentables.segmaps <span class="keyword">import</span> SegmentationMapsOnImage</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">从./MaskRCNN/rgb中读取rgb图像，从./MaskRCNN/label中读取mask图像</span></span><br><span class="line"><span class="string">生成数据增广的rgb图像保存在./MaskRCNN/rgb_aug中，mask掩码图保存在./MaskRCNN/label_aug中（先新建）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像数据增强</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_augmentation</span>(<span class="params">images_folder_path, output_folder_path, augment_times=<span class="number">3</span></span>):</span><br><span class="line">    <span class="comment"># 定义数据增强操作</span></span><br><span class="line">    seq = iaa.Sequential([</span><br><span class="line">        iaa.Sometimes(<span class="number">0.5</span>, iaa.GaussianBlur(sigma=(<span class="number">0</span>, <span class="number">0.5</span>))),</span><br><span class="line">        iaa.Affine(</span><br><span class="line">            scale=&#123;<span class="string">&quot;x&quot;</span>: (<span class="number">0.8</span>, <span class="number">1.2</span>), <span class="string">&quot;y&quot;</span>: (<span class="number">0.8</span>, <span class="number">1.2</span>)&#125;,</span><br><span class="line">            translate_percent=&#123;<span class="string">&quot;x&quot;</span>: (-<span class="number">0.2</span>, <span class="number">0.2</span>), <span class="string">&quot;y&quot;</span>: (-<span class="number">0.2</span>, <span class="number">0.2</span>)&#125;,</span><br><span class="line">            rotate=(-<span class="number">45</span>, <span class="number">45</span>),</span><br><span class="line">            shear=(-<span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">        ),</span><br><span class="line">        iaa.SomeOf((<span class="number">0</span>, <span class="number">5</span>), [</span><br><span class="line">            iaa.OneOf([</span><br><span class="line">                iaa.Dropout(p=(<span class="number">0</span>, <span class="number">0.1</span>)),</span><br><span class="line">                iaa.CoarseDropout(p=(<span class="number">0</span>, <span class="number">0.1</span>), size_percent=(<span class="number">0.02</span>, <span class="number">0.05</span>)),</span><br><span class="line">            ]),</span><br><span class="line">            iaa.AddToHueAndSaturation(value=(-<span class="number">10</span>, <span class="number">10</span>), per_channel=<span class="literal">True</span>),</span><br><span class="line">            iaa.LinearContrast(alpha=(<span class="number">0.95</span>, <span class="number">1.05</span>), per_channel=<span class="literal">True</span>),</span><br><span class="line">            iaa.AdditiveGaussianNoise(scale=(<span class="number">0</span>, <span class="number">0.05</span> * <span class="number">255</span>), per_channel=<span class="literal">True</span>),</span><br><span class="line">            iaa.Multiply((<span class="number">0.8</span>, <span class="number">1.2</span>), per_channel=<span class="number">0.2</span>),</span><br><span class="line">        ], random_order=<span class="literal">True</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取图片列表</span></span><br><span class="line">    img_list = os.listdir(images_folder_path)</span><br><span class="line">    <span class="comment"># 对每张图片进行增强</span></span><br><span class="line">    <span class="keyword">for</span> img_name <span class="keyword">in</span> img_list:</span><br><span class="line">        img_path = os.path.join(images_folder_path, img_name)</span><br><span class="line">        mask_path = img_path.replace(<span class="string">&quot;.png&quot;</span>, <span class="string">&quot;.png&quot;</span>)</span><br><span class="line">        mask_path = mask_path.replace(<span class="string">&quot;rgb&quot;</span>, <span class="string">&quot;label&quot;</span>)</span><br><span class="line">        img = cv2.imread(img_path)</span><br><span class="line">        mask = cv2.imread(mask_path)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(augment_times):</span><br><span class="line">            segmap_mask = SegmentationMapsOnImage(mask, shape=img.shape)</span><br><span class="line">            <span class="comment"># 对 RGB 图像和 mask 掩码图同时进行增强</span></span><br><span class="line">            aug_det = seq.to_deterministic()</span><br><span class="line">            aug_img = aug_det.augment_image(img)</span><br><span class="line">            segmap_aug  = aug_det.augment_segmentation_maps(segmap_mask)</span><br><span class="line"></span><br><span class="line">            aug_mask = segmap_aug .get_arr()</span><br><span class="line">            aug_mask = np.array(aug_mask, dtype=np.uint8)</span><br><span class="line">            thresh, aug_mask_bin = cv2.threshold(aug_mask, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">            <span class="comment"># 定义结构元素</span></span><br><span class="line">            kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>), np.uint8)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对掩码图像进行腐蚀操作</span></span><br><span class="line">            aug_mask_bin = cv2.erode(aug_mask_bin, kernel, iterations=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 保存增强后的图像</span></span><br><span class="line">            output_name = os.path.splitext(img_name)[<span class="number">0</span>] + <span class="string">&#x27;_aug_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i) + os.path.splitext(img_name)[<span class="number">1</span>]</span><br><span class="line">            output_path = os.path.join(output_folder_path, output_name)</span><br><span class="line">            output_mask_name = os.path.splitext(img_name)[<span class="number">0</span>]  + <span class="string">&#x27;_aug_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i) + os.path.splitext(img_name)[<span class="number">1</span>]</span><br><span class="line">            output_mask_path = os.path.join(output_folder_path.replace(<span class="string">&quot;rgb&quot;</span>, <span class="string">&quot;label&quot;</span>), output_mask_name)</span><br><span class="line">            cv2.imwrite(output_path, aug_img)</span><br><span class="line">            cv2.imwrite(output_mask_path, aug_mask_bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    images_folder_path = <span class="string">&#x27;./MaskRCNN/rgb&#x27;</span></span><br><span class="line">    output_folder_path = <span class="string">&#x27;./MaskRCNN/rgb_aug&#x27;</span></span><br><span class="line">    data_augmentation(images_folder_path, output_folder_path)</span><br></pre></td></tr></table></figure>
<p><strong>（3）从rgb和mask图生成coco数据</strong></p>
<h1>四、开始训练</h1>
<p>运行<code>json_to_dataset.py</code>将标注的json图像转换为数据集。</p>
<p>在<code>dataset.py</code>中的<code>load_shapes</code>中添加自己的分类，同时在最后的循环中也添加自己的分类。</p>
<p>在<code>train.py</code>的<code>ShapesConfig</code>修改图片大小，<code>IMAGE_MIN_DIM</code>和<code>IMAGE_MAX_DIM</code>两个图片大小可以一样，<code>NUM_CLASSES</code>后面的数字是分的类</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>经典实例分割模型Mask RCNN</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.mahaofei.com/post/maskrcnn.html">https://www.mahaofei.com/post/maskrcnn.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>马浩飞</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2022-06-11</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2022-06-11</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><a class="post-meta__tags" href="/tags/%E5%AE%9E%E9%AA%8C/">实验</a><a class="post-meta__tags" href="/tags/%E8%A7%86%E8%A7%89/">视觉</a><a class="post-meta__tags" href="/tags/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/">实例分割</a></div><div class="post_share"><div class="social-share" data-image="https://img.mahaofei.com/img/20220515154938.png" data-sites="qq,wechat,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.png" alt="微信支付"/></a><div class="post-qr-code-desc">微信支付</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/deeplearning-note1.html"><img class="prev-cover" src="https://img.mahaofei.com/img/20220426114017.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【深度学习笔记01】神经网络与深度学习</div></div></a></div><div class="next-post pull-right"><a href="/post/deeplearning-buglist.html"><img class="next-cover" src="https://img.mahaofei.com/img/20230225204946.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深度学习Buglist（不定时更新）</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><a href="https://www.mahaofei.com"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></a></div><div class="author-info__name">马浩飞</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">250</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">79</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://academic.mahaofei.com/"><i class="fa-solid fa-graduation-cap"></i><span>学术主页</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/HaofeiMa" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:mail@mahaofei.com" target="_blank" title="E-Mail"><i class="fa fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">新增了<a target="_blank" rel="noopener" href="https://academic.mahaofei.com/">学术主页</a>！<br>有任何问题欢迎留言评论或邮件联系。<br>E-mail：<a href="mailto:blog@mahaofei.com" style="text-decoration:underline;">blog@mahaofei.com</a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">一、Mask RCNN简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">二、Mask R-CNN实现过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Resnet101-%E4%B8%BB%E5%B9%B2%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E7%BD%91%E7%BB%9C"><span class="toc-text">2.1 Resnet101-主干特征提取网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Feature-Pyramid-FPN%E6%9E%84%E5%BB%BA%E7%89%B9%E5%BE%81%E9%87%91%E5%AD%97%E5%A1%94"><span class="toc-text">2.2 Feature Pyramid-FPN构建特征金字塔</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%9E%84%E5%BB%BARPN%E5%BB%BA%E8%AE%AE%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.3 构建RPN建议网络模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Anchors%E5%85%88%E9%AA%8C%E6%A1%86%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-text">2.4 Anchors先验框的获取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%85%88%E9%AA%8C%E6%A1%86%E8%B0%83%E6%95%B4%E8%8E%B7%E5%BE%97%E5%BB%BA%E8%AE%AE%E6%A1%86"><span class="toc-text">2.5 先验框调整获得建议框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%88%A9%E7%94%A8%E5%BB%BA%E8%AE%AE%E6%A1%86%E5%AF%B9%E5%85%B1%E4%BA%AB%E7%89%B9%E5%BE%81%E5%B1%82%E8%BF%9B%E8%A1%8C%E6%88%AA%E5%8F%96"><span class="toc-text">2.6 利用建议框对共享特征层进行截取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E5%B1%80%E9%83%A8%E5%85%AC%E7%94%A8%E7%89%B9%E5%BE%81%E5%B1%82%E5%88%B0%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C"><span class="toc-text">2.7 局部公用特征层到预测结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E5%BB%BA%E8%AE%AE%E6%A1%86%E8%B0%83%E6%95%B4%E8%8E%B7%E5%BE%97%E9%A2%84%E6%B5%8B%E6%A1%86"><span class="toc-text">2.8 建议框调整获得预测框</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">三、创建自己的数据集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%AE%89%E8%A3%85labelme"><span class="toc-text">3.1 安装labelme</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%BD%AC%E6%8D%A2coco%E6%A0%BC%E5%BC%8F"><span class="toc-text">3.2 转换coco格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%88%96%E8%80%85%E8%BD%AC%E6%8D%A2%E6%88%90mask%E6%8E%A9%E7%A0%81%E5%9B%BE%EF%BC%8C%E5%86%8D%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF%EF%BC%8C%E5%86%8D%E8%BD%AC%E6%8D%A2coco%E6%A0%BC%E5%BC%8F"><span class="toc-text">3.2 或者转换成mask掩码图，再数据增广，再转换coco格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">四、开始训练</span></a></li></ol></div></div><div class="card-widget card-recommend-post"><div class="item-headline"><i class="fas fa-dharmachakra"></i><span>相关推荐</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/contact-graspnet.html" title="【抓取算法】Contact GraspNet"><img src="https://img.mahaofei.com/img/20230404152359.png" alt="【抓取算法】Contact GraspNet"></a><div class="content"><a class="title" href="/post/contact-graspnet.html" title="【抓取算法】Contact GraspNet">【抓取算法】Contact GraspNet</a><time datetime="2023-04-07" title="发表于 2023-04-07">2023-04-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/rgb-matters.html" title="【抓取姿态估计算法】RGB Matters论文笔记与复现"><img src="https://img.mahaofei.com/img/202304231549478.png" alt="【抓取姿态估计算法】RGB Matters论文笔记与复现"></a><div class="content"><a class="title" href="/post/rgb-matters.html" title="【抓取姿态估计算法】RGB Matters论文笔记与复现">【抓取姿态估计算法】RGB Matters论文笔记与复现</a><time datetime="2023-05-04" title="发表于 2023-05-04">2023-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/densefusion-code.html" title="【6D位姿估计算法】DenseFusion代码结构"><img src="https://img.mahaofei.com/img/20230225210258.png" alt="【6D位姿估计算法】DenseFusion代码结构"></a><div class="content"><a class="title" href="/post/densefusion-code.html" title="【6D位姿估计算法】DenseFusion代码结构">【6D位姿估计算法】DenseFusion代码结构</a><time datetime="2000-01-01" title="发表于 2000-01-01">2000-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/custom-linemod.html" title="制作自己的Linemod数据集（ObjectDatasetTools）"><img src="https://img.mahaofei.com/img/20220918154609.png" alt="制作自己的Linemod数据集（ObjectDatasetTools）"></a><div class="content"><a class="title" href="/post/custom-linemod.html" title="制作自己的Linemod数据集（ObjectDatasetTools）">制作自己的Linemod数据集（ObjectDatasetTools）</a><time datetime="2022-09-18" title="发表于 2022-09-18">2022-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/gen6d.html" title="【6D位姿估计算法】Gen6D算法"><img src="https://img.mahaofei.com/img/20230327215520.png" alt="【6D位姿估计算法】Gen6D算法"></a><div class="content"><a class="title" href="/post/gen6d.html" title="【6D位姿估计算法】Gen6D算法">【6D位姿估计算法】Gen6D算法</a><time datetime="2023-03-29" title="发表于 2023-03-29">2023-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/gdrnpp.html" title="【6D位姿估计算法】GDRNPP算法"><img src="https://img.mahaofei.com/img/20230316104020.png" alt="【6D位姿估计算法】GDRNPP算法"></a><div class="content"><a class="title" href="/post/gdrnpp.html" title="【6D位姿估计算法】GDRNPP算法">【6D位姿估计算法】GDRNPP算法</a><time datetime="2023-03-27" title="发表于 2023-03-27">2023-03-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://img.mahaofei.com/img/GoodnightCopenhagen.png')"><div id="footer-wrap"><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank"href="https://github.com/"><img src="https://img.shields.io/badge/Hosted-Github-brightgreen?style=flat&logo=GitHub"title="本站项目由Gtihub托管"></a><a style="margin-inline:5px"target="_blank"href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo"title="博客框架为Hexo"></a><a style="margin-inline:5px"target="_blank"href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?logoColor=white&style=flat&logo=buefy"title="主题采用butterfly"></a><a style="margin-inline:5px"target="_blank"href="https://aliyun.com/product/cdn"><img src="https://img.shields.io/badge/DNS-Cloudflare-orange?style=flat&logo=Cloudflare"title="本站使用Cloudflare网络服务"></a><a style="margin-inline:5px"target="_blank"href="https://beian.miit.gov.cn/"><img src="https://img.shields.io/badge/%E6%B4%A5ICP%E5%A4%87-2021000769%E5%8F%B7--3-red?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAACNlJREFUSInF1mmMVeUdx/Hv2e+5+519mJWBYQZkGxZZxLKJqBXGoLS1iXWrmihotFXaJiTWWlsbl6q1aetWd5u0VkKjNG4YEJSlOCibDLMwM8x679z9nnPP1jcVJUxf+7z6J8+LT37/Z4VvaQhfFS8+sBXbctCDGrVTKlBUH4mxAbI9Hfj0IJLsp6paJ5/tmn20N/D0wKDRMq9F/c3M2U1/V0vDfWMFh+tv/Ig1zYPMabDImPJ52OaXO87W580KggCiiOsJOJ6I3wcNFaaeNKxrt72f2fLGu4FpJ/sDQABRzD22fH7/Yze069vGc6mrDLNIJCDik10sxz2by3VdPM87xzkP9jwPTZFRVI1YUJKH+oy7n3tbvv/P2wW/UQxRWe6w4ZJRptYLHDoCuz8v5cP92XbI762O+h6UVWHnUFbPpU0fEb2A60mMJ7MUi9b/b7UgKhiZMaIxm8YLplLMDPz8hl/EH+rs8TNlUpFf32uyZJGLPDwCiTGUyTWodTN49eUCdz2YwXb9NNcObp1X98WDoufynzMVCEKGn27ayPTWBi5ad8P5iQUkJEnFLjqM9Z+hrVX0vfDe6K2dPRWsW2bwyp9EUifSJB84gdxrkR0eRgv1o/3I4fbbprJ6scqamzVO9pffec1S5ZWY2Nfz5qEy/FqOC2Y3s3j53HMSi18VRjFPwSwg+1RfVbl115vvJrsfej7UGIsYPPGgQ7JXoO+Xx5B3dHEomyJ9x1qiQozkr95h5937aFnVyouPlgJK+Ss7Fxz64OTSxSX+LHYxT2IsRW5kbGI4oHcR0jqoqTjV9se3I7/f8rS/ClS23GxSXhph6L5d9Akm7qqZhHWBQGUJ+CWGFzcg7e7m6D3/ZuW1Ea5YKdA3EojuONi813TqNi+YPYOKUhXDtCeGL26/hakLLiEcdsaHRkRAoLRc4fJrmhnekyF0apgZowWSwwkaa+rw3f8WA1GZZsPP5JEChX8dhZTN6iU6kAcs5s+dHd183SJ0VVKL57pfw6YdRQw23aeWTns47DPTALWlRTR7kMLew6hGgYqUhWXYFFUdPZ6lUBahLA8hVcOftckfi7No7VRAAQqsX1dybfvG1qwriM9mM5mJ4e4jO5Cc01dPqixbr8tWGBQUL4vjGigEEShi+xUmZ2RiR/sJ1pbS8NkgZrKAGw0TsgQsQyFaF/nfYTGprAlMFysbA1pI3mhkR6snhGsaymYGvPyFEb9IdbUE2AzFFTwpRqCtBY0wmdER+hZW4j63gcJj38V+/ErSUZXsYBfjIZHIRW0c2Z8BskCAqN+CbBJBFnyyKjR+Ez57nBxLqpfMUeSISElMBFz6x2Q6OxzWrYjyxWVzEewioU3LCS5vQY6nMUrLwNaxXvoQ59IloFSx54PPAZtQLExVZZDxsVE8J4dn6v4JYatgbSjk0owPw7RGH2ADMo88Z7L20ip8f7gC7fAo0q4+0rt7kEQDvaghVZbiPHUHcyeXcfLjT3jmpR7AYsnSScya3UR8bARVMck7Y/cB75/X6rDf3Fg2dw2jKZm5dXGm1LuAzO5DCo9v6aT0ibco5kzOvLOP+NGTFJtDpPYeZKijk/Rn3QxsfZV7txwhX7ABiZUXBsGvIvguQApNQQva9RMmTvZ2dpVUls+tX/UD7GN/Y8Ws05w6rQF+9vyzg1vZjbvMRJhXiRSU8DpTFFe0QE8S6SfPkOkZoktrB2oAhZWrwljxOPmchiSMYOWNoxNuruFU5vWeXdsojiUon345113dBBQBmTYlTimgdB8nfPo4WjaNFgN9OMEkJ02dnadVt5ki54Esqy+bzKJltVhSPbI3iN2zCyMTeXNCuG7Omm2Zok7PR2+R7jvD8ouruHhmCrB5jVZeYxLdrTP4sr4Vtd9g4MA4qc4c+6cu5NPamfw4P59t2WrA4YdXKkASf7SFivo6PDdEPmf1fRM++zp1bH/0r4I1dD1ODtOWaW4IsvPjL7nqXhloQiSPwjjgMYkMASyGEBkjhISCQwkwzve/18AbT+pk8pVY4UacQi9y+gyZ0eRAw4qHa89LXEx1LXMSPfhDJYRb59BtlLKg2WPT2l6qYl1svtGkrLYckyA1S+t5+2ATm37WCui0LSynsckDNH5zTxAchbQtkx08hDHYiW6NgC0enHBzEZ102UDH8QORdEckjEzZrNWkRydzyx17uGnDXqbUnGZ6dRPjSY91q2TqwjFuvTxLo5Zn5Qo/pumRSFcTLQtybEhGE0fQrDhhJ0VvH2lTnnHPhGtsmWan469apERjI2MH3qN7+7MEfH6ql29CbV7PvsMG32k6yU2XDhEKyZw66eJaRdrXR7CzCcqUNC3zwgymPJRCH4KRRLINimpL14A5Y4GDeOqbsPRVcfuN7Xj44pav/hFfrNT2kr2rsqf2Ibp5pEA14ZIImUyW3t5REkkTXRGQ/DGGhtLginhqCWknQDE5hKf5UFSF9Lj020Q2ul5V1AR2hr+8vuP8Vlc2zMPRxoSjnx7XBC14sDoydahSGq7KdO/HFyrBchxCVfX4fDKp4T7SCQejYODZLrYgIqgKFsNIgQqEYob8mW6yiUyb7Z64LVK/+B85xznnJ3AWzqTzuIX46mr5wLs+UUTyIriBCjRNxguHMJIFDLEEvXEOVRWnSJ0+jCd4CJoGjoedM1CLcXQziW3nMV2TSMBeOx7vWZvPt1r+cMPzE8KunaUkFn0vNrvtqXj34c1W6gzxlEQ6naIoBahtnkMwoFMwIVzSRNguMt53Aj2s4nkSlgPoGqLkICsRNF0gl8rYWuP8+11/w/OOJDEhHPKLCIpOXmi+M9AgP+maiesLifF2T1Rn5ZNj5Lo/Qc/GcPMmhdoqlEgIGzCK4PiCmJKK68p4KfF3qYGuF0qCRUkJTzleUbvQyWRTuE5xYthxQbBs7EISAbkzUFG3VfXXbK2YFi3X/eryfKKnqVBItNjJxDzH8erddC4SqWwcN5WyTtlyO1RP/Lh3eHD76MB40swmiDVJyDLYRhpc5+ub6tse/wWKbvSQEAw1awAAAABJRU5ErkJggg=="title="备案号:津ICP备2021000769号-3"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris"title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><i class="fas fa-adjust"><use id="modeicon" xlink:href="#icon-moon"></use></i></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Algolia</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.mahaofei.com/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.vemoji)'))
      }
    }, "https://cdn.jsdelivr.net/gh/zhheo/twikoo@dev/dist/twikoo.all.min.js"))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'https://twikoo.mahaofei.com/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      document.getElementById('twikoo-count').innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script><script src="https://cdn.jsdelivr.net/npm/element-ui@2.15.6/lib/index.js"></script><script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script><script src="/js/custom/categoryBar.js"></script><script src="/js/custom/cardHistory.js"></script><script src="/js/custom/light_dark.js"></script><script src="/js/custom/forbidCopy.js"></script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"Jfmc1FSFWs09EC8r",ck:"Jfmc1FSFWs09EC8r"})</script><script src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script>new LingQue.Monitor().init({id:"JfmcYvlVsVAZlVkS"});</script><script defer src="https://cloud.umami.is/script.js" data-website-id="86b466f8-e8bc-415b-954e-289b3d0110fb"></script><script src="/js/custom/custom.js"></script><script src="/js/custom/nav.js"></script><script id="canvas_nest" defer="defer" color="66,66,66" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>