<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>百度网盘不限速下载方法</title>
    <url>/1946/02/14/000-00-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%B8%8D%E9%99%90%E9%80%9F%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、安装TamperMonkey扩展程序（油猴）"><a href="#一、安装TamperMonkey扩展程序（油猴）" class="headerlink" title="一、安装TamperMonkey扩展程序（油猴）"></a>一、安装TamperMonkey扩展程序（油猴）</h2><p>需要使用Edge浏览器或Chrome浏览器。</p>
<h4 id="1-1-如何使用Edge浏览器安装油猴"><a href="#1-1-如何使用Edge浏览器安装油猴" class="headerlink" title="1.1 如何使用Edge浏览器安装油猴"></a>1.1 如何使用Edge浏览器安装油猴</h4><p>使用Edge浏览器安装油猴十分简单，直接进入<a href="https://microsoftedge.microsoft.com/addons/detail/tampermonkey/iikmkjmpaadaobahmlepeloendndfphd?hl=zh-CN">【扩展应用商店】</a>安装即可。</p>
<h4 id="1-2-如何使用Chrome浏览器安装油猴"><a href="#1-2-如何使用Chrome浏览器安装油猴" class="headerlink" title="1.2 如何使用Chrome浏览器安装油猴"></a>1.2 如何使用Chrome浏览器安装油猴</h4><ol>
<li>如果可以科学上网，进入<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN">【Chrome扩展程序商店】</a>，点击右侧的添加至chrome即可。<br>ps.查外文文献查资料会经常需要科学上网。<br><img src="https://img-blog.csdnimg.cn/e6642d8c89b44e4b977b1fb2d49bd2c8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>如果无法打开上面的网页，可以<a href="https://huffie.lanzouw.com/i6TuUuhjdyd">【点此下载】</a>离线包。①将下载的压缩文件解压；②打开浏览器扩展程序管理页面；③右上角打开开发者模式；④将解压出来的【TamperMonkey.crx】文件拖到到此页面。<br><img src="https://img-blog.csdnimg.cn/95cf0b5cda3b482f97784e643760b2b6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/89c295ba5e1b4eaa9a4f02dea5b5e082.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ol>
<h2 id="二、安装油猴脚本"><a href="#二、安装油猴脚本" class="headerlink" title="二、安装油猴脚本"></a>二、安装油猴脚本</h2><p>这一步不论什么浏览器都一样。打开<a href="https://greasyfork.org/zh-CN/scripts/418182-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%AE%80%E6%98%93%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B-%E7%9B%B4%E9%93%BE%E4%B8%8B%E8%BD%BD%E5%A4%8D%E6%B4%BB%E7%89%88">【此网页】</a>，安装脚本即可。</p>
<p>ps. 油猴是一个非常实用的插件，GreasyFork里面有很多实用的脚本，想了解的可以自行探索。<br><img src="https://img-blog.csdnimg.cn/87ff4755090f46388291ce76d686dfe8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/524723165590413c802a8f0e3b8065ad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="三、开始下载"><a href="#三、开始下载" class="headerlink" title="三、开始下载"></a>三、开始下载</h2><h4 id="3-1-准备IDM"><a href="#3-1-准备IDM" class="headerlink" title="3.1 准备IDM"></a>3.1 准备IDM</h4><p>如果你已经在使用IDM，那么可以跳过这一步。</p>
<p>如果没有，可以使用刚才解压的文件夹中的IDM绿色版。</p>
<ol>
<li>将压缩包解压后运行【绿化.bat】；<br><img src="https://img-blog.csdnimg.cn/bf93366e169c4763a031b5fff36e25f0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>运行【IDMan.exe】</li>
<li>打开【选项】菜单，点击【下载】栏，将用户代理UA修改为：<strong>softxm;netdisk</strong><br><img src="https://img-blog.csdnimg.cn/ca9d61b5f676414299c09e212b3ea39c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>点击【连接】栏，将最大连接数设置为<strong>4</strong>，点击【确定】<br><img src="https://img-blog.csdnimg.cn/57cc91040b88415b82ac865d28c8ef26.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ol>
<h4 id="3-2-选择文件下载"><a href="#3-2-选择文件下载" class="headerlink" title="3.2 选择文件下载"></a>3.2 选择文件下载</h4><ol>
<li><p>打开<a href="https://pan.baidu.com/">【百度网盘网页版】</a>，选择一个要下载的文件。（注意只能是一个文件，不能是文件夹）。</p>
</li>
<li><p>点击上方的简易下载助手下载。<br><img src="https://img-blog.csdnimg.cn/8ba86c7ea1e54237b82bf5348a668ba3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p>点击【获取直链地址】，并【复制直链地址】<br><img src="https://img-blog.csdnimg.cn/807244ac7fe848c8a4d5ea55ad08e441.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p>打开IDM，选择新建下载任务，粘贴刚才的直链地址进行下载。<br>下载速度根据当前网络状况，校园网一般在<strong>2MB/s~10MB/s</strong><br><img src="https://img-blog.csdnimg.cn/214ed89178164d89b1ff66f1414754f7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Office2019专业版安装教程</title>
    <url>/1946/02/14/000-01-Office2019%E4%B8%93%E4%B8%9A%E7%89%88%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>阿里云盘链接：<br><a href="https://www.aliyundrive.com/s/panCD33Jzrv">https://www.aliyundrive.com/s/panCD33Jzrv</a><br>下载完成后将后缀名改回【.zip】即可正常解压</p>
</blockquote>
<p>安装之前，先到【控制面板-卸载程序】，卸载掉所有Office产品。</p>
<ol>
<li><p>解压压缩包，运行【<strong>Setup64.exe</strong>】<br><img src="https://img-blog.csdnimg.cn/b5cc2462b5484a9687be5517c8530a6b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p>等待20分钟左右安装，只能安装在C盘。</p>
</li>
<li><p>安装完成后在开始菜单打开，可以正常使用</p>
</li>
<li><p>如果需要激活，可以使用<a href="https://huffie.lanzouw.com/idn0Cuhmwzg">【此工具】</a>进行激活。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Proteus8.9的下载与安装教程</title>
    <url>/1946/02/14/000-02-Proteus8.9%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>百度网盘链接：<a href="https://pan.baidu.com/s/1EHGewnvjcnEpPbXnR1qLIA">https://pan.baidu.com/s/1EHGewnvjcnEpPbXnR1qLIA</a><br>提取码: pr89<br>&emsp;&emsp;<br>阿里云盘链接：<a href="https://www.aliyundrive.com/s/29x1H7qy3Hz">https://www.aliyundrive.com/s/29x1H7qy3Hz</a><br>下载后将后缀改为.zip即可正常解压。</p>
</blockquote>
<ol>
<li><p>右键压缩包，进行解压。进入解压的文件夹，右键<strong>p8.9.sp0.exe</strong>文件，使用管理员身份打开。<br><img src="https://img-blog.csdnimg.cn/2021042716183398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20210427155955965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 这里可能有些机器会先弹出安装Visual C++的一个界面，一定要安装这些勾选的组件，否则后续安装会出现问题。<br> <img src="https://img-blog.csdnimg.cn/img_convert/a463f19ba7ccc15c4b754107dbd96cfb.png" alt="在这里插入图片描述"></p>
</li>
<li><p>莫得选择，next<br><img src="https://img-blog.csdnimg.cn/20210427160040896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>I accept，然后next<br><img src="https://img-blog.csdnimg.cn/20210427160122443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>选择使用本地的激活证书license key。<br><img src="https://img-blog.csdnimg.cn/20210427160222163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>继续next<br><img src="https://img-blog.csdnimg.cn/20210427160250894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>这里会打开一个激活证书管理界面，点击左下角【Browse For Key File】，找到刚才解压出来的文件夹，里面解压后的【Proteus 8.9】文件夹中的【Crack】文件夹下的【Licence.lxk】文件，点击【打开】。<br><img src="https://img-blog.csdnimg.cn/20210427160407818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427160555445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>点击 【<strong>install</strong>】，在弹出的对话框询问是否继续，选择 【<strong>是</strong>】，安装完成后点击【<strong>Close</strong>】。<br><img src="https://img-blog.csdnimg.cn/20210427160626557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427160803299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427160923597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center0" alt="在这里插入图片描述"></p>
</li>
<li><p>都不用勾选，直接【<strong>next</strong>】<br><img src="https://img-blog.csdnimg.cn/2021042716101041.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>这里选择安装方式，选择【<strong>Custom</strong>】，然后选择要安装的路径，<strong>注意：两个路径一定要一样，否则后期软件使用时会闪退</strong>。<br><img src="https://img-blog.csdnimg.cn/20210427161954839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427162148838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>这里不用管，默认【<strong>Next</strong>】就可以。<br><img src="https://img-blog.csdnimg.cn/20210427162239902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>继续【<strong>Next</strong>】<br><img src="https://img-blog.csdnimg.cn/20210427162332399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>点击【<strong>Install</strong>】开始安装，安装耗时一分钟左右。<br><img src="https://img-blog.csdnimg.cn/20210427162402735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210427161154275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>13. 点击【<strong>Close</strong>】，不要运行Proteus<br><img src="https://img-blog.csdnimg.cn/20210427161358541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>14. 再次进入安装包解压后的【<strong>Proteus 8.9</strong>】文件夹中的【<strong>Crack</strong>】文件夹，选择所有文件【<strong>复制</strong>】。<br><img src="https://img-blog.csdnimg.cn/20210427162558619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>15. 在桌面找到【<strong>Proteus 8.9</strong>】的快捷方式，右键点击【<strong>打开文件所在的位置</strong>】<br><img src="https://img-blog.csdnimg.cn/20210427162858842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>16. 在空白处【<strong>右键-粘贴</strong>】，将刚才那三个文件复制过来。<br><img src="https://img-blog.csdnimg.cn/20210427163052411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>17. 右键<strong>粘贴后</strong>的【<strong>pp8.9</strong>】选择【<strong>以管理员身份运行</strong>】。（运行完成后不会弹出任何对话窗，运行一下就可以），建议关闭各种安全管家之后再运行。<br><img src="https://img-blog.csdnimg.cn/20210427163431335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>18. 再次打开解压后的【Proteus 8.9】文件夹，鼠标右击【Translations】选择【复制】。<br><img src="https://img-blog.csdnimg.cn/20210427163922127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol start="19">
<li>再次右键桌面【<strong>Proteus 8.9</strong>】的快捷方式，右键点击【<strong>打开文件所在的位置</strong>】<br><img src="https://img-blog.csdnimg.cn/20210427162858842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>点击路径中的【<strong>Proteus</strong>】文件夹，回到上一级。<br><img src="https://img-blog.csdnimg.cn/20210427163623221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>在空白处【<strong>右键-粘贴</strong>】，将刚才复制的Translation文件夹粘过来，可能会有27/28个同名文件，点击【<strong>替换目标中的文件</strong>】。<br><img src="https://img-blog.csdnimg.cn/20210427164054243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427164207604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>进入【<strong>C:\Program Files (x86)\Labcenter Electronics</strong>】目录下，有一个【<strong>Proteus 8 Professional</strong>】文件夹，进入此文件夹，【<strong>全选-复制这两个文件夹</strong>】。<br><img src="https://img-blog.csdnimg.cn/20210427172105339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>回到Proteus的安装路径（同19、20步），【<strong>右键粘贴，替换目标文件</strong>】<br><img src="https://img-blog.csdnimg.cn/20210427172526413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<p><strong>至此，安装完成！</strong><br><img src="https://img-blog.csdnimg.cn/20210427173415459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>LabVIEW2020的下载与安装教程</title>
    <url>/1946/02/14/000-03-LabVIEW2020%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>阿里云盘：<br><a href="https://www.aliyundrive.com/s/Xa9qWfUmRT2">https://www.aliyundrive.com/s/Xa9qWfUmRT2</a><br>下载完成后将文件后缀名改回【.zip】即可正常解压。</p>
</blockquote>
<p>此教程为Labview2020 中文版的安装教程，英文版安装过程相同。</p>
<ol>
<li>打开解压后的文件夹，<strong>进入安装包目录</strong>，双击运行【<strong>Install.exe</strong>】开始安装。<br><img src="https://img-blog.csdnimg.cn/b6d58731beb94ce0a1a3d3a309c333e0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>接受许可协议，<strong>下一步</strong><br><img src="https://img-blog.csdnimg.cn/a130caf1f78b4ee7a7bfd320cbd5d2ce.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>直接<strong>下一步</strong><br><img src="https://img-blog.csdnimg.cn/c66a13e03df44b6a9f6a85573d09b2b2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>莫得选择，继续<strong>下一步</strong><br><img src="https://img-blog.csdnimg.cn/b604b562b2bf47dc91fe48af9290011b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li><strong>等待十多秒</strong>安装相关组件，然后会<strong>弹出选择菜单</strong>，按照默认选择<strong>直接下一步</strong><br><img src="https://img-blog.csdnimg.cn/34c840b3f4a7410197f4a88d0def0f68.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ccdc00bb4b8b476fa05bb80e91405223.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li><strong>我接受，然后下一步</strong><br><img src="https://img-blog.csdnimg.cn/970b79c8425e485f884a7c4b7fafb1f2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>还是莫得选择，继续<strong>接受，然后下一步</strong><br><img src="https://img-blog.csdnimg.cn/c813266432484339be18e82c85f87c2e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>核对信息，正常安装不会有问题，<strong>直接下一步</strong><br><img src="https://img-blog.csdnimg.cn/250148dc78cf4241a83eed17a7e94ba7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li><strong>等待安装</strong>，安装过程耗时分钟左右<br><img src="https://img-blog.csdnimg.cn/e5e74472a4994fd5831a8b54503436f7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li><strong>选择yes</strong><br><img src="https://img-blog.csdnimg.cn/d345e55b4e544e8c9d96b54b25d37a42.png" alt="在这里插入图片描述"></li>
<li>选择<strong>不加入用户体验改进计划</strong>，<strong>确定</strong><br><img src="https://img-blog.csdnimg.cn/aa2c4026a63f4327ba6b5d3e8ee2bb75.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>在弹出的登陆页面<strong>点击取消</strong><br><img src="https://img-blog.csdnimg.cn/a111b55ed5a340d09bb8d264b145e0d6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>不需要重启，<strong>点击右上角x关闭安装程序即可</strong><br><img src="https://img-blog.csdnimg.cn/3f4c0eb7801c420aa1f6cf41f84b1420.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>打开安装包，找到【<strong>NI License Acticator 1.2</strong>】，右键<strong>以管理员身份运行</strong><br><img src="https://img-blog.csdnimg.cn/570e89176dee4a1e830b8b8da2b40b44.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>将<strong>全部选项右键激活</strong><br><img src="https://img-blog.csdnimg.cn/2dc2fb4e374f462a85025a40c46e57ac.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>至此完成安装，在开始菜单找到安装好的程序启动<br><img src="https://img-blog.csdnimg.cn/b3bbfc831770438cb40d7fda6b0fc630.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/b5e543c1059d4a66ad949e2d12c028b8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>RobotStudio6.08 下载与安装教程</title>
    <url>/1946/02/14/000-04-RobotStudio6.08%20%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>阿里云盘链接：<br><a href="https://www.aliyundrive.com/s/XUYg6iJPH2M">https://www.aliyundrive.com/s/XUYg6iJPH2M</a><br>下载后将文件的后缀名改回【.rar】即可正常解压。</p>
</blockquote>
<ol>
<li><p>打开压缩包，找到【<strong>setup.exe</strong>】双击运行。<br><img src="https://img-blog.csdnimg.cn/1b93e773a75e4e8d8a5167c8e0dfa7fd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p>默认中文简体，<strong>确定</strong><img src="https://img-blog.csdnimg.cn/1bfcabda1bc44071ad28a4a20f1503b3.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>点击下一步</strong>，开始进行安装<br><img src="https://img-blog.csdnimg.cn/ad3ffd46a40d404e88bf5c3ded9748e5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>我接受</strong>，然后点击<strong>下一步</strong><br><img src="https://img-blog.csdnimg.cn/118f7570d8f745fe936ec7dae3be7c84.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>点击接受</strong>，继续进行<br><img src="https://img-blog.csdnimg.cn/95edeba15ba54683a28c4596578d1646.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p>点击上方的<strong>更改</strong>按钮，选择一个安装位置，然后点击<strong>下一步</strong><img src="https://img-blog.csdnimg.cn/bf9e59b8ea9044aa8891e561f673c38f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
</li>
<li><p>建议按照默认，<strong>完整安装</strong>，点击<strong>下一步</strong><br><img src="https://img-blog.csdnimg.cn/1149e35c77e44109a632be89e8b20d12.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p>点击<strong>安装</strong>，开始安装RobotStudio程序主体，安装过程大概15分钟左右。<br><img src="https://img-blog.csdnimg.cn/c141787cab374c0c850223ee3ecd0519.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p>安装期间可能会弹出如下选项，一定要选择<strong>下载并安装此功能</strong>，否则安装后软件将无法正常启动<br><img src="https://img-blog.csdnimg.cn/4e0c8080cbdd45728fa281acc0f68c7c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p>安装完成，点击<strong>完成</strong>，退出安装程序<br><img src="https://img-blog.csdnimg.cn/a5e104f4e4d547b18e253821e8c17570.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>不需要</strong>重启电脑，点击<strong>否</strong><br><img src="https://img-blog.csdnimg.cn/ade41c7307c24baf888134a3bafd0db5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p>此时打开RobotStudio，会发现按下快捷键【win+R】，输入【regedit】进入注册表编辑器。<br><img src="https://img-blog.csdnimg.cn/a64cead00dbc4b5cb33deb6a22cd6fbb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p>找到如下位置：<br>32位电脑：HKEY_LOCAL_MACHINE——SOFTWARE——Microsoft——SLP Services<br>64位电脑：HKEY_LOCAL_MACHINE——SOFTWARE——Wow6432Node——Microsoft——SLP Services<br><img src="https://img-blog.csdnimg.cn/1a8ade5efcf84d9fbda6b4252ffb712a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p>选择表中倒数第6行中，从左至右第6个数改成【<strong>F4</strong>】，点击<strong>确认</strong>，再重新打开Robotstudio软件，可以看到RobotStudio已激活。<br><img src="https://img-blog.csdnimg.cn/6fcbfa00014f42d6b7ca45012b2f0709.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/e4a196d5a7c54ddca823e2916fb6abf3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2e52d92e4f0c4c9a80813e21afa0514e.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/877b5838abb5430a98fbb7679ededce2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>数字化方法基础（二）_点的投影</title>
    <url>/2019/10/29/003-%E6%95%B0%E5%AD%97%E5%8C%96%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89_%E7%82%B9%E7%9A%84%E6%8A%95%E5%BD%B1/</url>
    <content><![CDATA[<p>全部教程链接：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/102650117#_490">https://blog.csdn.net/weixin_44543463/article/details/102650117#_490</a><br>此为其中的第二部分</p>
<h1 id="Chapter4-用OpenGL生成点的投影"><a href="#Chapter4-用OpenGL生成点的投影" class="headerlink" title="Chapter4  用OpenGL生成点的投影"></a>Chapter4  用OpenGL生成点的投影</h1><h2 id="计算点的投影的基本原理"><a href="#计算点的投影的基本原理" class="headerlink" title="计算点的投影的基本原理"></a>计算点的投影的基本原理</h2><p><img src="https://img-blog.csdnimg.cn/20191020192801898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"></p>
<h2 id="如何编写程序实现点的投影"><a href="#如何编写程序实现点的投影" class="headerlink" title="如何编写程序实现点的投影"></a>如何编写程序实现点的投影</h2><p>1、我们要实现点的投影就要知道投影点的坐标，由上一节可知，需要计算<strong>P0P1矢量</strong>（这个直接调用上一讲求向量的函数），<strong>en向量</strong>（需要写一个单位化函数），<strong>向量点乘</strong>的函数<br>2、单位化，即将向量各个坐标除以它的模，函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Normalize</span><span class="params">(<span class="keyword">float</span> n[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> length;</span><br><span class="line">	length = <span class="built_in">sqrt</span>(n[<span class="number">0</span>]*n[<span class="number">0</span>]+n[<span class="number">1</span>]*n[<span class="number">1</span>]+n[<span class="number">2</span>]*n[<span class="number">2</span>]);</span><br><span class="line">	<span class="comment">//求向量的模</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">		n[i] /= length;</span><br><span class="line">	<span class="comment">//函数执行过后n[3]即变成单位法向量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、进行向量点乘计算，并求N点坐标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProjectPointtoPoint</span><span class="params">(<span class="keyword">float</span> point[<span class="number">3</span>],<span class="keyword">float</span> a[<span class="number">3</span>],<span class="keyword">float</span> n[<span class="number">3</span>], <span class="keyword">float</span> ProjectPoint[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> vector_a_p[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">float</span> distance;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">		vector_a_p[i] = point[i] - a[i];</span><br><span class="line">	<span class="comment">//求面内一点与面外一点的向量,即P0P1</span></span><br><span class="line">	distance = vector_a_p[<span class="number">0</span>]*n[<span class="number">0</span>]+vector_a_p[<span class="number">1</span>]*n[<span class="number">1</span>]+vector_a_p[<span class="number">2</span>]*n[<span class="number">2</span>];</span><br><span class="line">	<span class="comment">//做点乘运算求点到平面距离，即图中|P0N|</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">		ProjectPoint[j] = point[j] - n[j]*distance;</span><br><span class="line">	<span class="comment">//N点坐标=P0坐标 - en * |P0N|</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、经过上述步骤之后就获得投影点坐标，然后就可调用库函数显示投影点，以下为显示一个点的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPoint</span><span class="params">(<span class="keyword">float</span> a[<span class="number">3</span>],<span class="keyword">float</span> b[<span class="number">3</span>],<span class="keyword">float</span> c[<span class="number">3</span>],<span class="keyword">float</span> point[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> n[<span class="number">3</span>];</span><br><span class="line">	project(a,b,c,n);</span><br><span class="line">	<span class="comment">//求abc平面法向量</span></span><br><span class="line">	Normalize(n);</span><br><span class="line">	<span class="comment">//单位化法向量</span></span><br><span class="line">	<span class="keyword">float</span> ProjectPoint[<span class="number">3</span>];</span><br><span class="line">	<span class="comment">//定义一个数组用来存放投影点坐标</span></span><br><span class="line">	ProjectPointtoPoint(point,a,n,ProjectPoint);</span><br><span class="line">	<span class="comment">//获得投影点坐标</span></span><br><span class="line">	glVertex3fv(ProjectPoint);</span><br><span class="line">	<span class="comment">//显示投影点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、同三角形，在RenderSenen()函数中的画三角形的glEnd()后面 <strong>再次写入glBegin()与glEnd()函数，并在二者之间插入显示点的代码</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> point[<span class="number">3</span>] = &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;;</span><br><span class="line"><span class="comment">//定义要投影的点</span></span><br><span class="line">glColor3ub(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//显示的点的颜色</span></span><br><span class="line">glPointSize(<span class="number">6.0f</span>);</span><br><span class="line"><span class="comment">//显示的点的大小</span></span><br><span class="line">glBegin(GL_POINTS);</span><br><span class="line"><span class="comment">//开始生成点</span></span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">6</span>,point);</span><br><span class="line"><span class="comment">//根据第一个面3个点，画第一个投影点</span></span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">3</span>,point);</span><br><span class="line">DrawPoint(rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">6</span>,point);</span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">6</span>,rgfPoints4+<span class="number">9</span>,point);</span><br><span class="line">glEnd();</span><br></pre></td></tr></table></figure>
<p>6、调试成功，显示如图<br><img src="https://img-blog.csdnimg.cn/20191020190700117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffir"></p>
<h1 id="Chapter5-如何使用VS2010的调试功能"><a href="#Chapter5-如何使用VS2010的调试功能" class="headerlink" title="Chapter5  如何使用VS2010的调试功能"></a>Chapter5  如何使用VS2010的调试功能</h1><p> 假如我写完程序调试后发现点没有显示，那么可以一步步调试，找出错误的地方。<br> 1、设置断点，在觉得可能出问题的代码处设置断点<br><img src="https://img-blog.csdnimg.cn/20191020190926284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>2、点击调试，下图红框内左面按键为单步执行，点一下执行一句话，如果遇到函数就进入函数内部执行函数体的第一句；右面的按键，点一下执行一句，在遇到函数是直接将整个函数执行完，即将函数也当成一句话。<br><img src="https://img-blog.csdnimg.cn/20191020191040439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>3、这里选择左面按键进入函数内部查看,黄色箭头表示当前执行到哪一句<br><img src="https://img-blog.csdnimg.cn/20191020191502654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>4、按第二个按键将这个函数执行完（但不要退出这个函数，否则函数内部的变量内存会被释放，无法查看变量的值）<br><img src="https://img-blog.csdnimg.cn/20191020191717196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>5、此时可以看到下面的监视窗口可以看到变量，单击+即可看到变量的值，图中展开的为第一个面的法向量和投影点坐标<br><img src="https://img-blog.csdnimg.cn/20191020191851486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>第二个面的法向量和投影点坐标<br><img src="https://img-blog.csdnimg.cn/20191020192033599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>第三个面<br><img src="https://img-blog.csdnimg.cn/20191020192148203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>第四个<br><img src="https://img-blog.csdnimg.cn/20191020192223839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"></p>
<p><strong>Continue</strong></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>数字化方法基础（三）_导入本地模型</title>
    <url>/2019/10/29/004-%E6%95%B0%E5%AD%97%E5%8C%96%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89_%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>全部教程链接：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/102650117#_490">https://blog.csdn.net/weixin_44543463/article/details/102650117#_490</a><br>此为其中的第三部分</p>
<h1 id="Chapter-6-导入本地模型"><a href="#Chapter-6-导入本地模型" class="headerlink" title="Chapter 6  导入本地模型"></a>Chapter 6  导入本地模型</h1><p>图形的生成需要消耗一定的时间，简单的模型可能没有什么感觉，但是在模型十分复杂时，模型的生成就需要相当长的时间，这是我们不能忍受的。因此，将模型保存为本地文件，使用时直接加载进来，这就变得十分必要了，本节主要讲如何将创建一个列表以及如何加载一个列表。</p>
<h2 id="如何创建一个列表"><a href="#如何创建一个列表" class="headerlink" title="如何创建一个列表"></a>如何创建一个列表</h2><p>列表的基本原理就是将之前写的<strong>从glPolygonMode、glBegin开始，到glEnd</strong>将这些代码<strong>用一行glCallList(DrawList)代替</strong>，其中DrawList内存放的就是之前生成四面体的代码了。glCallList就相当于把原来的四面体代码加载进来。<br>那如何将原来的四面体代码创建为一个列表供glCallList读取呢，过程十分简单，只需要按以下步骤即可：<br>1、在整个文件开头部分<strong>定义一个GLuint类型的全局变量</strong>（因为这个变量要在不同的函数使用，故须定义为全局变量）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GLuint DrawList;</span><br></pre></td></tr></table></figure>
<p>2、将RenderScene函数（就是之前写glbegin和glEnd的地方）中的<strong>有关三角形的代码全部用glCallList函数代替</strong><img src="https://img-blog.csdnimg.cn/20191022183312604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>3、在SetupRC函数中的最后<strong>新建列表</strong>，<strong>框架</strong>如下<br><img src="https://img-blog.csdnimg.cn/20191022190234315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>4、框架写好之后在图中注释位置<strong>插入画四面体的代码</strong>，插入后结果如下图<br><img src="https://img-blog.csdnimg.cn/20191022190538150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>5、至此一个存有四面体列表就新建好了，点击调试运行即可看到和以前一样的四面体。<br><img src="https://img-blog.csdnimg.cn/20191022190817973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"></p>
<h2 id="如何读取本地模型"><a href="#如何读取本地模型" class="headerlink" title="如何读取本地模型"></a>如何读取本地模型</h2><p>当我们需要读取本地文件中的模型时，如何操作呢<br>1、既然要读取文件中的模型，首先肯定要打开文件，在创建列表的代码之前插入如下三行代码<br><img src="https://img-blog.csdnimg.cn/20191022191736138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>（注意，if stream的括号内为文件的路径，其中的\都要写成\，因为在C语言字符串中，\表示转义，\\才表示一个\）<br>（注意，ifstream若要使用需要先在开头插入以下两行引入头文件同时设置环境）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<p>2、在定义几个数组用来存放一会要读取的数据<br><img src="https://img-blog.csdnimg.cn/20191022192655701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>3、然后，将之前画四面体的代码，更改为读取文件的代码，更换后的框架如下，其中in每次读取一串字符（到空格或换行停止），<strong>in &gt;&gt; String0指的是将读取到的字符存入String0中</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	DrawList = <span class="built_in">glGenLists</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">glNewList</span>(DrawList,GL_COMPILE);</span><br><span class="line">	<span class="built_in">glPolygonMode</span>(GL_BACK,GL_LINE);</span><br><span class="line">	<span class="comment">//在↓插入代码</span></span><br><span class="line">	in &gt;&gt; String0 &gt;&gt; String0;<span class="comment">//这就表示将两个字符串先后存入到String0中</span></span><br><span class="line">	<span class="comment">//因为如下图在读取到有用数据之前有两个没用的单词，需要读取两次</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">strcmp</span>(String0,<span class="string">&quot;end&quot;</span>))<span class="comment">//读到的字符串为end则退出循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		in &gt;&gt; Points[<span class="number">0</span>] &gt;&gt; Points[<span class="number">1</span>] &gt;&gt; Points[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//因为刚才已经读掉了前两个没用的字符串，因此直接读取三个坐标到Points里</span></span><br><span class="line">		in &gt;&gt; String0 &gt;&gt; Points[<span class="number">3</span>] &gt;&gt; Points[<span class="number">4</span>] &gt;&gt; Points[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//如下图读完第一组坐标后会遇到 vertex这个单词，需要读到垃圾桶（String0）里再读坐标</span></span><br><span class="line">		in &gt;&gt; String0 &gt;&gt; Points[<span class="number">6</span>] &gt;&gt; Points[<span class="number">7</span>] &gt;&gt; Points[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">		<span class="built_in">glColor3ub</span>(<span class="number">200</span>,<span class="number">200</span>,<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">glBegin</span>(GL_TRIANGLES);</span><br><span class="line">		<span class="built_in">DrawTriangle</span>(Points,Points+<span class="number">3</span>,Points+<span class="number">6</span>);</span><br><span class="line"><span class="comment">//这三行时画一个三角形，根据刚才读到的三个点</span></span><br><span class="line">		in &gt;&gt; String0;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在↑插入代码</span></span><br><span class="line">	<span class="built_in">glEndList</span>();</span><br></pre></td></tr></table></figure>
<p>（因为用到了strcmp函数，需要引入头文件#include&lt;string.h&gt;）<br><img src="https://img-blog.csdnimg.cn/20191022193921836.png" alt="Huffie"><br><img src="https://img-blog.csdnimg.cn/20191022194106777.png" alt="Huffie"><br>注意一下，计算机里的图像<strong>无论是平面还是曲面，都是由无数个三角形组成的</strong>，只不过三角形数量无比多时，我们看起来它就是一个曲面，Part1.TXT文件中也是，每读取到三个点就画一个三角形，许许多多个三角形就会组成一个立体图形。<br>4、至此，如何从文件中导入立体模型就完成了，点击调试，即可看到一个正方体<br>6、那么对于给定的STL文件如何读取？首先右击Part2.STL，用记事本打开，看到文件内容如下<br><img src="https://img-blog.csdnimg.cn/20191022200005791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>这看起来和之前差不多，只是他多给了一个法向量，没用的字符串多了一些而已，你可以不用他给的法向量，只读取三个坐标然后自己计算法向量，也可以读取法向量，这个时候 DrawTriangle函数就不需要计算法向量了，直接四行代码就ok，和之前一样，每一次in &gt;&gt; String0操作就读掉一个没用的字符串，自己编写代码就可实现将STL文件中的所有点全部读取出来<br>需要注意的是，<strong>每次循环结束</strong>的时候都要保证<strong>String内存放</strong>的是<strong>facet或者最后的endsolid</strong>这个单词，以保证循环可以正常退出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawTriangle</span><span class="params">(<span class="keyword">float</span> a[<span class="number">3</span>],<span class="keyword">float</span> b[<span class="number">3</span>],<span class="keyword">float</span> c[<span class="number">3</span>],<span class="keyword">float</span> n[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//float n[3];</span></span><br><span class="line">	<span class="comment">//project(a,b,c,n);</span></span><br><span class="line">	<span class="built_in">glNormal3fv</span>(n);</span><br><span class="line">	<span class="built_in">glVertex3fv</span>(a);</span><br><span class="line">	<span class="built_in">glVertex3fv</span>(b);</span><br><span class="line">	<span class="built_in">glVertex3fv</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS.如果程序出现错误，如何进行调试呢，首先在while循环里第一句前面设置断点，如下图<br><img src="https://img-blog.csdnimg.cn/2019102322202536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>然后点击单步执行第二个按钮<br><img src="https://img-blog.csdnimg.cn/20191023222126398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>每次循环读9个点,查看你读取到的点的值是否与文件中的坐标值一一对应，其中012对应第一行3个点，345对应第二行三个点，678对应第三行。<br><img src="https://img-blog.csdnimg.cn/20191023222235402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"></p>
<p><strong>Continue</strong></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>数字化方法基础（一）_基础操作与生成四面体</title>
    <url>/2019/10/29/002-%E6%95%B0%E5%AD%97%E5%8C%96%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89_%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%88%90%E5%9B%9B%E9%9D%A2%E4%BD%93/</url>
    <content><![CDATA[<p>全部教程链接：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/102650117#_490">https://blog.csdn.net/weixin_44543463/article/details/102650117#_490</a><br>此为其中的第一部分</p>
<h1 id="Chapter1-VisualStudio2010-Express如何创建新工程"><a href="#Chapter1-VisualStudio2010-Express如何创建新工程" class="headerlink" title="Chapter1  VisualStudio2010 Express如何创建新工程"></a>Chapter1  VisualStudio2010 Express如何创建新工程</h1><p>   1、新建一个win32 Console Application工程，选择建立一个空项目（带预编译头的也可以，只不过大多数人不太习惯）<img src="https://img-blog.csdnimg.cn/20191020160526371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Alt"><img src="https://img-blog.csdnimg.cn/20191020160700922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Alt"><br>   2、在左侧解决方案资源管理器中右击Source-add-New item，创建一个C++文件<img src="https://img-blog.csdnimg.cn/20191020160828359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Alt"><br>   3、这样就用VS2010创建好了一个简单的工程！</p>
<h1 id="Chapter2-SB-WinSRC的使用方法"><a href="#Chapter2-SB-WinSRC的使用方法" class="headerlink" title="Chapter2 SB-WinSRC的使用方法"></a>Chapter2 SB-WinSRC的使用方法</h1><p>1、解压压缩包，得到一个SB-WinSRC文件夹<br>2、打开SB-WinSrc\examples\projects\microsoft\chapt05\shinyjet文件夹中的shinyjet.vcproj文件，如出现以下对话框则一直Next到最后<br> <img src="https://img-blog.csdnimg.cn/20191020161143715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>3、打开shinyjet.cpp并进行编译（Build solution生成解决方案）<br> <img src="https://img-blog.csdnimg.cn/20191020161209539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>4、出现图示错误<br> <img src="https://img-blog.csdnimg.cn/20191020161233400.png#pic_center" alt="Huffie"><br>5、打开目录\SB-WinSrc\examples\src\shared，找到freeglut_static.lib文件，将它复制到之前打开的shinyjet文件夹内<br> <img src="https://img-blog.csdnimg.cn/2019102016125668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br> <img src="https://img-blog.csdnimg.cn/20191020161309892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>6、再次进行编译（Build solution生成解决方案），出现下图错误<br> <img src="https://img-blog.csdnimg.cn/20191020161335972.png#pic_center" alt="Huffie"><br>7、在左侧Solution Explorer（解决方案资源管理器）中右击shinyjet打开属性，将Linker-Input-忽略特定默认库一栏中输入LIBC.lib<br> <img src="https://img-blog.csdnimg.cn/20191020161356328.png#pic_center" alt="Huffie"><br>8、再次编译，成功！</p>
<h1 id="Chapter3-用OpenGL生成四面体"><a href="#Chapter3-用OpenGL生成四面体" class="headerlink" title="Chapter3  用OpenGL生成四面体"></a>Chapter3  用OpenGL生成四面体</h1><h2 id="已知3点求法向量"><a href="#已知3点求法向量" class="headerlink" title="已知3点求法向量"></a>已知3点求法向量</h2><p>1、具体思路为先根据已知3点做差求出两个向量，利用两个向量叉乘运算求出法向量，实现过程中尽量避免将所有代码集中到一个函数中，因为后续的操作（如投影点的计算）还需用到求法向量的函数，到时可直接调用。<br>2、已知2点求向量的函数十分简单，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getvector</span><span class="params">(<span class="keyword">float</span> a[<span class="number">3</span>],<span class="keyword">float</span> b[<span class="number">3</span>],<span class="keyword">float</span> vec[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">		vec[i] = a[i] - b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、调用两次上述函数即可获得两个向量，接下来要做的就是拿这两个向量进行叉乘，以得到法向量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数中的法向量n[3]是提前在函数外定义的，通过调用函数给n[3]赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crossproject</span><span class="params">(<span class="keyword">float</span> vec1[<span class="number">3</span>],<span class="keyword">float</span> vec2[<span class="number">3</span>],<span class="keyword">float</span> n[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n[<span class="number">0</span>] = vec1[<span class="number">1</span>]*vec2[<span class="number">2</span>]-vec1[<span class="number">2</span>]*vec2[<span class="number">1</span>];</span><br><span class="line">	n[<span class="number">1</span>] = vec1[<span class="number">2</span>]*vec2[<span class="number">0</span>]-vec1[<span class="number">0</span>]*vec2[<span class="number">2</span>];</span><br><span class="line">	n[<span class="number">2</span>] = vec1[<span class="number">0</span>]*vec2[<span class="number">1</span>]-vec1[<span class="number">1</span>]*vec2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、将上面两个函数简单封装一下如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数中的法向量n[3]是提前在函数外定义的，通过调用函数给n[3]赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">project</span><span class="params">(<span class="keyword">float</span> point1[<span class="number">3</span>],<span class="keyword">float</span> b[<span class="number">3</span>],<span class="keyword">float</span> c[<span class="number">3</span>],<span class="keyword">float</span> n[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> vec1[<span class="number">3</span>],vec2[<span class="number">3</span>];</span><br><span class="line">	getvector(a,b,vec1);</span><br><span class="line">	getvector(b,c,vec2);</span><br><span class="line">	crossproject(vec1,vec2,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、这样一个求法向量的函数就写好了，使用方法如下例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a[<span class="number">3</span>] = &#123;<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> b[<span class="number">3</span>] = &#123;<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> c[<span class="number">3</span>] = &#123;<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> n[<span class="number">3</span>];</span><br><span class="line">project(a,b,c,n);</span><br><span class="line"><span class="comment">//调用过project()函数之后，n[3]数组内的值即为法向量</span></span><br></pre></td></tr></table></figure>
<h2 id="生成四面体"><a href="#生成四面体" class="headerlink" title="生成四面体"></a>生成四面体</h2><p>1、使用OpenGL生成四面体的基本方法为，<strong>给定三个点和一个法向量</strong>，调用OpenDL的库函数，即可<strong>生成一个由这三点围成的三角形平面</strong>，<strong>四个三角形平面即可组成一个四面体</strong>。<br>2、将课上的shinyjet.cpp模板复制到src相应的文件夹中（\SB-WinSrc\examples\src\chapt05\shinyjet），然后回到project对应文件夹中，打开shinyjet.vcxproj工程，点击调试，成功后出来的应该为一个蓝绿色底的对话框。<br><img src="https://img-blog.csdnimg.cn/20191020165015109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br><img src="https://img-blog.csdnimg.cn/20191020165314158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>3、在RenderSenen()函数中的下图位置 <strong>写入glBegin()与glEnd()函数，并在二者之间插入画三角形的代码</strong>。<img src="https://img-blog.csdnimg.cn/20191020165836169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> rgfPoints4[<span class="number">12</span>] = &#123;<span class="number">-0.6f</span>,<span class="number">-0.6f</span>,<span class="number">-0.6f</span>,</span><br><span class="line">						<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,</span><br><span class="line">						<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,</span><br><span class="line">						<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="comment">//这是定义了一个长为12的数组，每3个元素代表一个点坐标，共4个点</span></span><br><span class="line">glColor3ub(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置要生成图形的颜色</span></span><br><span class="line">glBegin(GL_TRIANGLES);</span><br><span class="line"><span class="comment">//开始生成三角形</span></span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">6</span>);</span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">3</span>);</span><br><span class="line">DrawTriangle(rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">6</span>);</span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">6</span>,rgfPoints4+<span class="number">9</span>);</span><br><span class="line"><span class="comment">//↑函数功能：给定3个点生成一个三角形，调用4次生成4个三角形组成四面体</span></span><br><span class="line">   glEnd();</span><br><span class="line">   <span class="comment">//结束</span></span><br></pre></td></tr></table></figure>
<p>4、在这里，glColor3ub、glBegin，glEnd均是OpenGL的库函数，不需要我们定义，直接调用即可，<strong>需要我们写的是DrawTriangle函数</strong>，接下来我们就开始定义DrawTriangle()，前面已经提到，需要用<strong>3个点和一个法向量</strong>来确定一个平面，因此我们把第一节中生成法向量的函数复制到此文件的开头处，以便调用。<br><img src="https://img-blog.csdnimg.cn/20191020171413456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>5、画三角形的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawTriangle</span><span class="params">(<span class="keyword">float</span> a[<span class="number">3</span>],<span class="keyword">float</span> b[<span class="number">3</span>],<span class="keyword">float</span> c[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> n[<span class="number">3</span>];	<span class="comment">//定义一个数组用来存放法向量</span></span><br><span class="line">	project(a,b,c,n);	<span class="comment">//调用生成法向量的函数由a,b,c三点生成法向量n</span></span><br><span class="line">	glNormal3fv(n);</span><br><span class="line">	glVertex3fv(a);</span><br><span class="line">	glVertex3fv(b);</span><br><span class="line">	glVertex3fv(c);		<span class="comment">//此四行为利用用库函数，由法向量n和三个点abc生成一个平面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、完成上述步骤后，进行调试，即可得到一个四面体<br><img src="https://img-blog.csdnimg.cn/20191020171854203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"></p>
<p><em><strong>Continue……</strong></em></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>数字化方法基础_常用函数</title>
    <url>/2019/10/29/006-%E6%95%B0%E5%AD%97%E5%8C%96%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="1-叉乘"><a href="#1-叉乘" class="headerlink" title="1. 叉乘"></a>1. 叉乘</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">crossproject</span><span class="params">(<span class="keyword">float</span> vec1[<span class="number">3</span>],<span class="keyword">float</span> vec2[<span class="number">3</span>],<span class="keyword">float</span> n[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n[<span class="number">0</span>] = vec1[<span class="number">1</span>]*vec2[<span class="number">2</span>]-vec1[<span class="number">2</span>]*vec2[<span class="number">1</span>];</span><br><span class="line">	n[<span class="number">1</span>] = vec1[<span class="number">2</span>]*vec2[<span class="number">0</span>]-vec1[<span class="number">0</span>]*vec2[<span class="number">2</span>];</span><br><span class="line">	n[<span class="number">2</span>] = vec1[<span class="number">0</span>]*vec2[<span class="number">1</span>]-vec1[<span class="number">1</span>]*vec2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-单位化矢量"><a href="#2-单位化矢量" class="headerlink" title="2. 单位化矢量"></a>2. 单位化矢量</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Normalize</span><span class="params">(<span class="keyword">float</span> n[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> length;</span><br><span class="line">	length = <span class="built_in">sqrt</span>(n[<span class="number">0</span>]*n[<span class="number">0</span>]+n[<span class="number">1</span>]*n[<span class="number">1</span>]+n[<span class="number">2</span>]*n[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">		n[i] /= length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-矩阵乘法4×4-×-4×1"><a href="#3-矩阵乘法4×4-×-4×1" class="headerlink" title="3. 矩阵乘法4×4  ×  4×1"></a>3. 矩阵乘法4×4  ×  4×1</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ApplyMatrix</span><span class="params">(<span class="keyword">float</span> *P0,<span class="keyword">float</span> *translation,<span class="keyword">float</span> *P1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">		P1[i] = P0[<span class="number">0</span>]*translation[i]+P0[<span class="number">1</span>]*translation[i+<span class="number">4</span>]+P0[<span class="number">2</span>]*translation[i+<span class="number">8</span>]+translation[i+<span class="number">12</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-矩阵乘法-4×4-×-4×4"><a href="#4-矩阵乘法-4×4-×-4×4" class="headerlink" title="4. 矩阵乘法 4×4  ×  4×4"></a>4. 矩阵乘法 4×4  ×  4×4</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">float</span> *rotation,<span class="keyword">float</span> *translation,<span class="keyword">float</span> *tran)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)</span><br><span class="line">				tran[<span class="number">4</span>*i+j] += rotation[<span class="number">4</span>*k+j]*translation[<span class="number">4</span>*i+k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>机器人</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP8266_APP连接试验</title>
    <url>/2020/12/31/007-ESP8266_APP%E8%BF%9E%E6%8E%A5%E8%AF%95%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本次试验使用的是ESP8266 NodeMCU</p>
<h1 id="硬件部分"><a href="#硬件部分" class="headerlink" title="硬件部分"></a>硬件部分</h1><h2 id="8266固件烧录"><a href="#8266固件烧录" class="headerlink" title="8266固件烧录"></a>8266固件烧录</h2><p>固件烧录的是nodemcu官方固件，打开官方提供的ESP8266Flasher，在配置一栏选择nodemcu固件，烧录地址为0x00000。<br><img src="https://img-blog.csdnimg.cn/20200519172949693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="nodemcu烧录"></p>
<h2 id="Arduino-IDE-8266版型下载"><a href="#Arduino-IDE-8266版型下载" class="headerlink" title="Arduino IDE 8266版型下载"></a>Arduino IDE 8266版型下载</h2><p>打开Arduino IDE，在文件-首选项-附加开发板管理器网址中输入：<br><code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code><br><img src="https://img-blog.csdnimg.cn/20200519173455915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="版型下载1"><br>然后打开工具-开发板-开发板管理器，在搜索框输入esp8266，在下方弹出的搜索结果中选中要下载的版型，点击安装即可。（下载速度较慢，可挂梯子）<br><img src="https://img-blog.csdnimg.cn/20200519173759807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="版型下载2"><br>到此为止，硬件部分的准备工作就完成了，接下来就可以使用Arduino IDE进行ESP8266的编程。</p>
<h2 id="安装MQTT库"><a href="#安装MQTT库" class="headerlink" title="安装MQTT库"></a>安装MQTT库</h2><p>因本程序设计MQTT部分，因此还需要安装MQTT库才能正常编译程序，打开项目-加载库-管理库，有许多mqtt库可以选择，我使用的是PubSubClient。<br><img src="https://img-blog.csdnimg.cn/20200519174652331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="MQTT库"></p>
<h2 id="ESP8266程序设计"><a href="#ESP8266程序设计" class="headerlink" title="ESP8266程序设计"></a>ESP8266程序设计</h2><p>代码不长，贴在下方</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;ESP8266WiFi.h&gt;</span><br><span class="line">#include &lt;PubSubClient.h&gt;</span><br><span class="line">WiFiClient espClient;</span><br><span class="line">PubSubClient client(espClient);</span><br><span class="line"><span class="keyword">const</span> char* wifissid = <span class="string">&quot;Wifi_SSID&quot;</span>; <span class="comment">//自己家WIFI</span></span><br><span class="line"><span class="keyword">const</span> char* password = <span class="string">&quot;Wifi_Password&quot;</span>; <span class="comment">//自己家WIFI密码</span></span><br><span class="line"><span class="keyword">const</span> char* mqtt_server = <span class="string">&quot;***,***,***,***&quot;</span>;<span class="comment">//MQTT服务器地址</span></span><br><span class="line"><span class="keyword">const</span> char* mqtt_id = <span class="string">&quot;827855942_ESP&quot;</span>;<span class="comment">//MQTT ID需要唯一，这里我设置成自己的QQ号+_ESP</span></span><br><span class="line"><span class="keyword">const</span> char* Mqtt_sub_topic = <span class="string">&quot;827855942_ESP&quot;</span>;   <span class="comment">//ESP8266订阅的topic，其他客户端向此topic发送信息时ESP8266会收到，设成自己的QQ号+_ESP</span></span><br><span class="line"><span class="keyword">const</span> char* Mqtt_pub_topic = <span class="string">&quot;827855942&quot;</span>;  <span class="comment">//ESP8266发布消息的topic，上报消息给手机APP的TOPIC，设成自己的QQ号</span></span><br><span class="line">long lastMsg = <span class="number">0</span>; <span class="comment">//定时用的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  pinMode(<span class="number">2</span>, OUTPUT);     </span><br><span class="line">  Serial.begin(<span class="number">115200</span>);<span class="comment">//设置波特率</span></span><br><span class="line">  setup_wifi();<span class="comment">//初始化wifi</span></span><br><span class="line">  client.setServer(mqtt_server, <span class="number">1883</span>);<span class="comment">//设定MQTT服务器与使用的端口，1883是默认的MQTT端口</span></span><br><span class="line">  client.setCallback(callback); <span class="comment">//设定回调方式，当ESP8266收到订阅消息时会调用此方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化Wifi</span></span><br><span class="line"><span class="comment">//连接成功后可在串口监视器看到ESP8266的IP地址</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">setup_wifi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  Serial.println();</span><br><span class="line">  Serial.print(<span class="string">&quot;Connecting to &quot;</span>);</span><br><span class="line">  Serial.println(wifissid);</span><br><span class="line">  WiFi.begin(wifissid, password);</span><br><span class="line">  <span class="keyword">while</span> (WiFi.status() != WL_CONNECTED) &#123;</span><br><span class="line">    delay(<span class="number">500</span>);</span><br><span class="line">    Serial.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;WiFi connected&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;IP address: &quot;</span>);</span><br><span class="line">  Serial.println(WiFi.localIP());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数，参数固定不能改</span></span><br><span class="line"><span class="comment">//payload内容可以是任意的，此程序中传递的是JSON数据</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">callback</span>(<span class="params">char* topic, byte* payload, unsigned int length</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">String</span> msg=<span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="built_in">String</span> LED_set = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  Serial.print(<span class="string">&quot;Message arrived [&quot;</span>);</span><br><span class="line">  Serial.print(topic);</span><br><span class="line">  Serial.print(<span class="string">&quot;] &quot;</span>);</span><br><span class="line">  <span class="comment">//msg中存放的就是传递过来的json数据，此处为&#123;&quot;set_led&quot;:1&#125;格式</span></span><br><span class="line">  <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    msg+= (char)payload[i];</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(msg);</span><br><span class="line">  <span class="keyword">if</span>(msg.indexOf(<span class="string">&quot;led&quot;</span>))  <span class="comment">//判断是否是要设置LED灯</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//取出LED_set数据 并执行</span></span><br><span class="line">    LED_set = msg.substring(msg.indexOf(<span class="string">&quot;led\&quot;:&quot;</span>)+<span class="number">5</span>,msg.indexOf(<span class="string">&quot;&#125;&quot;</span>)); </span><br><span class="line">    digitalWrite(<span class="number">2</span>,!LED_set.toInt()); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断线重连</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">reconnect</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (!client.connected()) &#123;</span><br><span class="line">    Serial.print(<span class="string">&quot;Attempting MQTT connection...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (client.connect(mqtt_id)) &#123;</span><br><span class="line">      Serial.println(<span class="string">&quot;connected&quot;</span>);</span><br><span class="line">      <span class="comment">//连接成功以后就开始订阅</span></span><br><span class="line">      client.subscribe(Mqtt_sub_topic,<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.print(<span class="string">&quot;failed, rc=&quot;</span>);</span><br><span class="line">      Serial.print(client.state());</span><br><span class="line">      Serial.println(<span class="string">&quot; try again in 5 seconds&quot;</span>);</span><br><span class="line">      delay(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">loop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">//MQTT是否连接，若未连接则重连</span></span><br><span class="line">  <span class="keyword">if</span> (!client.connected()) &#123;</span><br><span class="line">    reconnect();</span><br><span class="line">  &#125;</span><br><span class="line">  client.loop();</span><br><span class="line">  long now = millis();<span class="comment">//运行时间</span></span><br><span class="line">  <span class="keyword">if</span> (now - lastMsg &gt; <span class="number">2000</span>) &#123;</span><br><span class="line">    lastMsg = now;</span><br><span class="line">    <span class="comment">//打包发送数据给pubtopic    </span></span><br><span class="line">    <span class="built_in">String</span> json = <span class="string">&quot;&#123;\&quot;temperature\&quot;:&quot;</span>+<span class="built_in">String</span>(analogRead(A0))+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    client.publish(Mqtt_pub_topic,json.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="APP部分"><a href="#APP部分" class="headerlink" title="APP部分"></a>APP部分</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p> Start a new Android project，我选择Empty Activity，name随意，language java，Android版本要小于等于手机安卓版本。（尽量用真机调试，虚拟机bug太多）<br><img src="https://img-blog.csdnimg.cn/20200519181712551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="app_1"></p>
<h2 id="UI设计"><a href="#UI设计" class="headerlink" title="UI设计"></a>UI设计</h2><p> 打开app-res-layout下的activity_main.xml文件，设计UI<br>    常用的代码列下<br>    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android:orientation=<span class="string">&quot;vertical&quot;</span>	<span class="comment">//设置线性布局方向</span></span><br><span class="line">android:background=<span class="string">&quot;#FFFFFF&quot;</span>	<span class="comment">//设置背景色</span></span><br><span class="line">android:src=<span class="string">&quot;@drawable/pic&quot;</span>	<span class="comment">//ImageView下添加图片</span></span><br><span class="line">android:layout_margin=<span class="string">&quot;10dp&quot;</span>	<span class="comment">//设置距离父空间边缘距离</span></span><br><span class="line">android:id=<span class="string">&quot;@+id/image_1		//设置id</span></span><br><span class="line"><span class="string">android:layout_weight=&quot;</span><span class="number">1</span><span class="string">&quot;		//布局内设置权重</span></span><br><span class="line"><span class="string">android:gravity=&quot;</span>center_vertical<span class="string">&quot;	//布局内设置垂直居中</span></span><br></pre></td></tr></table></figure></p>
<h2 id="主程序设计"><a href="#主程序设计" class="headerlink" title="主程序设计"></a>主程序设计</h2><p> 打开MainActivity.java编写程序<br>    1. OnCreate函数是程序打开后最先运行的地方<br>    2. 按钮单击事件<br>    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button_1 = findViewById(R.id.button_1); <span class="comment">//寻找XML里面真正的ID，与自己初始化的变量绑定</span></span><br><span class="line">button_1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里是单击之后执行的地方</span></span><br><span class="line">	<span class="comment">//在当前ativity 显示内容为hello的短时间弹窗</span></span><br><span class="line">	Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">&quot;hello&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>    3. 导入JAR包<br>        将mqtt的JAR包复制到app下的libs文件夹中<br>        右键JAR包Add as Lib确定<img src="https://img-blog.csdnimg.cn/20200519183641965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="app_2"><br>    4. 移植Mqtt_init()函数<br>    5. 移植startReconnect()函数<br>    6. 移植publishmessageplus()函数<br>    7. 在OnCreate中加入<br>    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mqtt_init();</span><br><span class="line">startReconnect();</span><br><span class="line">handler = <span class="keyword">new</span> Handler() &#123;</span><br></pre></td></tr></table></figure><br>注：每完成一小步都要刷入真机调试，以免调bug之痛</p>
<p>以上就完成了基本的app与ESP8266的通信。<br><img src="https://img-blog.csdnimg.cn/20200519185054690.png#pic_center" alt="result_2"><br><img src="https://img-blog.csdnimg.cn/20200519184734195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="result_1"><br>感谢正哥，B站up<a href="https://space.bilibili.com/265908761/">阿正啷个哩个啷</a>，大佬的教程</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title>二相四线制步进电机驱动原理与Proteus仿真</title>
    <url>/2021/01/01/008-%E4%BA%8C%E7%9B%B8%E5%9B%9B%E7%BA%BF%E5%88%B6%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86%E4%B8%8EProteus%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<h2 id="一、L298N"><a href="#一、L298N" class="headerlink" title="一、L298N"></a>一、L298N</h2><p><img src="https://img-blog.csdnimg.cn/20201231180306615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="L298N"><br>    单片机无法直接驱动步进电机，需要L298N进行驱动。L298N的最大功耗为20W，驱动部分端子供电范围+5~+30V，控制信号输入电压范围5V/0V，驱动部分峰值电流2A。</p>
<h2 id="二、两相四线制步进电机"><a href="#二、两相四线制步进电机" class="headerlink" title="二、两相四线制步进电机"></a>二、两相四线制步进电机</h2><p><strong>1. 技术指标</strong><br>（1）相数：电机内部的线圈组数。<br>（2）拍数：完成一个磁场周期性变化所需要脉冲数或导电状态。两相四线电机可以使用单四拍、双四拍和八拍的方式驱动。<br>（3）步距角：磁场变化一次电机转过的角度，两相四线电机步距角为0.9°/1.8°。<br><strong>2. 工作原理</strong><br><img src="https://img-blog.csdnimg.cn/20201231184450180.png" alt="电机原理"><br>    如图所示，电机有四条控制信号A+、A-、B+、B-，通过控制这四条引线上的励磁脉冲，就可以控制步进电机的转动。以四拍驱动方式为例，顺时针转动时<br>| STEP | A+   | A-   | B+   | B-   |      |<br>| —- | —- | —- | —- | —- | —- |<br>| 1    | 1    | 0    | 0    | 0    |      |<br>| 2    | 0    | 1    | 0    | 0    |      |<br>| 3    | 0    | 0    | 1    | 0    |      |<br>| 4    | 0    | 0    | 0    | 1    |      |<br><strong>ps：</strong>电动机的旋转方向由脉冲顺序决定，转动速度和脉冲频率有关。</p>
<h2 id="三、接线方法"><a href="#三、接线方法" class="headerlink" title="三、接线方法"></a>三、接线方法</h2><ul>
<li>控制端：IN1、IN2、IN3、IN4接单片机的四个管脚，用于给出脉冲</li>
<li>输入端：5V输入接板载5V，12V输入外接电源</li>
<li>使能端：ENA、ENB接板载5V，默认使能</li>
<li>输出端：OUT1、OUT2、OUT3、OUT4分别接步进电机的四条线红绿黄蓝。<h2 id="四、Proteus仿真"><a href="#四、Proteus仿真" class="headerlink" title="四、Proteus仿真"></a>四、Proteus仿真</h2>在Proteus中的接线情况如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210101142442184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="Protues接线"><br>参考程序如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line">sbit enable = P3^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">114</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unsigned <span class="keyword">char</span> step[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>&#125;;	<span class="comment">//顺时针转动</span></span><br><span class="line">	<span class="comment">//unsigned char istep[] = &#123;0x01,0x02,0x04,0x08&#125;; //逆时针转动</span></span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	enable=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			P2 = step[i];</span><br><span class="line">			delay(<span class="number">200</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
仿真结果：<br><img src="https://img-blog.csdnimg.cn/20210101142900715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="仿真结果"></li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>proteus</tag>
      </tags>
  </entry>
  <entry>
    <title>Proteus仿真错误解决方法：No power supply specified for net 5V in Power Rail Configuration.</title>
    <url>/2021/01/02/009-Proteus%E4%BB%BF%E7%9C%9F%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9ANo%20power%20supply%20specified%20for%20net%205V%20in%20Power%20Rail%20Configuration./</url>
    <content><![CDATA[<p><strong>错误原因</strong><br>设置的5V电源没有添加到电网，如下图红圈中的电源。<br><img src="https://img-blog.csdnimg.cn/20210101143220770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="5V"><br><strong>解决方法</strong><br>设计—配置供电网—在电源供应中，并将未连接电网的电源增加到网络连接即可。<br><img src="https://img-blog.csdnimg.cn/2021010114350341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210101143531253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>proteus</tag>
        <tag>bug解决</tag>
      </tags>
  </entry>
  <entry>
    <title>使用38译码器扩展单片机接口</title>
    <url>/2021/01/04/011-%E4%BD%BF%E7%94%A838%E8%AF%91%E7%A0%81%E5%99%A8%E6%89%A9%E5%B1%95%E5%8D%95%E7%89%87%E6%9C%BA%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="74HC138译码器"><a href="#74HC138译码器" class="headerlink" title="74HC138译码器"></a>74HC138译码器</h2><p><strong>1. 介绍</strong><br>    在设计单片机电路的时候，单片机的IO口数量是有限的，有时并满足不了我们的设计需求，因此为了控制更多的器件，就需要使用一些外围的数字芯片进行引脚扩展。常用的是74HC138，也叫38译码器。<br><img src="https://img-blog.csdnimg.cn/20210103153614461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2. 工作原理</strong><br>    38译码器，从名字来分析就是把3种输入状态翻译成8种输出状态。对于数字器件的引脚，如果一个引脚输入的时候，有 0 和 1 两种状态；对于两个引脚输入的时候，就会有 00、01、10、11 这四种状态了，那么对于 3 个输入的时候，就会出现 8 种状态了，真值表如下图所示。<br><img src="https://img-blog.csdnimg.cn/2021010315402528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    可以看出，左面三位相当于从0~8，右面则是8种输出状态。在任意输入状态时，只有一个输出引脚是低电平，这一点需要注意，也可以通过连接反相器实现高电平输出。<br>    使用时，E2、E3接地，E1用来控制译码器的选通1为开启，0为关闭。A、B、C分别对应A0、A1、A2。E1、A、B、C连接单片机的4个引脚，就可以实现共输出状态的控制。</p>
<h2 id="Protues仿真实验"><a href="#Protues仿真实验" class="headerlink" title="Protues仿真实验"></a>Protues仿真实验</h2><p><strong>1. 实验目的</strong><br>    使用51单片机控制12个电机的选择启动<br><strong>2. 实验过程</strong><br><img src="https://img-blog.csdnimg.cn/20210103155500832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>L298N作为步进电机的驱动</li>
<li>CD4066作为步进电机的选通开关，控制端收到高电平则导通</li>
<li>74HC138译码器+74HC240反相器用于扩展引脚，将单片机的信号经翻译后发送给给CD4066选择电机</li>
<li><em>3. 实验结果</em>*<br>   电机按照预期要求以此选通启动。<br><img src="https://img-blog.csdnimg.cn/20210103160034971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><em>4. 代码</em>*<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line">sbit enable = P3^<span class="number">0</span>;</span><br><span class="line">sbit key = P3^<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">114</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line">			</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unsigned <span class="keyword">char</span> step[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>&#125;;	<span class="comment">//顺时针转动</span></span><br><span class="line">	<span class="comment">//unsigned char istep[] = &#123;0x01,0x02,0x04,0x08&#125;; //逆时针转动	</span></span><br><span class="line">	unsigned <span class="keyword">char</span> table[] = &#123;<span class="number">0x80</span>,<span class="number">0x90</span>,<span class="number">0xa0</span>,<span class="number">0xb0</span>,<span class="number">0xc0</span>,<span class="number">0xd0</span>,<span class="number">0xe0</span>,<span class="number">0xf0</span>,<span class="number">0x08</span>,<span class="number">0x09</span>,<span class="number">0x0a</span>,<span class="number">0x0b</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">	enable=<span class="number">1</span>;</span><br><span class="line">	P1=<span class="number">0x00</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(key == <span class="number">0</span>);</span><br><span class="line">		&#123;</span><br><span class="line">			delay(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">if</span>(key == <span class="number">0</span>)</span><br><span class="line">			&#123;				</span><br><span class="line">				num++;</span><br><span class="line">				<span class="keyword">if</span>(num&gt;=<span class="number">12</span>)</span><br><span class="line">					num=-<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span>(!key);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		if(num==-1)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			P1=0x00;</span></span><br><span class="line"><span class="comment">			P0=0x00;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		else if(num&lt;8)</span></span><br><span class="line"><span class="comment">			P1=table1[num];</span></span><br><span class="line"><span class="comment">		else</span></span><br><span class="line"><span class="comment">			P0=table2[num-8];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">		<span class="keyword">if</span>(num==-<span class="number">1</span>)</span><br><span class="line">			P1=<span class="number">0x00</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			P1 = table[num];</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			P2 = step[i];</span><br><span class="line">			delay(<span class="number">500</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>proteus</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动多个二相四线制步进电机的Proteus仿真</title>
    <url>/2021/01/03/010-%E9%A9%B1%E5%8A%A8%E5%A4%9A%E4%B8%AA%E4%BA%8C%E7%9B%B8%E5%9B%9B%E7%BA%BF%E5%88%B6%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E7%9A%84Proteus%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<h2 id="CD4066介绍"><a href="#CD4066介绍" class="headerlink" title="CD4066介绍"></a>CD4066介绍</h2><p><strong>1. 功能简介</strong><br>    CD4066是四双向模拟开关，主要用作模拟或数字信号的多路传输。CD4066 的每个封装内部有4 个独立的模拟开关，每个模拟开关有输入、输出、控制三个端子，其中输入端和输出端可互换。<br>    <img src="https://img-blog.csdnimg.cn/20210101164242237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="CD4066"><br><strong>2. 引脚说明</strong></p>
<ul>
<li>CONTROL：开关控制端 [1] </li>
<li>IN/OUT：输入/输出端</li>
<li>OUT/IN：输出/输入端</li>
<li>VDD：电源正</li>
<li>VSS：电源负</li>
</ul>
<p><strong>3. 控制方法</strong><br>    将CD4066的四个输入端接在L298N的输出口，CD4066的输出端接在步进电机的A+、A-、B+、B-端口，四个控制口同时接在单片机的某一引脚上，实现单片机的一个引脚控制一个CD4066上四个开关的同时开断，进而实现步进电机的选择。</p>
<h2 id="Proteus仿真"><a href="#Proteus仿真" class="headerlink" title="Proteus仿真"></a>Proteus仿真</h2><p>Proteus接线图如下图所示。<br><img src="https://img-blog.csdnimg.cn/20210101164743892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于Proteus内没有CD4066，只有4066，因此考虑将4个4066组合视为一个整体。<br><img src="https://img-blog.csdnimg.cn/20210102105614123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>仿真结果：<br><img src="https://img-blog.csdnimg.cn/20210102105732744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line">sbit enable = P3^<span class="number">0</span>;</span><br><span class="line">sbit key = P3^<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">114</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line">			</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unsigned <span class="keyword">char</span> step[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>&#125;;	<span class="comment">//顺时针转动</span></span><br><span class="line">	<span class="comment">//unsigned char istep[] = &#123;0x01,0x02,0x04,0x08&#125;; //逆时针转动</span></span><br><span class="line">	unsigned <span class="keyword">char</span> table1[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>&#125;;</span><br><span class="line">	unsigned <span class="keyword">char</span> table2[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">	enable=<span class="number">1</span>;</span><br><span class="line">	P1 = <span class="number">0x00</span>;</span><br><span class="line">	P0 = <span class="number">0x00</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(key == <span class="number">0</span>);</span><br><span class="line">		&#123;</span><br><span class="line">			delay(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">if</span>(key == <span class="number">0</span>)</span><br><span class="line">			&#123;				</span><br><span class="line">				num++;</span><br><span class="line">				<span class="keyword">if</span>(num&gt;=<span class="number">12</span>)</span><br><span class="line">					num=-<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span>(!key);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(num==-<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			P1=<span class="number">0x00</span>;</span><br><span class="line">			P0=<span class="number">0x00</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;<span class="number">8</span>)</span><br><span class="line">			P1=table1[num];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			P0=table2[num-<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			P2 = step[i];</span><br><span class="line">			delay(<span class="number">500</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>proteus</tag>
      </tags>
  </entry>
  <entry>
    <title>LabView2019的安装与卸载</title>
    <url>/2021/01/05/012-LabView2019%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="LabView2019的安装"><a href="#LabView2019的安装" class="headerlink" title="LabView2019的安装"></a>LabView2019的安装</h1><p><strong>注：此版本为英文版，如需要要中文版的请参考<a href="https://blog.csdn.net/weixin_44543463/article/details/112323169">LabView2018的安装
</a></strong><br><strong>1. 下载网盘里面的LabView2019.zip压缩包</strong></p>
<blockquote>
<p>百度网盘链接：<a href="https://pan.baidu.com/s/1gyiFn5nOdPkLdp-1kRwwHA">https://pan.baidu.com/s/1gyiFn5nOdPkLdp-1kRwwHA </a><br>提取码：labv<br>&emsp;&emsp;<br>阿里云盘链接：<a href="https://www.aliyundrive.com/s/fgfRMQYBBuu">https://www.aliyundrive.com/s/fgfRMQYBBuu</a><br>阿里云盘无法分享压缩包，因此改了文件格式，下载完后缀名改回.zip即可</p>
</blockquote>
<p><strong>2. 解压进入对应64位或32位文件夹，再解压文件夹内的的ISO文件，进入打开的文件夹，双击install.exe</strong><br><img src="https://img-blog.csdnimg.cn/20210104114600105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br><strong>3. 按照下列步骤进行安装</strong><br><img src="https://img-blog.csdnimg.cn/20210104114709712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br><img src="https://img-blog.csdnimg.cn/20210104114758490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br><img src="https://img-blog.csdnimg.cn/20210104114822143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br><img src="https://img-blog.csdnimg.cn/2021010411485786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br><img src="https://img-blog.csdnimg.cn/20210104114922913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br><img src="https://img-blog.csdnimg.cn/20210104114949815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br><img src="https://img-blog.csdnimg.cn/2021010411501288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br>等待一段时间的安装<br><img src="https://img-blog.csdnimg.cn/20210104120355448.png" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210104120440529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br>这里不要登陆账号，直接关闭所有窗口，然后点击立即重启。<br><img src="https://img-blog.csdnimg.cn/20210104120735952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br><strong>3. 进行软件的破解</strong><br>打开Crack文件夹下面的破解工具<br><img src="https://img-blog.csdnimg.cn/20210104121616790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br>鼠标右键激活，将所有都变成绿色<br><img src="https://img-blog.csdnimg.cn/20210104121903353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%"><br>至此完成了LabView的安装和破解，接下来就可以正常使用了。<br>在开始菜单中所有应用中可以找到新安装的LabView2019<br><img src="https://img-blog.csdnimg.cn/20210104122111240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></p>
<h1 id="LabView2019的卸载"><a href="#LabView2019的卸载" class="headerlink" title="LabView2019的卸载"></a>LabView2019的卸载</h1><p>打开控制面板，按照安装时间排序，找到图示的程序，双击卸载<br><img src="https://img-blog.csdnimg.cn/20210104161910299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br>选择删除全部<br><img src="https://img-blog.csdnimg.cn/20210104162033580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br>再在控制面板中删除其它有关LabView的程序</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>LabView2018的安装</title>
    <url>/2021/01/07/013-LabView2018%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>百度网盘链接：<a href="https://pan.baidu.com/s/1gyiFn5nOdPkLdp-1kRwwHA">https://pan.baidu.com/s/1gyiFn5nOdPkLdp-1kRwwHA</a><br>提取码：labv<br>&emsp;&emsp;<br>阿里云盘链接：<a href="https://www.aliyundrive.com/s/vBKNYBdLsXV">https://www.aliyundrive.com/s/vBKNYBdLsXV</a><br>阿里云盘无法分享压缩包，因此改了文件格式，下载完后缀名改回.zip即可</p>
</blockquote>
<p>安装前请新建一个文件夹作为labview的安装路径，最好不要安装在盘符根目录下。</p>
<ol>
<li>下载LabView2018安装包解压，运行安装程序。<img src="https://img-blog.csdnimg.cn/20210107173145226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>选择安装程序的解压路径，点击Unzip<img src="https://img-blog.csdnimg.cn/20210107172140459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>开始安装，点击下一步<img src="https://img-blog.csdnimg.cn/20210107172247778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>输入用户信息，可以随意输入<img src="https://img-blog.csdnimg.cn/20210107172331872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>不用输入序列号，直接跳过，点击下一步<img src="https://img-blog.csdnimg.cn/2021010717240871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>选择安装目录，点击下一步<img src="https://img-blog.csdnimg.cn/20210107172435834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>选择需要安装的组件，一般情况默认下一步即可<img src="https://img-blog.csdnimg.cn/20210107172529588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>接受许可，一直下一步即可<img src="https://img-blog.csdnimg.cn/20210107172613247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210107172632324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210107172709490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210107172733924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210107172811930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
如果出现需要安装支持，如果不用NI的采集卡，是不需要安装这个驱动的，直接点击不需要支持就可以，如果后续需要驱动的话可以另行安装。
<img src="https://img-blog.csdnimg.cn/20210325120149703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210107172829860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>进行软件的注册破解<br>打开破解工具<img src="https://img-blog.csdnimg.cn/20210107173057314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
鼠标右键激活，将所有都变成绿色
<img src="https://img-blog.csdnimg.cn/20210104121903353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%">
至此完成了LabView的安装和破解，接下来就可以正常使用了。
在开始菜单中所有应用中可以找到新安装的LabView2019
<img src="https://img-blog.csdnimg.cn/20210325120533440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>LabView学习笔记（一）：基础介绍</title>
    <url>/2021/01/07/014-LabView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p>
<hr>
<h1 id="一、前面板"><a href="#一、前面板" class="headerlink" title="一、前面板"></a>一、前面板</h1><h2 id="1-控件选板"><a href="#1-控件选板" class="headerlink" title="1. 控件选板"></a>1. 控件选板</h2><p>（1） 控件来源于控件选板，右键可以打开控件选板，控件可以点击后添加到前面板，也可以通过拖拽添加控件。<br><img src="https://img-blog.csdnimg.cn/20210107175250351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%"><br>（2） 分类</p>
<ul>
<li>数值控件：输入和显示数值数据</li>
<li>布尔控件：创建按钮、开关和指示灯</li>
<li>路径控件：输入或返回文件或目录的地址</li>
<li>数组、矩阵、簇控件：创建数组、矩阵、簇</li>
<li>列表框、树形和表格等控件：提供选项列表</li>
<li>图形控件：图形和图表的形式绘制数值数据</li>
<li>枚举控件：提供一个可供选择的项列表</li>
<li>容器控件：用于组合各种控件<h2 id="2-工具选板"><a href="#2-工具选板" class="headerlink" title="2. 工具选板"></a>2. 工具选板</h2><img src="https://img-blog.csdnimg.cn/20210107180055359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210107180117367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="90%"></li>
</ul>
<h1 id="二、程序框图"><a href="#二、程序框图" class="headerlink" title="二、程序框图"></a>二、程序框图</h1><h2 id="1-组成"><a href="#1-组成" class="headerlink" title="1. 组成"></a>1. 组成</h2><p>  接线端（前面板）、子VI、函数、常量、结构、连线</p>
<h2 id="2-函数选板"><a href="#2-函数选板" class="headerlink" title="2. 函数选板"></a>2. 函数选板</h2><p>  依然是右键打开</p>
<h2 id="3-程序框图"><a href="#3-程序框图" class="headerlink" title="3. 程序框图"></a>3. 程序框图</h2><p>（1） 接线端：包括前面板对象程序框图外观，可以右键不选显示为图标，使程序框图界面更简洁。<br>（2） 节点：带有输入和输出端，是用来进行运算的，比如函数节点、子VI节点（双击即可查看子VI的前面板和程序框图，ExpressVI是特殊的子VI所需连线数量最少，通过对话框配置）。<br>（3） 连线</p>
<ul>
<li>程序框图对象之间通过连线传输数据</li>
<li>不同数据类型的连线颜色、粗细和样式均有差异</li>
<li>断开的连线显示为中间带有红叉的黑色虚线</li>
<li>按下Ctrl+B删除所有断线</li>
<li>右键连线可以整理连线</li>
<li>框选程序框图的一部分，使用整理程序框图可以使程序框图更易读</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>LabView学习笔记（二）：滤波器实验</title>
    <url>/2021/01/08/015-LabView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p>
<hr>
<h3 id="滤波器实验"><a href="#滤波器实验" class="headerlink" title="滤波器实验"></a>滤波器实验</h3><p><strong>1. 主要目的</strong>：学习VI的创建方法<br><strong>2. 操作步骤</strong>：<br>（1）放置Express VI至程序框图<br>（2）配置弹出的对话框<br>（3）连线Express VI<br>（4）保存并运行VI<br><strong>3. 实验过程</strong><br>（1）添加正弦仿真信号，并对正弦信号进行配置，设置频率为100Hz<br><img src="https://img-blog.csdnimg.cn/20210107184427821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="70%"><br><img src="https://img-blog.csdnimg.cn/20210107184509313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br>（2）添加滤波器，设置截止频率为100Hz，频率低于100Hz就可以进行波形显示<br><img src="https://img-blog.csdnimg.cn/20210107184541660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="70%"><br><img src="https://img-blog.csdnimg.cn/20210107184558150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210107184936362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br>（3）将正弦信号和滤波后的信号进行合并<br><img src="https://img-blog.csdnimg.cn/20210107184836372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210107184958755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br>（4）添加图形显示控件<br><img src="https://img-blog.csdnimg.cn/20210107185407224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210107185437464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br>（5）双击生成的图形显示控件，进入前面板，运行程序<br><img src="https://img-blog.csdnimg.cn/20210107185611823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br>（6）可以尝试修改正弦信号源和滤波器的配置，观察曲线变化</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>LabView学习笔记（三）：基本控件</title>
    <url>/2021/01/09/016-LabView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p>
<hr>
<h2 id="1-数值型控件"><a href="#1-数值型控件" class="headerlink" title="1. 数值型控件"></a>1. 数值型控件</h2><ul>
<li>数值型控件可表示不同类型的数值</li>
<li>程序框图或前面板中，右键单击输入控件、显示控件或常量，从快捷菜单中选择表示法，可以改变数值型数据的表示法<img src="https://img-blog.csdnimg.cn/20210108151345661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="30%">
## 2. 布尔型控件</li>
<li>布尔型控件最关键的就是机械动作的选择。</li>
</ul>
<table>
<thead>
<tr>
<th>机械动作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>单击时转换</td>
<td>按下按钮时改变状态。保持改状态直至其他按钮按下</td>
</tr>
<tr>
<td>释放时转换</td>
<td>释放按钮时改变状态。释放其他按钮之前保持当前状态</td>
</tr>
<tr>
<td>保持转换直到释放</td>
<td>按下按钮时改变状态。松开按钮后恢复原来的状态</td>
</tr>
<tr>
<td>单击时触发</td>
<td>按下按钮时改变状态。LabView读取控件值后恢复原来的状态</td>
</tr>
<tr>
<td>释放时触发</td>
<td>释放按钮时改变状态。LabView读取控件值后返回原状态</td>
</tr>
<tr>
<td>保持触发直到释放</td>
<td>按下按钮时改变状态。松开按钮且LabView读取控件值后恢复原来的状态</td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/20210108153209510.png" width="40%"></td>
<td></td>
</tr>
</tbody></table>
<h2 id="3-字符型控件"><a href="#3-字符型控件" class="headerlink" title="3. 字符型控件"></a>3. 字符型控件</h2><ul>
<li>可以通过快捷菜单更改显示类型：正常显示、’&#39;显示、密码显示、十六进制显示</li>
<li>在LabView中字符串颜色为粉红色</li>
<li>字符串的数据/控件可以通过数值/字符串转换函数实现字符串与各种类型数值数据之间的转换，字符串数据也可以与路径、数组之间进行转换</li>
<li>字符串型控件可以通过函数面板的连接字符串以及制表符、回车/换行符将多个字符串数据转换成指定格式的字符串，用于报表的制作<img src="https://img-blog.csdnimg.cn/20210108153449908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%">
## 4. 枚举和下拉控件</li>
<li>下拉列表：右键单击下拉列表控件，并从快捷菜单中选择编辑项，或者在属性对话框中点击编辑项的选项卡，即可向控件的下拉列表中添加内容，并更改项的顺序<img src="https://img-blog.csdnimg.cn/20210108153659260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210108153723261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>枚举型控件：将枚举型控件连接至条件结构的选择器接线端时，LabView将控件中的字符串与分支条件相比较，而不是控件的数值<img src="https://img-blog.csdnimg.cn/20210108153829153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>如果数据过大时，枚举类型可以较好的显示，而下拉列表有时需要更改数据类型以实现存储较大数据。<img src="https://img-blog.csdnimg.cn/20210108154006830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"></li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>LabView学习笔记（四）：动态数据类型</title>
    <url>/2021/01/10/017-LabView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p>
<hr>
<h2 id="动态数据类型介绍"><a href="#动态数据类型介绍" class="headerlink" title="动态数据类型介绍"></a>动态数据类型介绍</h2><ol>
<li>在LabView中，动态数据类型表示为深蓝色</li>
<li>只有Express VI才能产生和接收ExpressVI （如要使用内置VI或函数处理动态数据类型，必须先进行数据类型转换，连线时一般会自动转换动态数据）</li>
<li>动态数据类型转换</li>
</ol>
<ul>
<li>从动态数据类型转换：在程序框图上放置“从动态数据转换”Express VI，配置转换的数据类型</li>
<li>转换至动态数据：在程序框图上放置“转换至动态数据”ExpressVI</li>
</ul>
<ol start="4">
<li>获取和设置动态数据</li>
</ol>
<ul>
<li>使用获取动态数据ExpressVI获取动态数据的属性</li>
<li>使用设置动态数据属性ExpressVI设置动态数据的属性，如信号名、时间标识、时间模式等</li>
</ul>
<h2 id="实验：波形显示和数据获取"><a href="#实验：波形显示和数据获取" class="headerlink" title="实验：波形显示和数据获取"></a>实验：波形显示和数据获取</h2><ol>
<li>主要目的：模拟信号输入，在波形图上显示波形，获取采样数据，采样时间和信号名称</li>
<li>实验过程<br>（1）添加并配置仿真信号<img src="https://img-blog.csdnimg.cn/2021010815504847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%" >
<img src="https://img-blog.csdnimg.cn/20210108155308782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
（2）创建图形显示控件（示波器），用来显示输出波形
<img src="https://img-blog.csdnimg.cn/20210108155405692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%">
（3）获得信号数据，并进行显示
<img src="https://img-blog.csdnimg.cn/20210108155502565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/2021010815552310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210108155603114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%">
（4）获得信号属性并显示
<img src="https://img-blog.csdnimg.cn/20210108155635301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210108155658283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="30%">
<img src="https://img-blog.csdnimg.cn/20210108155722160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%">
（5）运行程序查看结果
<img src="https://img-blog.csdnimg.cn/20210108155806130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>LabView学习笔记（五）：数据类型综合实验</title>
    <url>/2021/01/11/018-LabView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p>
<hr>
<h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><ol>
<li>输出正弦波信号，频率0-50M</li>
<li>采样率10M、50M、100M可选</li>
<li>检测信号频率</li>
<li>输出采样信号的功率谱，如果频率或采样率发生变化，重新开始平均过程</li>
</ol>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><ol>
<li>在程序框图中创建基本函数发生器，按下Ctrl+H查看即时帮助中的接口说明<img src="https://img-blog.csdnimg.cn/20210109154923188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210109155022876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%"></li>
<li>按照任务要求配置各个接口，首先在信号类型处右键，创建常量（正弦波）<img src="https://img-blog.csdnimg.cn/20210109155152824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%"></li>
<li>在频率、采样信息处右键创建输入控件<img src="https://img-blog.csdnimg.cn/20210109155241158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%"></li>
<li>添加两个波形测量的Express VI，分别是提取单频信息、FFT功率谱和PSD<img src="https://img-blog.csdnimg.cn/20210109155529693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210109155604165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>在 提取单频信息 的Express VI的<strong>检测到的功率</strong>的接口，FFT功率谱和PSD 的Express VI<strong>功率谱/PSD</strong>接口创建显示控件<img src="https://img-blog.csdnimg.cn/20210109160019340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>在FFT功率谱和PSD的Express VI的<strong>显示为DB</strong>接口创建常量并设置为<strong>True</strong><img src="https://img-blog.csdnimg.cn/20210109160140905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>在FFT功率谱和PSD的Express VI的<strong>平均参数</strong>接口创建常量并设置为<strong>RMS均方根平均方式</strong><img src="https://img-blog.csdnimg.cn/20210109160258552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210109160314783.png" width="15%"></li>
<li>因需要重新开始平均所以在<strong>重新开始平均</strong>接口处创建常量并选择为<strong>真</strong><img src="https://img-blog.csdnimg.cn/20210109160451227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>切换回前面板，将功率谱的显示方式替换为波形图，并将频率的显示方式替换为旋钮<img src="https://img-blog.csdnimg.cn/20210109160622482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210109160646834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>修改旋钮周围的刻度<img src="https://img-blog.csdnimg.cn/20210109160717411.png" width="20%">
<img src="https://img-blog.csdnimg.cn/20210109160736502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%"></li>
<li>将采样信息替换为文本下拉列表，然后右键-编辑项，修改下拉列表的菜单，并设置默认值为50M<img src="https://img-blog.csdnimg.cn/20210109160848108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210109160909209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%">
<img src="https://img-blog.csdnimg.cn/20210109160942715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>修改检测到的频率的显示格式<img src="https://img-blog.csdnimg.cn/20210109161028713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%"></li>
<li>进行简单外观修饰后运行程序<img src="https://img-blog.csdnimg.cn/20210109161106102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>LabView学习笔记（六）：while循环与for循环</title>
    <url>/2021/01/12/019-LabView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9Awhile%E5%BE%AA%E7%8E%AF%E4%B8%8Efor%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p>
<hr>
<h2 id="while循环（图片循环播放程序）"><a href="#while循环（图片循环播放程序）" class="headerlink" title="while循环（图片循环播放程序）"></a>while循环（图片循环播放程序）</h2><p>实验：完成三张图片的循环放映</p>
<ol>
<li>插入一个图片下拉列表，并导入n张图片<img src="https://img-blog.csdnimg.cn/20210109161918931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210109161957452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="30%">
<img src="https://img-blog.csdnimg.cn/20210109162022893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="20%">
<img src="https://img-blog.csdnimg.cn/20210109162103514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%"></li>
<li>打开程序框图，利用While循环实现图片的循环播放，首先将图片下拉列表转换为显示控件<img src="https://img-blog.csdnimg.cn/20210109162221504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="30%"></li>
<li>创建一个While循环<img src="https://img-blog.csdnimg.cn/20210109162258677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%"></li>
<li>因下拉图片列表中各个图片的值为0，1，2……n，利用循环次数与n的余数作为图片的选择依据（n为图片个数），插入数值中的商与余树控件并连线<img src="https://img-blog.csdnimg.cn/20210109162517679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%">
在我的程序中图片数是3所以除数为3</li>
<li>创建停止条件<img src="https://img-blog.csdnimg.cn/20210109162620541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>回到前面板中添加一个旋钮，用于调整图片切换速度<img src="https://img-blog.csdnimg.cn/20210109162712203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>在while循环中插入一个等待时间，等待时间的输入端以毫秒作为单位，同时考虑旋钮越大图片切换速度应该越快，因此将旋钮的数值取倒数再乘1000作为while循环的等待时间<img src="https://img-blog.csdnimg.cn/20210109162913137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210109162933676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>运行程序，即可观察到图片循环播放，拖动旋钮可以看到图片切换速度也会随之变化。</li>
</ol>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ol>
<li>for循环的创建</li>
</ol>
<ul>
<li>创建for循环的方法和while循环类似</li>
<li>可以右键单击while循环的边框，在右键菜单中将while循环转换为for循环</li>
</ul>
<ol start="2">
<li>for循环的接线端</li>
</ol>
<ul>
<li>N为循环次数，循环次数必须指定为非负整数（如果将双精度浮点数值连接至总线接线端，LabView将把较长的数值转换为32位有符号整数）</li>
<li>为了避免强制转换，以增强程序性能，选择匹配的数据类型，或者通过编程进行数据类型的转换</li>
</ul>
<ol start="3">
<li>与while循环的区别</li>
</ol>
<ul>
<li>while循环至少执行一次，for循环可以执行0次</li>
<li>while循环自动输出最后一次执行的值，for循环自动输出一个数组</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>LabView学习笔记（七）：变量与移位寄存器</title>
    <url>/2021/01/13/020-LabView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E4%B8%8E%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p>
<hr>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol>
<li>变量的作用：在并行循环间传递数据</li>
<li>变量类型</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>局部变量</td>
<td>将数据存储在前面板输入控件和显示控件中</td>
</tr>
<tr>
<td>全局变量</td>
<td>将数据存储在多个VI可访问的特殊数据库中</td>
</tr>
<tr>
<td>功能全局变量</td>
<td>将数据存储在While循环移位寄存器中</td>
</tr>
<tr>
<td>共享变量</td>
<td>在通过网络连接的分布式任务间传递数据</td>
</tr>
<tr>
<td>3. 布尔控件的局部变量</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>具有关联局部变量的布尔控件必须使用开关机械动作</li>
<li>布尔触发动作与局部变量不兼容<h2 id="移位寄存器"><a href="#移位寄存器" class="headerlink" title="移位寄存器"></a>移位寄存器</h2></li>
</ul>
<ol>
<li>应用：移位寄存器可以将前一循环产生的数据传递至下一循环</li>
<li>添加方法：右键单击循环边框，添加移位寄存器</li>
<li>右侧的移位寄存器存储每次循环结束后的数据，左侧的移位寄存器为下一循环提供所存储的数据</li>
<li>移位寄存器的初始化</li>
</ol>
<table>
<thead>
<tr>
<th>初始化</th>
<th>程序执行结果</th>
</tr>
</thead>
<tbody><tr>
<td>初始化的移位寄存器</td>
<td>无论程序运行多少次结果都一样</td>
</tr>
<tr>
<td>未初始化的移位寄存器</td>
<td>输入为上一次程序运行的结果，因此输出结果会随着程序运行次数而改变</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>LabView学习笔记（八）：属性节点</title>
    <url>/2021/01/14/021-LabView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%B1%9E%E6%80%A7%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p>
<hr>
<h2 id="一、属性节点的介绍"><a href="#一、属性节点的介绍" class="headerlink" title="一、属性节点的介绍"></a>一、属性节点的介绍</h2><ol>
<li>属性节点：可用于访问对象的属性。当某些应用中可能需要通过编程改变前面板对象外观，以响应特定输入时，通过编辑属性节点进行设置。</li>
<li>创建方法：在程序框图的控件上右键，创建属性节点。需要设置多个属性时可以在边框上下拖动添加属性，属性节点按照由上而下的顺序执行。</li>
<li>严格属性节点：右键控件创建属性节点的方法为隐含属性节点；通过控件引用创建严格属性节点（右键创建属性节点，控件右键创建引用，二者相连即可创建严格属性节点）。在多个VI涉及同一个控件的属性时，会使用严格属性节点传递。</li>
</ol>
<h2 id="二、实验"><a href="#二、实验" class="headerlink" title="二、实验"></a>二、实验</h2><ol>
<li>任务要求：通过滑动杆对波形图任意一段进行显示。<img src="https://img-blog.csdnimg.cn/20210111155755610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>实现过程：<br>（1）用for循环产生1000个随机数，通过波形图将1000个点显示出来<img src="https://img-blog.csdnimg.cn/20210111154508679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
（2）在前面板添加一个水平滑动杆作为拖动的滚动条。
<img src="https://img-blog.csdnimg.cn/20210111154630269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%">
（3）因需要实时调整波形图，所以用一个while循环，在while循环中创建属性节点（波形图的最大值和最小值），并将其转换为写入。将滑动杆的输出连接至波形图最小值，滑动杆的输出+100连接至波形图最大值。
<img src="https://img-blog.csdnimg.cn/20210111154832410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210111155120224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%">
（4）设置滑动杆的属性（最大值和最小值）为0和900，初始值为0。
<img src="https://img-blog.csdnimg.cn/20210111155408823.png" width="20%">
（5）连接错误簇确定程序执行顺序。
<img src="https://img-blog.csdnimg.cn/20210111155608532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
（6）程序设计完成</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>LabView学习笔记（九）：数组与簇</title>
    <url>/2021/01/15/022-LabView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%8E%E7%B0%87/</url>
    <content><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p>
<hr>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol>
<li>数组：处理一系列相似的数据和执行重复计算操作时，可考虑使用数组。数据将相同类型的数据元素归为一组。</li>
<li>创建方法：在前面板放置一个数组的外框，拖放一个数据对象或元素至外框内即可创建数组。</li>
<li>数组组成：<br>（1） 元素：组成数组的数据<br>（2）b. 维度：数组的长度、高度、深度 （数组可以是一维或多维的，内存允许的情况下，每一维度可有多达(2^31)-1个元素）</li>
<li>数组初始化<br>（1）直接在前面板输入元素进行初始化。<br>（2）利用循环，如for循环索引输出的是一个数组<br>（3）c. 数组的初始化函数<br>（注：未初始化的元素只具有维数，不包含任何元素）</li>
<li>数组函数：包括数组大小、索引数组、创建数组、数组最大值最小值、排序、拆分数组等操作均可以通过数组函数实现。<br><img src="https://img-blog.csdnimg.cn/20210112153519739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="簇"><a href="#簇" class="headerlink" title="簇"></a>簇</h3></li>
<li>簇与数组：簇将不同类型数据元素归为一组，簇不同于数组的地方在于簇的大小是固定的，簇可以包含不同的数据类型，数组仅可包含一种数据类型。</li>
<li>簇的创建方法<br>（1）在前面板上放置一个簇的外框<br>（2）推拽数据对象或元素至簇的外框内，拖拽对象可分为数值、布尔值、字符串、路径、引用句柄、数组、簇输入控件和簇显示控件</li>
<li>簇的顺序：簇元素的逻辑顺序与其在簇内的位置无关，右键单击簇外框，从快捷菜单中选择重新排序簇中控件<img src="https://img-blog.csdnimg.cn/20210112154216684.png" width="30%"></li>
<li>簇函数：簇函数中最重要的就是构造打包生成簇的捆绑函数和从簇中解包提取簇中元素的接触捆绑函数<img src="https://img-blog.csdnimg.cn/20210112154316847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>错误簇：<br>（1）可以控制控件执行的先后顺序<br>（2）也可以通过错误簇控制循环的终止</li>
<li>波形簇的簇元素<br>（1）t0：时间戳<br>（2）dt：Y数据的时间间隔<br>（3）Y：随时间变化的一组数据</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>LabView学习笔记（十）：条件结构</title>
    <url>/2021/01/16/023-LabView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p>
<hr>
<h2 id="条件结构"><a href="#条件结构" class="headerlink" title="条件结构"></a>条件结构</h2><ol>
<li>条件结构类似C语言中的if…else…和switch结构，主要用于分支选择程序逻辑。</li>
<li>条件结构包括两个及以上子程序框图或分支。每次仅执行一个条件分支</li>
<li>右键单击条件结构边框添加、复制、删除、重排及选择默认分支。<h2 id="输入和输出隧道"><a href="#输入和输出隧道" class="headerlink" title="输入和输出隧道"></a>输入和输出隧道</h2></li>
<li>可创建多个输入/输出隧道</li>
<li>输入数据可供全部条件分支使用</li>
<li>必须为每个条件分支定义各自的输出隧道</li>
<li>默认分支选择器是布尔型的，当为真的时候，执行真框图内的内容，当为假的时候执行假框图内的内容。同时分支选择器也可以是数组、枚举等控件输入。</li>
</ol>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><strong>任务要求</strong></p>
<ol>
<li>产生频率、波形类型均可设置的信号</li>
<li>已足够的采样率产生和显示波形，并生成采样率可调的波形，并进行比较</li>
<li>显示波形和信号频谱</li>
</ol>
<p><strong>实现过程</strong></p>
<ol>
<li>信号的产生和显示是一个连续的过程，所以考虑使用循环。</li>
<li>由于信号的波形类型是可以设置的，所以在前面板中插入一个枚举型变量用于进行设置，对于枚举型变量采用不同的值，要产生不同的波形，因此使用条件结构进行判断。<img src="https://img-blog.csdnimg.cn/20210114140551282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/2021011414062461.png" width="10%"></li>
<li>首先对第一种波形（正弦波）进行设置，程序框图中添加一个正弦波形生成控件。<br>（1）设置波形：在前面板插入一个旋钮用于调节频率，回到程序框图将其连到正弦波形生成控件的频率接口上。<img src="https://img-blog.csdnimg.cn/20210114140824878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210114140826953.png" width="15%">
（2）设置采样信息：在对应接口处添加常量，增大采样率，产生采样率足够大的正弦信号。
<img src="https://img-blog.csdnimg.cn/20210114140930231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>产生采样信号 添加一个正弦波形生成控件用于产生采样信号，在前面板添加一个文本下拉列表控件用于设置采样率（数据类型为DBL，采样率如下图），利用捆绑，将采样率和采样点数捆绑后传递给正弦波形生成控件的采样信息接口。其它接口与上面正弦波形的部分一致。<img src="https://img-blog.csdnimg.cn/20210114141006713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%">
<img src="https://img-blog.csdnimg.cn/20210114141012688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>显示信号：因涉及到两个信号的显示，因此使用创建数组，将两个信号合成为数组传递到波形图中。<img src="https://img-blog.csdnimg.cn/20210114141103436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>信号测量：添加一个FFT功率谱和PSD（在信号处理-波形测量中）。将采样信号连接至时间信号接口，平均参数接口创建一个常量并选择RMS平均方式。然后在前面板添加一个波形图控件用于显示频谱图。<img src="https://img-blog.csdnimg.cn/20210114141151598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>配置其他波形：先在条件结构中删除方波分支，然后选择复制正弦波分支，并将条件结构内的正弦波形生成控件替换为方波生成控件。（其他波形也是类似的操作流程）<img src="https://img-blog.csdnimg.cn/20210114141236718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210114141245973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210114141254503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>添加停止按钮，修改波形图的横坐标显示范围，最后修饰一下界面，程序就成功完成了<img src="https://img-blog.csdnimg.cn/20210114141355605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%">
采样率足够高时，波形信号与采样率几乎重合。
<img src="https://img-blog.csdnimg.cn/20210114141446991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%">
采样率较低时，会出现明显的失真
<img src="https://img-blog.csdnimg.cn/20210114141518519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派系统的安装、初步配置与远程访问</title>
    <url>/2021/01/17/024-%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E5%88%9D%E6%AD%A5%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h5 id="一、准备TF卡"><a href="#一、准备TF卡" class="headerlink" title="一、准备TF卡"></a>一、准备TF卡</h5><ol>
<li>将TF卡通过读卡器连接到电脑上。</li>
<li>如果原来使用过的话，用Diskgenius将TF卡内所有分区都删除，新建一个分区为FAT32格式，然后格式化当前分区。<h5 id="二、镜像的下载和写入"><a href="#二、镜像的下载和写入" class="headerlink" title="二、镜像的下载和写入"></a>二、镜像的下载和写入</h5></li>
<li>进入RaspberryPi官网下载最新的<a href="https://www.raspberrypi.org/software/operating-systems/#raspberry-pi-os-32-bit">系统镜像</a>。这里有三种版本，轻量版、标准版和完全版，大家可以根据需要下载，一般标准版就可以了。<img src="https://img-blog.csdnimg.cn/20210103161604252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
如果大家觉得下载太慢，也可以使用一些方法从百度网盘下载，链接放在下面了。
链接：https://pan.baidu.com/s/1FhSZkqXggTO-spSZxLwLcQ 
提取码：qhcm </li>
<li>使用Win32Diskimager安装镜像。镜像安装完成后可能会弹出格式化的对话框，一定不要格式化，否则相当于前功尽弃。<br>（ps：使用过程中可能会报错，因为可能打开了TF卡的某个文件夹，不用理会直接确认即可。）<img src="https://img-blog.csdnimg.cn/20210103161526535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="40%"></li>
<li>打开SSH服务：在制作好的boot分区内，新建一个文件名为ssh，无任何后缀的文件。（可以在文件资源管理器上方点击查看选项卡，选择显示扩展名）<img src="https://img-blog.csdnimg.cn/20210103162427618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
##### 三、IP地址的确定和访问
以下操作需要【屏幕+外接键盘】或者【一根网线】，二者选一个即可。使用前者的在需要的时候将屏幕和键盘连接至树莓派即可，使用后者的需要将路由器或者电脑通过网线连接至树莓派。</li>
</ol>
<p><strong>使用网线的：</strong></p>
<ol>
<li><p>将之前制作好的TF卡插入树莓派中，为树莓派连接电源（电源可以是2.5mm圆头电源线，也可以是microUSB或者TypeC接口的线，但要求充电头能够达到5V 3A，最低5V 2.5A）</p>
</li>
<li><p>开机，等待一段时间后进入系统，如果有显示器可以看到进入系统的界面，没有显示器的直接进行下一步即可。</p>
</li>
<li><p>使用Advanced scanner搜索此局域网内的树莓派的IP地址。</p>
<img src="https://img-blog.csdnimg.cn/20210103163155625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li><p>使用PuTTy软件，默认SSH连接方式，输入IP地址，进入系统后如果出现login，则说明连接成功，用户名为pi，密码为raspberry，则可以成功进入系统。如果PuTTy连接超时，则说明IP地址有问题或者树莓派没有连接到网络。</p>
<img src="https://img-blog.csdnimg.cn/20210103163546527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li><p>设置wifi<br> (1)命令行执行</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure>
<p>  (2)内容改为</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line">network=&#123;</span><br><span class="line">ssid=<span class="string">&quot;这里写wifi名称&quot;</span></span><br><span class="line">psk=<span class="string">&quot;这里写密码&quot;</span></span><br><span class="line">key_mgmt=WPA-PSK</span><br><span class="line">priority=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <img src="https://img-blog.csdnimg.cn/20210103164816336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">

<p> 其中priority是连接优先级，数字越大，优先级越高。<br> (3)保存后reboot重启，没有问题的话就可以连接上WiFi了，如果出现no wireless interfaces found，那么一定要检查上面这个文件/etc/wpa_supplicant/wpa_supplicant.conf的内容，key_mgmt和priority两行是可以不写的，所有拼写都不能错。（本人就曾因为把ssid打成ssod导致连接不上wifi排查了好久）</p>
</li>
<li><p>查看IP地址，使用Advanced scanner搜索，或者用更简单的方法，在命令行里输入<code>raspberrypi.local</code>即可查看树莓派的地址，再使用PuTTy访问即可。</p>
</li>
</ol>
<p><strong>使用外接屏幕键盘数表的</strong>（这些设备只使用一次就够了）</p>
<ol>
<li>将之前制作好的TF卡插入树莓派中，为树莓派连接电源（电源可以是2.5mm圆头电源线，也可以是microUSB或者TypeC接口的线，但要求充电头能够达到5V 3A，最低5V 2.5A）</li>
<li>开机，等待一段时间后进入系统，如果有显示器可以看到进入系统的界面，按照提示进行初始化设置，提示需要大量更新的时候跳过即可，后续换源后再手动更新。</li>
</ol>
<h5 id="四、数据源的更新和配置"><a href="#四、数据源的更新和配置" class="headerlink" title="四、数据源的更新和配置"></a>四、数据源的更新和配置</h5><p>如果使用默认的源，下载速度可能会很慢，因此推荐换成国内的源，这里以清华源为例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">打开sources.list文件</span><br><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">注释里面的所有内容，输入以下地址</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi</span><br><span class="line">（ctrl+o回车保存，ctrl+x退出编辑器）</span><br><span class="line"></span><br><span class="line">打开raspi.list文件</span><br><span class="line">sudo nano /etc/apt/sources.list.d/raspi.list</span><br><span class="line"></span><br><span class="line">注释里面的所有内容，输入以下地址</span><br><span class="line">deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br><span class="line">deb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br><span class="line"></span><br><span class="line">更新源</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<h5 id="五、windowns远程访问的实现"><a href="#五、windowns远程访问的实现" class="headerlink" title="五、windowns远程访问的实现"></a>五、windowns远程访问的实现</h5><ol>
<li>在PuTTy命令行窗口输入<code>sudo raspi-config</code>，选中进入Interfacing Options，选中VNC选项，回车，选择Enable，即可打开VNC。</li>
<li>下载安装<a href="https://www.realvnc.com/en/connect/download/viewer/windows/">VNC软件</a><img src="https://img-blog.csdnimg.cn/20210103165919163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
注意：如果出现cannot currently show the desktop，则需要在刚才的位置修改分辨率，在PuTTy中输入`sudo raspi-config`，选中进入Advanced Options-Resolutions，选择除了第一个default的任意一个，保存重启后，再打开VNC即可。</li>
<li>即可进入图形界面。<br>至此，初步完成了系统的安装。</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>【树莓派搭建个人网站】环境配置</title>
    <url>/2021/01/18/025-%E3%80%90%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E3%80%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="一、搭建LAMP服务器"><a href="#一、搭建LAMP服务器" class="headerlink" title="一、搭建LAMP服务器"></a>一、搭建LAMP服务器</h2><p><strong>即Linux+Apache+MySQL+PHP</strong></p>
<p><strong>1. 安装apache</strong><br>打开控制台，输入命令，确保软件安装是最新的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure>
<p>安装apache</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install apache2</span><br></pre></td></tr></table></figure>
<p>安装完成后给apache文件赋予权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chown -R pi:www-data /var/www/html/</span><br><span class="line">sudo chmod -R 770 /var/www/html/</span><br></pre></td></tr></table></figure>
<p>在浏览器输入<code>127.0.0.1</code>可以看到apache的页面，说明apache已经顺利安装成功。<br><img src="https://img-blog.csdnimg.cn/20210115160502183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br><strong>2. 安装Nginx</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure>
<p><strong>2. 安装php及部分插件</strong><br>在控制台输入以下命令安装php7.3（2021年1月为7.3版本，安装最新版即可）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php7.0</span><br></pre></td></tr></table></figure>
<p>安装插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php7.0-fpm</span><br><span class="line">sudo apt-get install php7.0-mysql</span><br><span class="line">sudo apt-get install php7.0-common</span><br></pre></td></tr></table></figure>
<p><strong>3. 安装MySQL</strong><br>由于MySQL闭源了，我们安装mariadb.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mariadb-server</span><br><span class="line">sudo apt-get install mariadb-client</span><br></pre></td></tr></table></figure>
<p><strong>4. 配置Nginx</strong><br>在控制台输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure>
<p>找到其中的location，将location修改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">index index.html index.htm index.php default.html default.htm default.php</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~\.php<span class="variable">$&#123;</span></span><br><span class="line"><span class="variable">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>5. 重新启动服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/nginx restart</span><br><span class="line">sudo /etc/init.d/php7.3-fpm restart</span><br><span class="line">sudo service mysql restart</span><br><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure>
<p><strong>6. 测试Nginx与PHP</strong><br>所有关于网站的东西都在var内，对其授权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chmod -R 777 /var</span><br><span class="line">sudo chmod -R 777 /var/www</span><br><span class="line">sudo chmod -R 777 /var/www/html</span><br></pre></td></tr></table></figure>
<p>在/var/www/html中新建index.php文件，并输入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>PHP Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		&lt;?php echo &#x27;<span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#x27;; ?&gt;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后删除/var/www/html文件夹内的index.html和index.nginx-debian.html两个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /var/www/html/index.html</span><br><span class="line">sudo rm -rf /var/www/html/index.nginx-debian.html</span><br></pre></td></tr></table></figure>
<p>完成后，打开浏览器，输入树莓派的ip地址，或者localhost，即可看到网页Helloworld，说明以上步骤顺利完成了。<br><img src="https://img-blog.csdnimg.cn/20210115162214961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width=""></p>
<h2 id="创建数据库用户"><a href="#创建数据库用户" class="headerlink" title="创建数据库用户"></a>创建数据库用户</h2><p>这一步需要安装PhpMyAdmin，并使用SQL语句添加mariaDB数据库用户。PHPMYADMIN是一个以PHP为基础，以Web-Base防止架构运行在网站主机上的MySQL的数据库管理工具，让管理者可以直接使用Web接口管理MySQL数据库。<br><strong>1.安装phpmyadmin</strong><br>使用以下命令进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install phpmyadmin</span><br></pre></td></tr></table></figure>
<p>安装过程中会遇到一些选项，按下图设置即可<br><img src="https://img-blog.csdnimg.cn/2021011516274890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br><img src="https://img-blog.csdnimg.cn/20210115162818344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br>这里的密码要记住，一会登录phpmyadmin时要用到。<br><img src="https://img-blog.csdnimg.cn/202101151628373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="50%"><br><strong>2. 设置PHPMYADMIN软连接</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/share/phpmyadmin /var/www/html</span><br></pre></td></tr></table></figure>
<p><strong>3. 登录phpmyadmin</strong><br>在浏览器输入<code>localhost/phpmyadmin</code>进入登陆界面，初始用户名为<code>phpmyadmin</code>初始密码为之前安装过程中设置的密码。<br><img src="https://img-blog.csdnimg.cn/2021011516334035.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br><strong>4. 使用SQL语句添加mariaDB数据库用户</strong><br>输入以下命令进入mariadb环境，这里没有密码，直接回车或者随便输入即可进入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>在mariadb中添加用户并赋予权限<br>（1）添加用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE USER <span class="string">&#x27;名字&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>（2）赋予用户权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to 名字@localhost;</span><br></pre></td></tr></table></figure>
<p>（3）刷新权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>（4）退出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure>
<p>再次打开浏览器进入phpmyadmin中（<code>localhost/phpmyadmin</code>），使用刚刚创建的用户登录。<br><img src="https://img-blog.csdnimg.cn/20210115164056922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210115164108861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br>可以看到我们有了很高的权限（甚至可以删库[doge]）<br>到此为止就基本完成了网站环境的搭建，之后就是使用wordpress等工具搭建个人网站了。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>网站搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>【树莓派搭建个人网站】花生壳内网穿透</title>
    <url>/2021/01/20/027-%E3%80%90%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E3%80%91%E8%8A%B1%E7%94%9F%E5%A3%B3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p>如果wordpress已经安装设置完成后，浏览器输入<code>localhost</code>或者 <code>树莓派的ip地址</code>，就可以访问到网站了，但是外网（不在一个路由器内）仍然无法访问，而内网穿透的目的就是使外网的计算机能够访问你的网站。为了减少配置的难度和复杂度，我使用了花生壳进行配置。<br>（虽然说是免费内网穿透，但是过程中是花费了6元）</p>
<h4 id="1-安装花生壳"><a href="#1-安装花生壳" class="headerlink" title="1. 安装花生壳"></a>1. 安装花生壳</h4><ol>
<li>进入<a href="https://hsk.oray.com/download/">官网下载页面</a>，下载<strong>树莓派32位系统</strong>。</li>
<li>通过cd命令进入对应下载目录，输入下面的命令进行安装：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -i phtunnel_5_0_rapi_armhf.deb</span><br></pre></td></tr></table></figure></li>
<li>安装成功后，将显示此树莓派的SN码、默认密码以及远程管理地址。记住这里的SN码。<img src="https://img-blog.csdnimg.cn/20210119150828190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
#### 2. 配置花生壳</li>
<li>浏览器输入远程管理地址<a href="b.oray.com">b.oray.com</a>进入花生壳远程管理页面，输入安装花生壳时生成的SN码及默认密码admin进入。</li>
<li>首次登录，需要通过扫码或者密码进行激活操作，两种方法任选一种。</li>
<li>激活成功后，即可免费开通内网穿透。<h4 id="3-配置内网穿透"><a href="#3-配置内网穿透" class="headerlink" title="3. 配置内网穿透"></a>3. 配置内网穿透</h4></li>
<li>点击控制台左侧的花生壳-账号列表，点击自己的账号名，即可进入内网穿透的配置页面</li>
<li>添加映射，映射类型选择http，这里就需要支付6元了。</li>
<li>其它配置按下图配置即可，域名只能选择固定的域名，外网端口只能选择动态端口，内网主机为树莓派的ip地址，端口一般是80。<img src="https://img-blog.csdnimg.cn/20210119152257306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
</ol>
<p>这样就已经实现外网访问自己用wordpress搭建的个人网站了。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>网站搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>【树莓派搭建个人网站】WordPress安装</title>
    <url>/2021/01/19/026-%E3%80%90%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E3%80%91WordPress%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一、下载wordpress"><a href="#一、下载wordpress" class="headerlink" title="一、下载wordpress"></a>一、下载wordpress</h2><p>在<a href="https://cn.wordpress.org/download/">wordpress官网</a>下载安装包，解压后把worpress文件夹内容放在html文件夹内。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wget https://cn.wordpress.org/latest-zh_CN.tar.gz</span><br><span class="line">tar -xzvf latest-zh_CN.tar.gz</span><br><span class="line">mv wordpress/* /var/www/html/</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210119141212782.png" width="60%">

<h2 id="二、在phpmyadmin内新建一个数据库"><a href="#二、在phpmyadmin内新建一个数据库" class="headerlink" title="二、在phpmyadmin内新建一个数据库"></a>二、在phpmyadmin内新建一个数据库</h2><ol>
<li>浏览器输入localhost/phpmyadmin进入phpmyadmin，输入自己的phpmyadmin用户名和密码</li>
<li>点击数据库栏，新建数据库，输入一个数据库的名字，点击创建即可，暂时不需要数据表<img src="https://img-blog.csdnimg.cn/20210119141601975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>在地址栏输入localhost，即可进入wordpress，按下图进行wordpress的配置<br>(我是在wordpress官网下载的安装包，没有下载中文官网的，所以显示英文，不过内容一样，按网页提示填写网站的信息即可)。<img src="https://img-blog.csdnimg.cn/20210119141658922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210119141753914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>设置完成后，接下来就可以用刚刚设置的用户名和密码进行wordpress的登陆了<img src="https://img-blog.csdnimg.cn/20210119142146907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/2021011914215390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></li>
</ol>
<ul>
<li>ps.如果要从英文修改成中文，就在如果需要修改中文就在<a href="https://cn.wordpress.org/download/">https://cn.wordpress.org/download/</a>下载中文官网的安装包，解压后将<code>wordpress/wp_content</code>内的language文件夹复制到<code>/var/www/html/wpcontent</code>内即可</li>
</ul>
<h2 id="三、wordpress修改网站主题"><a href="#三、wordpress修改网站主题" class="headerlink" title="三、wordpress修改网站主题"></a>三、wordpress修改网站主题</h2><p>点击左上角的网站title即可查看当前网站<br><img src="https://img-blog.csdnimg.cn/20210119142707113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br>如果想更改主题，可以点击左侧W标志，进入外观-主题菜单栏，选择主题安装。<br><strong>主机名填写树莓派的ip地址，用户名为pi，密码为raspberry</strong>，若出现下列要求FTP的对话框<br><img src="https://img-blog.csdnimg.cn/20210119154653738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><br>则在命令栏输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br><span class="line">sudo passwd root	<span class="comment">#自己设置一个root账户密码</span></span><br><span class="line">sudo passwd --unlock root</span><br><span class="line">su	<span class="comment">#这里会提示输入刚才设置的密码</span></span><br><span class="line">vi /etc/vsftpd.conf</span><br><span class="line"><span class="comment">#去掉write_enable=YES前面的#</span></span><br><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure>
<p>此时再重新安装主题即可成功安装。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>网站搭建</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>wordpress后台加载慢的解决方法</title>
    <url>/2021/01/21/029-wordpress%E5%90%8E%E5%8F%B0%E5%8A%A0%E8%BD%BD%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>进入后台/在后台操作时，会发现页面加载很慢，原因之一是wordpress使用了google字体<br>解决方法：安装disable google fonts插件（2021.1亲测有效）<br>（查资料还有一个原因是用户头像无法正常加载，但是这个在最新版的wordpress中已经解决了）</p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>网站</category>
      </categories>
      <tags>
        <tag>bug解决</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>wordpress上传文件报错的解决方法（413 Request Entity Too Large、超过upload_max_filesize文件中定义的php.ini值）</title>
    <url>/2021/01/21/028-wordpress%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%88413%20Request%20Entity%20Too%20Large%E3%80%81%E8%B6%85%E8%BF%87upload_max_filesize%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84php.ini%E5%80%BC%EF%BC%89/</url>
    <content><![CDATA[<h1 id="报错：413-Request-Entity-Too-Large"><a href="#报错：413-Request-Entity-Too-Large" class="headerlink" title="报错：413 Request Entity Too Large"></a>报错：413 Request Entity Too Large</h1><p>问题nginx是限制上传大小，解决方法如下:</p>
<ol>
<li><p>打开nginx配置文件 nginx.conf, 路径一般是：/etc/nginx/nginx.conf。</p>
</li>
<li><p>在http{}段中加入 client_max_body_size 64m; 64m为允许最大上传的大小。</p>
</li>
<li><p>保存后重启nginx，service nginx restart</p>
</li>
</ol>
<h1 id="报错：上传的文件尺寸超过upload-max-filesize文件中定义的php-ini值"><a href="#报错：上传的文件尺寸超过upload-max-filesize文件中定义的php-ini值" class="headerlink" title="报错：上传的文件尺寸超过upload_max_filesize文件中定义的php.ini值"></a>报错：上传的文件尺寸超过upload_max_filesize文件中定义的php.ini值</h1><p>解决方法：修改/etc/php/7.3/apache2/php.ini文件中的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">post_max_size = 64M</span><br><span class="line">upload_max_filesize = 64M</span><br></pre></td></tr></table></figure>
<p>（这两条都在比较靠后的位置，不太好找）<br><img src="https://img-blog.csdnimg.cn/20210118095103404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"></p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>网站</category>
      </categories>
      <tags>
        <tag>bug解决</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>WordPress学习笔记（一）文章操作</title>
    <url>/2021/01/22/030-WordPress%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E7%AB%A0%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><h5 id="1-网站的内容"><a href="#1-网站的内容" class="headerlink" title="1. 网站的内容"></a>1. 网站的内容</h5><p>对于一个网站来说，内容是最重要的一部分，用户之所以访问你的网站，也是因为你的内容。在WordPress中，内容主要分成两个部分：文章和页面。</p>
<ul>
<li>文章：用于发布网站的主要内容（如博客类网站，文章处发布博文）</li>
<li>页面：用于发布网站的其他内容（如博客类网站，页面处发布博主/网站信息）<img src="https://img-blog.csdnimg.cn/20210120095736266.png" width="20%">
##### 2. 网站的规划
（1）划分出网站的主要内容和其他内容
（2）对主要内容进行分门别类，划分出分类目录
（3）不需要事先划分标签
>**分类目录**：对文章按内容进行分类
>**标签**：可以理解为是一种标记，通过给文章添加一个标记，如果需要查看带有某个标记的文章的时候，wordpress就能快速筛选出来。</li>
</ul>
<img src="https://img-blog.csdnimg.cn/20210120100513357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<h2 id="二、文章"><a href="#二、文章" class="headerlink" title="二、文章"></a>二、文章</h2><ul>
<li>右边可以看到文章的发布信息、状态、分类目录、标签、特色图片等信息<img src="https://img-blog.csdnimg.cn/20210120101214344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="30%"></li>
<li>点击右上角显示选项可以看到更多信息，这里可以先把所有复选框都选上，后面一个一个看他们的作用。（我们的选项可能不一样，这是因为安装的插件不同导致的，这个不用在意）<br><img src="https://img-blog.csdnimg.cn/202101201018334.png
?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
</ul>
<ol>
<li><strong>标题</strong>：从上到下，第一个就是文章内容的标题，这里就不多说。</li>
<li><strong>添加媒体</strong>：可以上传图片等文件，插入进文章中光标所在位置</li>
<li><strong>文章摘要</strong>：在文章内容下面，可以看到文章摘要的填写框，文章摘要就是文章主要内容的概述，作用为在网站的文章列表中显示摘要，让用户快速的了解文章的主要内容，如果用户感兴趣的话可以进一步查看内容。</li>
<li><strong>发送Trackback</strong>：如果应用或借鉴了其他人的文章，可以在此处填写ulr通知对方，这个功能目前很少使用。</li>
<li><strong>自定义栏目</strong>：在正文内无法添加，需要添加更多的内容，可以在自定义栏目中实现。</li>
<li><strong>讨论</strong>：允许评论勾选则允许评论，不勾选则不允许用户评论</li>
<li><strong>评论</strong>：可以添加，或者管理评论</li>
<li><strong>别名</strong>：修改链接网址，使网址更符合搜索引擎的索引要求</li>
<li><strong>标签</strong>：可以给文章打上标记，将来如果想查看文章，只需要使用标签即可。</li>
<li><strong>特色图像</strong>：相当于文章的缩略图</li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>网站</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>WordPress学习笔记（二）插件安装</title>
    <url>/2021/01/24/031-WordPress%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>插件可以实现为wordpress站点增加、修改、删除功能。<br>WordPress有许多安装插件的安装方法，可以在线安装，可以手动上传插件包，也可以直接配置文件视线插件的安装。<br><img src="https://img-blog.csdnimg.cn/20210119153133414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" width="60%"></p>
<ol>
<li>在线安装插件，可以在wordpress的特色、热门、推荐菜单中寻找插件，也可以搜索插件。找到合适的插件后点击安装即可。<img src="https://img-blog.csdnimg.cn/20210119153246819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" width="60%"></li>
<li>手动安装插件：当在线安装插件失败或者需要安装wordpress插件库中没有的插件时，从对应网站下载插件包，点击上传插件，选择手动下载下来的插件包即可。<img src="https://img-blog.csdnimg.cn/20210119153405170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" width="60%"></li>
<li>解压安装插件：如果手动安装插件仍然出错而且无法解决时，可以将下载的zip压缩包解压，将整个文件夹放到wp-content/plugins/文件夹内</li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>网站</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>WordPress学习笔记（三）其他功能</title>
    <url>/2021/01/24/032-WordPress%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="一、媒体库"><a href="#一、媒体库" class="headerlink" title="一、媒体库"></a>一、媒体库</h2><p>媒体库是主要用来管理，你使用wordpress上传的附件的，比如图片、视频等其他文件。 点击左上角可以切换视图（列表/缩略图）</p>
<h4 id="媒体文件的管理"><a href="#媒体文件的管理" class="headerlink" title="媒体文件的管理"></a>媒体文件的管理</h4><ol>
<li>编辑：可以修改图片的的标题，说明文字，替代文本。替代文本是当图片没有办法正常显示的时候，会用文本代替图片。</li>
<li>永久删除：在媒体库中删除媒体，已经在文章中添加过的不受影响</li>
<li>查看：以网页的形式查看图片<img src="https://img-blog.csdnimg.cn/20210122101633801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
#### 媒体文件添加</li>
<li>在此处可以上传到上传文件最大允许尺寸为2M</li>
<li>常用的图片格式、文档格式、压缩格式都可以上传。可以利用这里上传文件供用户下载。<img src="https://img-blog.csdnimg.cn/20210122101809159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
</ol>
<h2 id="二、评论管理"><a href="#二、评论管理" class="headerlink" title="二、评论管理"></a>二、评论管理</h2><ol>
<li>列表从左到右依次是：评论的用户，评论内容，用户评论的文章，评论时间。</li>
<li>在评论内容处可以管理评论，具体操作有<br>（1）驳回/批准：wordpress默认设置用户发表评论，批准后才会在网页显示<br>（2）回复：就是回复用户的评论<br>（3）编辑：可以修改用户的评论<br>（4）垃圾评论和移至回收站操作后，评论都不会在网页中显示。<img src="https://img-blog.csdnimg.cn/20210122102236146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
</ol>
<h2 id="三、用户管理"><a href="#三、用户管理" class="headerlink" title="三、用户管理"></a>三、用户管理</h2><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><p>可以在此给网站添加用户，一般是不会手动添加用户的，手动添加用户一般只用来添加管理员，普通用户通常是会有注册渠道。<br>填写用户名，电子邮件，名字，姓氏，密码，选择用户角色后即可完成用户的添加。<br><img src="https://img-blog.csdnimg.cn/20210122103135103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></p>
<h4 id="用户资料"><a href="#用户资料" class="headerlink" title="用户资料"></a>用户资料</h4><p>点击个人资料即可看到自己的资料<br><img src="https://img-blog.csdnimg.cn/20210122103558110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></p>
<ol>
<li>可视化编辑器<br>不使用可视化编辑器：<img src="https://img-blog.csdnimg.cn/2021012210331455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">
使用可视化编辑器
<img src="https://img-blog.csdnimg.cn/2021012210335138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%"></li>
<li>管理界面的配色：后台左侧和上侧的颜色</li>
<li>工具栏：在登录之后，打开自己的网站，会看到最上面有一条工具条。<img src="https://img-blog.csdnimg.cn/20210122103742533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>资料图片：需要到gravatar网站上注册账户，并设置头像。当在wordpress的网站中使用相同的邮件账户注册会员，那么wordpress就会根据邮件账户信息，从gravatar网站中获取头像<h4 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h4>在所有用户页面内可以管理此网站的所有用户<br>在这里插入图片描述<img src="https://img-blog.csdnimg.cn/20210122104125701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
</ol>
<h2 id="四、工具"><a href="#四、工具" class="headerlink" title="四、工具"></a>四、工具</h2><h4 id="快速发布"><a href="#快速发布" class="headerlink" title="快速发布"></a>快速发布</h4><p>将按钮拖动到收藏夹栏即可添加这个工具。再打开别人的网站时，点击快速发布按钮，可以将该网页的标题，内容，图片等copy下来形成一个文章。</p>
<h4 id="直接链接"><a href="#直接链接" class="headerlink" title="直接链接"></a>直接链接</h4><p>类似快速发布，点击直接连接按钮，可以看到最上方有一栏可以输入url，找到想要剪辑的网页，将url复制到此栏即可生成一篇文章。</p>
<h4 id="导入和导出"><a href="#导入和导出" class="headerlink" title="导入和导出"></a>导入和导出</h4><p>导入可以从其它博客平台等网站，将自己的文章和评论等导入到此网站。到处则是创建一个xml文件，保存网站的内容。</p>
<h2 id="五、外观"><a href="#五、外观" class="headerlink" title="五、外观"></a>五、外观</h2><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><ol>
<li>主题的作用<br>更换不同的主题，网站的视觉效果会发生改变。用户看到的网站内容也会发生改变。站点的功能也会发生变化。</li>
<li>主题的安装方法<br>点击添加主题即可进入安装页面，可以在此页面安装主题<br>（1）在线安装：在wordpress的特色、热门、最新等栏目中选择主题，也可以搜索主题安装。安装后点击实时预览可以看到网站更换主题的效果。点击启用即可更换主题。<img src="https://img-blog.csdnimg.cn/20210122105005590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
（2）手动安装：将主题下载到本地，点击上传主题，选择下载好的主题zip文件，点击现在安装即可。
<img src="https://img-blog.csdnimg.cn/20210122105121342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
（3）直接安装：直接将解压后的主题文件夹，放置在wp-content/themes/文件夹内。回到主提页面，刷新一下即可看到刚才安装的主题。</li>
<li>自定义主题<br>点击自定义按钮后，可以看到左侧是自定义的栏目（不同的主题栏目会不一样），右侧是实时效果预览<img src="https://img-blog.csdnimg.cn/20210122105310748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
#### 小工具
有的主题没有提供这个功能，有没有这个功能是由主题决定的。</li>
<li>小工具右侧可以看到一些容器，修改这些容器可以更改网页的效果。</li>
<li>小工具左侧可用的选项，可以拖动到右面的容器中使用。<img src="https://img-blog.csdnimg.cn/2021012210562168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
## 六、设置
#### 常规设置</li>
<li>站点标题：网站的名称</li>
<li>副标题：一般情况下，显示在网站的标题旁边 </li>
<li>wordpress地址和站点地址一般使用默认</li>
<li>电子邮件地址：用于接收站点相关通知的邮</li>
<li>成员资格：网站是否允许其他人注册</li>
<li>新用户默认角色：考虑权限以及安全问题，订阅者权限即可。</li>
<li>ICP备案号：可以填写网站的备案号，是否会在网站显示取决于主题。<img src="https://img-blog.csdnimg.cn/20210122105910627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
#### 撰写设置</li>
<li>默认文章分类：发布文章时没有勾选分类目录时，wordpress会自动将这篇文章放到此处设置的分类目录里面</li>
<li>更新服务：在更新服务里面填写的网址，当发布新的内容的时候，wordpress会自动通知此处的链接地址。（主要用于搜索优化）<img src="https://img-blog.csdnimg.cn/20210122110028192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
#### 阅读设置</li>
<li>首页显示：默认显示最新文章，选择静态页面时可以设置站点首页为后台发布的某张页面</li>
<li>Feed中显示最近：用户订阅我们网站内容时，每页显示多少内容<img src="https://img-blog.csdnimg.cn/20210122110140495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
#### 讨论设置
尝试通知文章链接的博客：在发布文章时，如果文章内容发布链接时，如果勾选此选项，则会通知对方我们的链接指向了他们（一般不使用）。
<img src="https://img-blog.csdnimg.cn/20210122110305572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
#### 多媒体设置
上传图片后，wordpress会自动在此图片基础上转换出不同像素大小的图片。
#### 固定链接
通过切换不同的链接结构，可以改变网页网址。更改的主要原因是为了搜索引擎检索的优化。一般使用文章名较好。
<img src="https://img-blog.csdnimg.cn/20210122110437112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
自定义结构
| 代码       | 作用       |
| ---------- | ---------- |
| %post_id%  | 内容的编号 |
| %postname% | 内容的名称 |
| %year%     | 发布的年份 |
| %monthnum% | 发布的月份 |
| %day%      | 具体哪一天 |</li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>网站</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>【WordPress网站设计】小白网站设计流程（使用Elementor可视化编辑网站）</title>
    <url>/2021/01/25/033-%E3%80%90WordPress%E7%BD%91%E7%AB%99%E8%AE%BE%E8%AE%A1%E3%80%91%E5%B0%8F%E7%99%BD%E7%BD%91%E7%AB%99%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8Elementor%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E8%BE%91%E7%BD%91%E7%AB%99%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h4 id="1-安装Elementor插件"><a href="#1-安装Elementor插件" class="headerlink" title="1. 安装Elementor插件"></a>1. 安装Elementor插件</h4><p>进入wordpress后台，搜索插件Elementor进行安装。<br><img src="https://img-blog.csdnimg.cn/20210122171337715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></p>
<blockquote>
<p>如果安装失败，可以在官网下载安装包，手动上传安装，安装方法参考<a href="https://blog.csdn.net/weixin_44543463/article/details/112839933">此篇文章</a><br>下载地址：<a href="https://cn.wordpress.org/plugins/elementor/">https://cn.wordpress.org/plugins/elementor/</a></p>
</blockquote>
<h4 id="2-安装主题"><a href="#2-安装主题" class="headerlink" title="2. 安装主题"></a>2. 安装主题</h4><p>这里以Astra主题为例，进入wordpress后台，搜索主题Astra进行安装。<br><img src="https://img-blog.csdnimg.cn/20210125142357851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></p>
<h4 id="3-安装辅助插件"><a href="#3-安装辅助插件" class="headerlink" title="3. 安装辅助插件"></a>3. 安装辅助插件</h4><p>根据不同主题的要求，可能需要安装不同的辅助插件，才能导入网站模板。Astra主题需要的插件是Starter Templates。<br><img src="https://img-blog.csdnimg.cn/20210125142716805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></p>
<h2 id="二、导入模板"><a href="#二、导入模板" class="headerlink" title="二、导入模板"></a>二、导入模板</h2><p>点击<strong>外观-Starter Templates</strong>，可以看到Astra的一些网站模板。在这里我们可以选择一个符合自己网站主题的模板（点击详情可以预览网页），导入到我们的网站中。<br><img src="https://img-blog.csdnimg.cn/20210125143120692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210125143354910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></p>
<h2 id="三、可视化编辑"><a href="#三、可视化编辑" class="headerlink" title="三、可视化编辑"></a>三、可视化编辑</h2><h4 id="1-修改网站logo和标识"><a href="#1-修改网站logo和标识" class="headerlink" title="1. 修改网站logo和标识"></a>1. 修改网站logo和标识</h4><p>（1）进入自己的网站界面，点击上方的使用Elementor编辑，进入Elementor的编辑界面。<br><img src="https://img-blog.csdnimg.cn/20210125144617113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br>（2）点击左上角进入<strong>站点设置-网站标识</strong>，可以修改网站的Logo和标识。<br><img src="https://img-blog.csdnimg.cn/20210125145014221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210125145038629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210125145314609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></p>
<h4 id="2-修改内容"><a href="#2-修改内容" class="headerlink" title="2. 修改内容"></a>2. 修改内容</h4><p>Elementor是模块化的编辑器，它将网站从上到下按不同段进行拼接，每个段内部分成一个或多个栏，可以填加不同的功能模块。<br>（1）修改文字：将鼠标放在要求改的文字上，单击可以直接修改，或者在左侧编辑菜单中修改。<br><img src="https://img-blog.csdnimg.cn/20210125145751962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br>（2）更换图片：点击要修改的图片，可以看到左侧编辑菜单出现了相应的选项，此处可以更换图像，图像可以选择媒体库中已存在的图像，也可以上传图像。同时下方能够修改图像的尺寸和对齐方式。此外还可以在高级设置中进行更多的设置。<br><img src="https://img-blog.csdnimg.cn/20210125150258960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210125150701232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br>（3）更改图标：还是点击要求改的图标，以Read More→的→为例，在左侧可以选择图标库中已经有的图标，也可以自己上传图标。<br><img src="https://img-blog.csdnimg.cn/20210125151020486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210125151045717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></p>
<h4 id="3-修改布局"><a href="#3-修改布局" class="headerlink" title="3. 修改布局"></a>3. 修改布局</h4><p>（1）点击段上方中间的按钮，在左侧可以更改此段的布局（边距、对齐）、结构（分栏数）等。<br><img src="https://img-blog.csdnimg.cn/20210125151413750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br>（2）点击段内部各个栏的左上方的小窗子，可以修改内部各栏的布局。<br><img src="https://img-blog.csdnimg.cn/2021012515165162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br>（3）修改段的位置，点击Elementor编辑菜单下方的导航器。可看到右侧出现了网站的大纲列表，直接拖动对应的段即可直接排序。<br><img src="https://img-blog.csdnimg.cn/20210125153008401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210125153032288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></p>
<h4 id="4-添加段"><a href="#4-添加段" class="headerlink" title="4. 添加段"></a>4. 添加段</h4><p>（1）翻到页面最下端或者点击某段上方的+，可以添加段<br><img src="https://img-blog.csdnimg.cn/20210125152108814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br>（2）添加新段：选择分栏的方式数目，然后从左侧Elementor的编辑菜单直接拖动需要的功能模块至各栏即可。<br><img src="https://img-blog.csdnimg.cn/20210125152200844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210125152327441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br>（3）使用Elementor的模板，这里可以在左上角选择模板的分类，比如我要添加About的相关模块。选好后直接插入即可。<br><img src="https://img-blog.csdnimg.cn/20210125152432962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br>（4）有些主题也有自己内置的模块，添加方法类似。<br><img src="https://img-blog.csdnimg.cn/20210125152637596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></p>
<h2 id="四、修改网页导航"><a href="#四、修改网页导航" class="headerlink" title="四、修改网页导航"></a>四、修改网页导航</h2><p>网页导航就是网站最上方的一排导航按钮，在wordpress后台的外观-菜单中可以修改。可以选择不同的页面添加到导航菜单中，也可以修改导航菜单的顺序，或者修改页面之间的从属关系，实现下拉菜单的效果。<br><img src="https://img-blog.csdnimg.cn/20210125153219863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210125153326303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>网站</category>
      </categories>
      <tags>
        <tag>网站搭建</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>【RobotStudio学习笔记】（一）软件的安装与初步测试</title>
    <url>/2021/01/26/034-%E3%80%90RobotStudio%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="RobotStudio-6-03-02-的安装"><a href="#RobotStudio-6-03-02-的安装" class="headerlink" title="RobotStudio 6.03.02 的安装"></a>RobotStudio 6.03.02 的安装</h2><blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1NyDTu_OCcPJLbfaQLtCHCw">https://pan.baidu.com/s/1NyDTu_OCcPJLbfaQLtCHCw</a><br>提取码：robo </p>
</blockquote>
<h5 id="1-安装注意事项"><a href="#1-安装注意事项" class="headerlink" title="1. 安装注意事项"></a>1. 安装注意事项</h5><p>（1）PC用户名为英文<br>（2）安装路径为英文<br>（3）安装过程全程联网</p>
<h5 id="2-安装方法"><a href="#2-安装方法" class="headerlink" title="2. 安装方法"></a>2. 安装方法</h5><p>（1）将安装包解压，运行安装包内的setup.exe程序，按照提示安装即可，比较简单。<br>（2）安装完成后双击<code>RobotStudio_5.61.02注册补丁.reg</code>。<br>（3）打开RobotStudio即可完成安装。</p>
<h2 id="初次测试"><a href="#初次测试" class="headerlink" title="初次测试"></a>初次测试</h2><ol>
<li>打开RobotStudio软件，新建一个空工作站解决方案。<img src="https://img-blog.csdnimg.cn/20210125115511712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>点击左上角ABB模型库，导入一个IRB 120确定<img src="https://img-blog.csdnimg.cn/20210125115613611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210125115623160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="40%">
<img src="https://img-blog.csdnimg.cn/2021012511561873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>然后点击机器人系统-从布局创建系统，选择一个6.03的软件版本<img src="https://img-blog.csdnimg.cn/20210125115737139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210125115741617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="40%">
<img src="https://img-blog.csdnimg.cn/20210125115744637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="40%">
点击选项，将其中的默认语言改为中文，点击完成即可，稍等一段时间等待系统创建完成。
<img src="https://img-blog.csdnimg.cn/20210125115854259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="40%">
<img src="https://img-blog.csdnimg.cn/20210125115857844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="40%"></li>
<li>当下方控制器状态变成绿色的时候说明系统已经创建完成了。<img src="https://img-blog.csdnimg.cn/20210125120032477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210125120039330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>点击上方 控制器-示教器-虚拟示教器<img src="https://img-blog.csdnimg.cn/20210125120130585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
在弹出的示教器窗口，打开控制面板切换为手动并使能。
<img src="https://img-blog.csdnimg.cn/20210125120154143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>在机器人视图内，Ctrl+左键为平移，Ctrl+Shift+左键为旋转，调整视图，使虚拟示教器和机器人能够同时看到。</li>
<li>点击菜单-程序编辑器，新建一个程序。<img src="https://img-blog.csdnimg.cn/20210125120329622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
添加一条MoveJ指令
<img src="https://img-blog.csdnimg.cn/20210125120404443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
长按示教器右边的箭头，使机器人转动一个角度，然后在下方再添加一条MoveJ指令。（一定要看示教器上访的状态，保证机器人是手动控制模式、电机开启）
<img src="https://img-blog.csdnimg.cn/20210125120415784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
然后点击调试-PP移至Main，再点击右下方的运行按钮，即可看到机器人在起始位置和刚才转动的位置进行往复运动。
<img src="https://img-blog.csdnimg.cn/20210125120426558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>【RobotStudio学习笔记】（二）手动操作</title>
    <url>/2021/01/28/035-%E3%80%90RobotStudio%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89%E6%89%8B%E5%8A%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="手动单轴操作"><a href="#手动单轴操作" class="headerlink" title="手动单轴操作"></a>手动单轴操作</h2><ol>
<li>打开一个机器人系统，打开虚拟示教器</li>
<li>点击<strong>菜单-手动操纵-动作模式</strong>，可以看到下方有四个动作模型，其中轴1-3和轴4-6为单轴操作，后面是线性操作，和重定位操作，这里<strong>选择轴1-3</strong>，点击确定。<img src="https://img-blog.csdnimg.cn/20210125140527223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210125140532834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210125140536765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>可以看到在手动操作界面右方有机器人的位置信息和操纵杆方向。 操纵杆方向处的箭头对应示教器控制器的箭头，数字代表轴的序号。 如第一个代表上下箭头控制二轴的运动，下箭头为正方向第二个代表左右箭头控制1轴的运动，第三个代表顺时针，逆时针按钮控制3轴的运动。如果想要控制4-6，点击动作模式选择轴4-6即可。<img src="https://img-blog.csdnimg.cn/20210125140715773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
## 手动线性操作</li>
<li>进入手动操纵的菜单栏，可以看到现在的动作模式是单轴动作，坐标系不可选。<img src="https://img-blog.csdnimg.cn/20210125140811571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>点击动作模式，将<strong>动作模式更改为线性</strong>，确定后，可以看到此时的坐标系可以选择了。<img src="https://img-blog.csdnimg.cn/20210125140849441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>进入坐标系菜单，可以看到有四种坐标系，分别是大地坐标、基坐标、工具、工件坐标。<img src="https://img-blog.csdnimg.cn/20210125140931116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>首先看大地坐标，选择大地坐标确定后，可以看到控制器右侧的位置信息变成了xyz坐标值。操纵杆方向也变成了xyz，大地坐标系就是以机器人视图左下角的坐标系为基准进行运动。<img src="https://img-blog.csdnimg.cn/20210125141017416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210125141024981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>基坐标系，选中机器人底座，可以看到有一个坐标系，此时xyz就是沿着这个坐标系确定的。<img src="https://img-blog.csdnimg.cn/2021012514111936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>工具坐标，可以看到菜单栏有一项为工具坐标tool0，这个坐标系就是以机器人末端第六关节的坐标运动。<img src="https://img-blog.csdnimg.cn/20210125141147664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210125141151479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>工件坐标，可以看到菜单栏有一项为工件坐标tool0，这个坐标系是以工件的坐标系运动。<h2 id="重定位操作"><a href="#重定位操作" class="headerlink" title="重定位操作"></a>重定位操作</h2></li>
<li>打开虚拟示教器，<strong>手动操纵-动作模式</strong>，切换动作模式为重定位。<img src="https://img-blog.csdnimg.cn/20210126112359422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>回到手动操纵的菜单栏，可以看到此时的坐标系为工具，工具坐标为tool0<img src="https://img-blog.csdnimg.cn/20210126112814805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>按下示教器的箭头，手动操作进行观察，可以发现位置坐标XYZ始终不发生变化。<img src="https://img-blog.csdnimg.cn/20210126113447236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>将爪子隐藏，可以看出系统运动过程中，第6关节末端中心点位置保持不变。<img src="https://img-blog.csdnimg.cn/20210126113725826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="30%">
<img src="https://img-blog.csdnimg.cn/20210126113827573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
## 动作模式的切换</li>
<li>在摇杆的左侧切换操作模式，第二个按钮是切换重定位和线性，第三个按钮切换轴1-3和轴4-6。面板右下角显示当前操作模式。<img src="https://img-blog.csdnimg.cn/20210126142144107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>点击示教器右下角图标，可以看到机器人系统的详细信息，在这里同样可以对手动操纵菜单栏里所有的选项进行更改。<img src="https://img-blog.csdnimg.cn/20210126142226534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>【RobotStudio学习笔记】（三）程序创建</title>
    <url>/2021/01/28/036-%E3%80%90RobotStudio%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E4%B8%89%EF%BC%89%E7%A8%8B%E5%BA%8F%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<p><strong>1. 层级结构</strong><br>打开主菜单-程序 可以看到最上面一行是程序名称，T_ROB1/MainModule/main。<br><img src="https://img-blog.csdnimg.cn/20210128232141274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br>其中T_ROB1是任务，有几个机械单元就有几个任务可以选择。比如两个机械臂协同工作，就会出现ROB2等。<br><img src="https://img-blog.csdnimg.cn/20210128232154943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br>第二层是模块，分成系统模块和程序模块。模块就是将机器人需要实现的各个功能分成不同模块。可以理解成文件夹。<br><img src="https://img-blog.csdnimg.cn/20210128232221908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br>第三层是例行程序，是机器人系统真正执行的一些程序。<br><img src="https://img-blog.csdnimg.cn/2021012823223232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br><strong>2. 新建程序</strong><br>新建模块：点击文件-新建模块。<br><img src="https://img-blog.csdnimg.cn/20210128232339667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210128232342799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br>进入新建的模块，可以看到现在的模块只是相当于一个文件夹，并没有创建程序的地方。所以我们需要先创建一个例行程序。点击右上方例行程序，文件-新建例行程序。<br><img src="https://img-blog.csdnimg.cn/20210128232354418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br><img src="https://img-blog.csdnimg.cn/20210128232357133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br>点击显示例行程序，就可以进入到程序编辑页面了。<br>把当前位置记录下来，使用添加指令-MoveJ指令。<br>将机器人移动至另一个位置，再次添加MoveJ指令。点击调试-pp移至Main，点击右边的单步执行，可以看到机器人进行了一步移动。<br><img src="https://img-blog.csdnimg.cn/20210128232421755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"><br>同时，程序可以切换单周执行与连续执行。<br><img src="https://img-blog.csdnimg.cn/2021012823243114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>【RobotStudio学习笔记】（四）夹取工件程序设计</title>
    <url>/2021/01/30/037-%E3%80%90RobotStudio%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E5%9B%9B%EF%BC%89%E5%A4%B9%E5%8F%96%E5%B7%A5%E4%BB%B6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="一、指令"><a href="#一、指令" class="headerlink" title="一、指令"></a>一、指令</h3><ol>
<li>MoveJ：移动到某位置</li>
<li>Set/Reset：控制外部设备<h3 id="二、实现过程"><a href="#二、实现过程" class="headerlink" title="二、实现过程"></a>二、实现过程</h3></li>
<li>在初始位置添加一句MoveJ指令<img src="https://img-blog.csdnimg.cn/20210130223152519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>将机器人爪调至工件的正上方，再添加一条MoveJ指令（在工件上方添加一个位置点，是为了防止机器人直接夹取，可能会从侧面撞到工件）<img src="https://img-blog.csdnimg.cn/20210130223224740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>将机器人爪子向下移动到夹取工件的位置，添加一条MoveJ指令<img src="https://img-blog.csdnimg.cn/20210130223249635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>使用Set指令，使机器人爪子夹紧工件。<img src="https://img-blog.csdnimg.cn/20210130223307362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>将机器人竖直向上移动，使工件脱离工作台，添加一条MoveJ指令。<img src="https://img-blog.csdnimg.cn/20210130223325749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>将工件移动到夹具台上方，再次添加一条MoveJ指令。<img src="https://img-blog.csdnimg.cn/20210130223346194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>将工具放到工作台上，添加一条MoveJ指令，再使用Reset指令松开夹爪。<img src="https://img-blog.csdnimg.cn/20210130223407578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>使用MoveJ指令将机器人先竖直向上移动，再回到初始位置，即可完成一个动作周期。<h3 id="三、增强代码可读性-创建robtarget数据"><a href="#三、增强代码可读性-创建robtarget数据" class="headerlink" title="三、增强代码可读性-创建robtarget数据"></a>三、增强代码可读性-创建robtarget数据</h3>点击MoveJ指令后的<em>，点击ToPoint，点击新建，即可创建一个robotarget数据，代替</em>所在位置，增强程序的可读性。<br>（注意，新建robtarget数据时，是记录机器人<strong>现在位置</strong>，而非原指位置）<img src="https://img-blog.csdnimg.cn/2021013022383614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/2021013022384658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210130223849295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/2021013022385995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
### 四、修改程序中的工具数据
为了输出负载等其它参数的正常与机器人的稳定运行，需要将指令后的工具坐标修改为正确的工具坐标。</li>
<li>当机器人系统处于此行程序对应位置时，点击tool0修改为tGrip<img src="https://img-blog.csdnimg.cn/20210131231140252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210131230745750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>因工具坐标发生变化，所以对应的位置坐标也需要改变，点击修改位置即可将更改正确位置<img src="https://img-blog.csdnimg.cn/20210131230807560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>将机器人移动到下一个位置，然后再修改工具坐标，再更正位置。<img src="https://img-blog.csdnimg.cn/20210131230828617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>【RobotStudio学习笔记】（五）工具数据</title>
    <url>/2021/01/30/038-%20%E3%80%90RobotStudio%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E4%BA%94%EF%BC%89%E5%B7%A5%E5%85%B7%E6%95%B0%E6%8D%AE%20/</url>
    <content><![CDATA[<ol>
<li>拆除夹爪，测量夹爪末端坐标<img src="https://img-blog.csdnimg.cn/20210130224218166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>点击建模-测量-点到点，选择夹爪底面和末端面，记录得到的z坐标值<img src="https://img-blog.csdnimg.cn/20210130224307753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>将夹爪安装回机器人末端<img src="https://img-blog.csdnimg.cn/20210130224323148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>打开虚拟示教器，进入手动操纵-工具坐标-新建，修改名称，点击左下角初始值<img src="https://img-blog.csdnimg.cn/20210130224339453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>修改第一个z（坐标位置）为刚才测得得值215.30，mass（质量）为1，第二个z（重心位置）初估一个数<img src="https://img-blog.csdnimg.cn/20210130224351960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210130224356614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>验证坐标，选择动作模式为重定位，工具坐标为刚才新建坐标。操纵摇杆可看到机器人绕夹爪两末端中心点转动。</li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>【RobotStudio学习笔记】（六）有效载荷</title>
    <url>/2021/01/31/039-%E3%80%90RobotStudio%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E5%85%AD%EF%BC%89%E6%9C%89%E6%95%88%E8%BD%BD%E8%8D%B7/</url>
    <content><![CDATA[<p>从夹爪夹住工件后，系统的载荷就发生了变化，对于仿真程序中效果区别可能不明显，但在实际系统中，必须要考虑载荷的区别。</p>
<ol>
<li>打开手动操作-有效载荷<img src="https://img-blog.csdnimg.cn/20210131230940711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>新建一个有效载荷<img src="https://img-blog.csdnimg.cn/20210131231245338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210131231252329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210131231300677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>修改程序，在程序开始处，添加指令-settings-gripload<img src="https://img-blog.csdnimg.cn/20210131231314809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210131231318175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>添加到上方，负载为load0<img src="https://img-blog.csdnimg.cn/20210131231341397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>在夹爪夹取工件后，即set dol0_1语句下，再次添加一条gripload语句，负载为load_Box。同理，在夹爪松开后，再次添加一条gripload语句，负载为load0.<img src="https://img-blog.csdnimg.cn/20210131231356461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>【RobotStudio学习笔记】（七）工件坐标</title>
    <url>/2021/02/01/040-%E3%80%90RobotStudio%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E4%B8%83%EF%BC%89%E5%B7%A5%E4%BB%B6%E5%9D%90%E6%A0%87/</url>
    <content><![CDATA[<h3 id="一、工件坐标简介"><a href="#一、工件坐标简介" class="headerlink" title="一、工件坐标简介"></a>一、工件坐标简介</h3><p>在目标工作台的任意位置，任意角度创建一个直角坐标系，把这个坐标系叫做工件坐标。<br>在不同的位置创建工件坐标系，就可以实现，相同的程序在不同的位置实现相同的加工。</p>
<h3 id="二、3点法设置工件坐标"><a href="#二、3点法设置工件坐标" class="headerlink" title="二、3点法设置工件坐标"></a>二、3点法设置工件坐标</h3><ol>
<li><p>进入手动操作-工件坐标=新建，创建一个工件坐标</p>
<img src="https://img-blog.csdnimg.cn/20210201233648550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210201233651421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li><p>选中新建的工件坐标，编辑-定义，用户方法选择3点</p>
<img src="https://img-blog.csdnimg.cn/20210201233720674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210201233725746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li><p>如果想建立一个如下图所示的坐标系</p>
<img src="https://img-blog.csdnimg.cn/20210201233738948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li><p>在仿真内选择基本-其它-创建工件坐标，用户坐标框架-取点创建框架，选择三个点即可创建坐标系。</p>
<img src="https://img-blog.csdnimg.cn/20210201233752532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="40%">
<img src="https://img-blog.csdnimg.cn/202102012337556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="30%">
### 三、实际系统工件坐标的确定
在操作实际机器人系统时，可以选择一个具有尖端的工件，手动操作对齐要确定的三个点，记录下来设置工件坐标。</li>
<li><p>添加一个具有尖端的工具，用于确定目标点坐标。将工具添加到机器人系统中，并隐藏此前的夹爪工具。</p>
<img src="https://img-blog.csdnimg.cn/20210202215601345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210202215702951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="40%">
<img src="https://img-blog.csdnimg.cn/20210202215653454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="40%"></li>
<li><p>按照上文<strong>三点法设置工件坐标</strong>的前两步。选择仓库的三个点位分别设置为X1、X2、Y1，以此来确定工件坐标系。完成后点击确定。</p>
<img src="https://img-blog.csdnimg.cn/20210202215848235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210202215905721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210202220049412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li><p>同理在操作台也可以创建一个工件坐标</p>
<img src="https://img-blog.csdnimg.cn/20210202220204452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210202220208134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210202220227233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li><p>删除刚才添加用于确定点位的工具（Pen），令夹爪可见</p>
<h3 id="四、程序中工件坐标的修改方法"><a href="#四、程序中工件坐标的修改方法" class="headerlink" title="四、程序中工件坐标的修改方法"></a>四、程序中工件坐标的修改方法</h3><p>修改程序中的工件坐标，使在仓库夹取工件的部分动作使用仓库工件坐标系，在操作台的放置部分动作使用操作台工件坐标系，其余动作使用默认工件坐标系。</p>
</li>
<li><p>以pPickUP位置处的动作为例。单步运行程序，运行至pPickUP位置时，点击整条指令，<strong>可选变量—[\WObj]—使用</strong></p>
<img src="https://img-blog.csdnimg.cn/20210202220422892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210202220720676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li><p>点击wobj0，选择wobj_CK确定</p>
<img src="https://img-blog.csdnimg.cn/20210202220735993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li><p>选择回到手动操作面板，点击工件坐标，选择wobj_CK</p>
<img src="https://img-blog.csdnimg.cn/20210202220758156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210202220806430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li><p>再回到程序编辑器，选择刚才编辑的那一条语句，修改位置即可。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>【RobotStudio学习笔记】（八）速度设置</title>
    <url>/2021/02/02/041-%E3%80%90RobotStudio%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E5%85%AB%EF%BC%89%E9%80%9F%E5%BA%A6%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="一、速度的直接设置"><a href="#一、速度的直接设置" class="headerlink" title="一、速度的直接设置"></a>一、速度的直接设置</h3><p>在手动模式下，最大速度受到限制，最大时250mm/s。而程序中v1000在仿真和实际中是十分快的，因此修改工件拿起和放下时的速度，轻拿轻放。<br><img src="https://img-blog.csdnimg.cn/20210202221242154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"><br>实际操作时，手动调试完成后要先如下图，从25%速度开始测试，如果实物机器人运动没有问题，在逐步增大速度，直到100%。如果中间出现任何问题，就将程序中的速度参数修改成适合的值。<br><img src="https://img-blog.csdnimg.cn/20210202221406536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></p>
<h3 id="二、速度数据的创建与替换"><a href="#二、速度数据的创建与替换" class="headerlink" title="二、速度数据的创建与替换"></a>二、速度数据的创建与替换</h3><ol>
<li>点击<strong>菜单【三V】—&gt;数据类型—&gt;全部数据类型—speeddata—&gt;显示数据—&gt;新建</strong><img src="https://img-blog.csdnimg.cn/2021020222214267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210202222145611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210202222149565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>设置变量的名字，然后修改初始值，其中v_tcp是直线运动速度（主要用这个），v_ori是重定位速度。<img src="https://img-blog.csdnimg.cn/20210202222152873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210202222306240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210202222308918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>回到程序设计页面，点击速度值，选择需要替换的速度变量，确定。<img src="https://img-blog.csdnimg.cn/20210202222353738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210202222356696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210202222359177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
### 三、速度延时设置
夹爪的加紧动作需要时间，如果不延时的话，夹爪会在加进的同时运动，可能导致一些问题。设置的方法如下：</li>
<li>点击夹爪夹紧的指令（Set语句），添加指令WaitTime，这里以1s延时为例。<img src="https://img-blog.csdnimg.cn/20210202222716601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210202222719563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210202222721665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>同理在夹爪松开时，同样需要进行延时设置。<img src="https://img-blog.csdnimg.cn/20210202222758693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>【RobotStudio学习笔记】（九）坐标偏移设置</title>
    <url>/2021/02/03/042-%E3%80%90RobotStudio%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E4%B9%9D%EF%BC%89%E5%9D%90%E6%A0%87%E5%81%8F%E7%A7%BB%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="Offs指令"><a href="#Offs指令" class="headerlink" title="Offs指令"></a>Offs指令</h3><p><strong>功能</strong>：根据当前所选工件坐标以及基准点进行坐标偏移<br><strong>使用</strong>：Offs(变量, Δx, Δy, Δz)</p>
<h3 id="坐标偏移设置方法"><a href="#坐标偏移设置方法" class="headerlink" title="坐标偏移设置方法"></a>坐标偏移设置方法</h3><ol>
<li>点击要偏移的robtarget数据，选择<strong>功能-Offs</strong><img src="https://img-blog.csdnimg.cn/20210203203127916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210203203140988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>例如让夹爪夹取工件后竖直上升50mm，则可按如下设置<img src="https://img-blog.csdnimg.cn/2021020320315993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210203203201258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
同理，其它坐标的偏移方式也可按相同的方法进行设置。</li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>【RobotStudio学习笔记】（十）模块化程序</title>
    <url>/2021/02/04/043-%E3%80%90RobotStudio%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E5%8D%81%EF%BC%89%E6%A8%A1%E5%9D%97%E5%8C%96%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>当程序比较复杂，或者程序内存在重复的部分时，模块化程序设计往往是比较可行的办法。在RobotStudio中可以通过在主程序中调用不同的例行程序，达到使代码逻辑清晰的目的。</p>
<h3 id="将搬运工件的动作保存为例行程序"><a href="#将搬运工件的动作保存为例行程序" class="headerlink" title="将搬运工件的动作保存为例行程序"></a>将搬运工件的动作保存为例行程序</h3><ol>
<li>进入例行程序，新建一个例行程序<img src="https://img-blog.csdnimg.cn/20210204224202652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210204224206400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>回到main程序，鼠标选中第一行，点击编辑-编辑，将main函数内的代码复制到新建的例行程序中<img src="https://img-blog.csdnimg.cn/20210204224224703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>回到刚才新建的例行程序中，将main函数代码粘贴过来。<img src="https://img-blog.csdnimg.cn/20210204224237573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>利用调试-pp移至例行程序，测试例行程序是否正确，没有问题的话，就将main函数的内容，用指令procall代替。<img src="https://img-blog.csdnimg.cn/2021020422425031.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210204224327471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210204224304409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
### 快速实现搬运第二个工件</li>
<li>首先将搬运工件的例行程序复制一份<img src="https://img-blog.csdnimg.cn/20210204224415393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/2021020422442011.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>因为工件的位置是利用仓库的工件坐标系通过偏倚确定的，因此只需要修改Offs函数的参数即可确定第二个工件的夹取位置。<img src="https://img-blog.csdnimg.cn/20210204224443342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>RobotStudio关于Ctrl+鼠标左键拖动速度慢的解决方法</title>
    <url>/2021/02/06/044-RobotStudio%E5%85%B3%E4%BA%8ECtrl+%E9%BC%A0%E6%A0%87%E5%B7%A6%E9%94%AE%E6%8B%96%E5%8A%A8%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>使用ABB RobotStudio的过程中，有时会遇到鼠标拖动平移视角的速度突然变慢的问题，不知道问题出在什么地方，但是发现了解决方法：<br><strong>工作站空白处右键，点击查看全部或查看中心</strong><br><img src="https://img-blog.csdnimg.cn/20210206211208458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"><br>然后就恢复正常了。</p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>bug解决</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>RobotStudio传送带设计</title>
    <url>/2021/02/06/045-RobotStudio%E4%BC%A0%E9%80%81%E5%B8%A6%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<blockquote>
<p>工作站文件：<br>链接：<a href="https://pan.baidu.com/s/1kikAGbj-vVAH-IR9AWY1sg">https://pan.baidu.com/s/1kikAGbj-vVAH-IR9AWY1sg</a><br>提取码：robo </p>
</blockquote>
<h3 id="传送带模型的创建"><a href="#传送带模型的创建" class="headerlink" title="传送带模型的创建"></a>传送带模型的创建</h3><ol>
<li>新建一个工作站，从设备中导入一个传送带<img src="https://img-blog.csdnimg.cn/20210206224246204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210206224248316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="30%"></li>
<li>创建一个正方体，作为传送带的传送对象<img src="https://img-blog.csdnimg.cn/20210206224310980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="40%"></li>
<li>将小方块拖动带传送带上我们要的位置处<img src="https://img-blog.csdnimg.cn/20210206224425607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>可以借助<strong>捕捉</strong>与<strong>设定位置</strong>精确定位小方块的位置<img src="https://img-blog.csdnimg.cn/20210206224447527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="30%">
<img src="https://img-blog.csdnimg.cn/20210206224451279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210206224453136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="30%">
### 简单传送带设计</li>
<li>建立一个Smart组件，先实现小方块的直线移动<img src="https://img-blog.csdnimg.cn/20210206224552764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210206224555161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="40%"></li>
<li>点击仿真-播放，然后点击Smart组件的Execute按钮，即可观察到小方块的直线运动。但是小方块无法自行停止，需要点击停止按钮，然后重置，才能回到初始状态。<img src="https://img-blog.csdnimg.cn/2021020622461846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>添加一个<strong>面传感器</strong>用于检测小方块的位置<img src="https://img-blog.csdnimg.cn/20210206224642954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210206224646236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>回到Smart组件的设计页面，设计逻辑程序，因为<strong>传送带的逻辑是输入端有高电平就运行，传感器的逻辑是有物体触碰就输出高电平，其他时间输出低电平</strong>。因此要实现传送带的要求，只需要将<strong>传感器的输出取非后传给传动带</strong>即可。<img src="https://img-blog.csdnimg.cn/202102062247123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210206224713976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%"></li>
<li>进行仿真，发现传送带与小方块的运行效果符合预期。如果发现小方块不停止的话，将传送带的<strong>可由传感器检测</strong>取消掉就可以了<img src="https://img-blog.csdnimg.cn/20210206224732832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="30%">
### 多个物体的连续传送</li>
<li>添加一个Source组件用于实现小方块的复制，编辑它的属性<img src="https://img-blog.csdnimg.cn/20210206224810810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
复制源Source选择小方块，位置通过捕捉本地原点选择小方块的原点，点击应用。</li>
<li>然后进行复制小方块的程序设计由于<strong>Source组件的触发条件是上升沿</strong>，即低脉冲跃变到高脉冲时，才会触发复制效果。<img src="https://img-blog.csdnimg.cn/20210206224915720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
因此考虑添加一个脉冲信号的发生组件Timber，信号间隔暂定为5s。
<img src="https://img-blog.csdnimg.cn/20210206224925945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210206224928925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>但是这样带来的问题是，在第一个小方块还未到终点时，因为时间已经到了5s，因此传送带会开始运送下一个小方块，仿真表现是所有小方块运动5s后会自动停止。因此选择使用队列这个组件来解决问题。<img src="https://img-blog.csdnimg.cn/20210206225010760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210206225046494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/2021020622502545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
</ol>
<ul>
<li>back：将复制出来的小方块添加到队列后面</li>
<li>delete：删除队列中最前面的物体</li>
<li>enqueue：接收到复制完成的信号后开始将对象添加到队列中</li>
<li>传送带的传送对象需要改为整个队列</li>
</ul>
<p>仿真效果如下（可将原始方块部件_1取消可见，显示效果更好）<br><img src="https://img-blog.csdnimg.cn/20210206225425517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>RobotStudio创建目标点时出现未找到有效配置的问题</title>
    <url>/2021/02/07/046-RobotStudio%E5%88%9B%E5%BB%BA%E7%9B%AE%E6%A0%87%E7%82%B9%E6%97%B6%E5%87%BA%E7%8E%B0%E6%9C%AA%E6%89%BE%E5%88%B0%E6%9C%89%E6%95%88%E9%85%8D%E7%BD%AE%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><p>RobotStudio在使用路径和目标点的创建目标点时，有时会出现<strong>无法跳转到目标点</strong>的问题，错误为<strong>未找到有效配置</strong>。<br><img src="https://img-blog.csdnimg.cn/20210207223509743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></p>
<h4 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h4><ol>
<li><strong>未使用正确的工具坐标</strong></li>
<li>目标点的坐标与工具坐标无法对应，<strong>机器人不能实现运动</strong>到指定位置使两坐标系重合。<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4></li>
<li>解决方法1：在基本-设置选择正确的工具坐标，例如夹具的工具坐标。</li>
<li>解决方法2：右键目标点-修改目标-旋转，将坐标系旋转至<strong>工具运动到此位置时的工具坐标系重合</strong>。如果仍然有问题可以多试几个方向，一般不止一个方向可以实现跳转到目标点。<img src="https://img-blog.csdnimg.cn/20210207223828674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210207223831418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>bug解决</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>RobotStudio双传送带系统的搭建</title>
    <url>/2021/02/08/047-RobotStudio%E5%8F%8C%E4%BC%A0%E9%80%81%E5%B8%A6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="机械结构的搭建"><a href="#机械结构的搭建" class="headerlink" title="机械结构的搭建"></a>机械结构的搭建</h3><ol>
<li>导入两个传送带，将第二个传送带以z轴旋转90°，再沿y轴偏移-3200mm。<img src="https://img-blog.csdnimg.cn/20210208220925834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
<img src="https://img-blog.csdnimg.cn/20210208220928149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210208220932520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210208220938376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
<img src="https://img-blog.csdnimg.cn/20210208220951687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li>导入机器人IRB120，将其移动到合适的位置上。<img src="https://img-blog.csdnimg.cn/20210208221212764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
<img src="https://img-blog.csdnimg.cn/20210208221220232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="70%"></li>
<li>创建工件的模型，将工件的第二部分内的物体拖动到第一部分中，形成一个部件<img src="https://img-blog.csdnimg.cn/20210208221157676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
<img src="https://img-blog.csdnimg.cn/20210208221255491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="70%"></li>
<li>将工件移动到合适的位置<img src="https://img-blog.csdnimg.cn/20210208221309199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li>导入夹具，将夹具旋转至与大地坐标系平行<img src="https://img-blog.csdnimg.cn/20210208222354248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li>设置夹具的本地坐标<img src="https://img-blog.csdnimg.cn/20210208222418547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li>在左侧布局栏中，将夹具拖动到机器人上，更新夹具的位置<img src="https://img-blog.csdnimg.cn/20210208222428972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
### 创建机器人系统
<img src="https://img-blog.csdnimg.cn/20210208222524806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20210208222531328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210208222535887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210208222539823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210208222543443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
<img src="https://img-blog.csdnimg.cn/2021020822255042.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
<img src="https://img-blog.csdnimg.cn/20210208222552948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
</ol>
<p>等待一段时间，等待系统创建完成即可进行传送带的试验。</p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>RobotStudio机器人运行路径的创建与仿真</title>
    <url>/2021/02/09/048-RobotStudio%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E8%A1%8C%E8%B7%AF%E5%BE%84%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<p>本文在一个已经<strong>搭建好机械模型</strong>，同时<strong>完成机器人系统的创建</strong>后的机器人运行路径的创建过程。初始时的界面如下：<br><img src="https://img-blog.csdnimg.cn/20210209222732393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>工程文件已上传到网盘</strong><br>包括：初始工程文件（03Practice_init.rspag）、完成后的工程文件（03Practice.rspag）、模型文件<br>链接：<a href="https://pan.baidu.com/s/1f0RL-iLBm2Kxd0NbLduv0Q">https://pan.baidu.com/s/1f0RL-iLBm2Kxd0NbLduv0Q</a><br>提取码：rs03</p>
</blockquote>
<h4 id="工件坐标的创建"><a href="#工件坐标的创建" class="headerlink" title="工件坐标的创建"></a>工件坐标的创建</h4><p><img src="https://img-blog.csdnimg.cn/2021020922332540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210209223802723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="运行路径的创建"><a href="#运行路径的创建" class="headerlink" title="运行路径的创建"></a>运行路径的创建</h4><ol>
<li>首先创建一个空路径<br><img src="https://img-blog.csdnimg.cn/20210209224044219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>改变机器人的姿态，使工具移动到目标点进行示教。<br><img src="https://img-blog.csdnimg.cn/20210209224624729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210209224837363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210209225455767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210209225734881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>动作类型<ul>
<li>Joint：机器人以点到点的形式到此点（不走直线，各轴自由运动）</li>
<li>Linear：机器人以直线运行方式从上一点运行到下一点</li>
</ul>
</li>
<li>Conc<ul>
<li>禁用：机器人会精确到达此点</li>
<li>启用：机器人会依据Zone的参数，略过此点</li>
</ul>
</li>
<li>Speed：机器人的运动速度</li>
<li>Zone：启用Conc时，机器人掠过目标点所经过圆弧轨迹的半径</li>
</ul>
<ol start="3">
<li>测试到达能力并进行模拟运行<br><img src="https://img-blog.csdnimg.cn/20210209230801863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h4 id="仿真与录像"><a href="#仿真与录像" class="headerlink" title="仿真与录像"></a>仿真与录像</h4></li>
<li>将工作站同步到Rapid代码<br><img src="https://img-blog.csdnimg.cn/20210209231033919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210209231123433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>进行仿真设定<br><img src="https://img-blog.csdnimg.cn/20210209231433940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>播放并录制保存仿真视频。（录制的视频默认保存在 <strong>我的电脑/视频</strong> 目录下）<br><img src="https://img-blog.csdnimg.cn/20210209231800534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>RobotStudio碰撞检测的设定</title>
    <url>/2021/02/10/049-RobotStudio%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E7%9A%84%E8%AE%BE%E5%AE%9A/</url>
    <content><![CDATA[<h4 id="碰撞检测的创建"><a href="#碰撞检测的创建" class="headerlink" title="碰撞检测的创建"></a>碰撞检测的创建</h4><p>单击<strong>创建碰撞检测</strong>进行创建，创建完成后，<strong>ObjectA</strong>与<strong>ObjectB</strong>为进行检测的两个组，如果两个组的物体发生碰撞，则会发生颜色变化。<br><img src="https://img-blog.csdnimg.cn/20210210225054223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="碰撞检测的设定"><a href="#碰撞检测的设定" class="headerlink" title="碰撞检测的设定"></a>碰撞检测的设定</h4><p>可以在右键菜单中设置<strong>接近距离</strong>和<strong>变化颜色</strong><br><img src="https://img-blog.csdnimg.cn/20210210225349634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="仿真演示"><a href="#仿真演示" class="headerlink" title="仿真演示"></a>仿真演示</h4><ol>
<li>正常状态，焊枪与盒子未碰撞，颜色未改变。<br><img src="https://img-blog.csdnimg.cn/20210210225540781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>焊枪与盒子碰撞时，两物体颜色均改变成设定的颜色<br><img src="https://img-blog.csdnimg.cn/20210210225735560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>RobotStudio动态夹具的创建</title>
    <url>/2021/02/11/050-RobotStudio%E5%8A%A8%E6%80%81%E5%A4%B9%E5%85%B7%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="创建夹具的几何模型"><a href="#创建夹具的几何模型" class="headerlink" title="创建夹具的几何模型"></a>创建夹具的几何模型</h3><p>如果你有其它建模软件如Solidworks等做的夹具模型，可以导入到RobotStudio中。<br>这里简单建模，主要展示动态夹具的创建流程。</p>
<ol>
<li>创建夹具的本体<br><img src="https://img-blog.csdnimg.cn/2021021118235246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>将其移动到其他位置，准备创建夹具的其他部分<br><img src="https://img-blog.csdnimg.cn/20210211182556601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>创建一个圆柱，作为夹具的法兰盘，与机器人的关节末端相连<br><img src="https://img-blog.csdnimg.cn/20210211182711155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>移动长方体的位置。<br><img src="https://img-blog.csdnimg.cn/20210211183344368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>将部件2的物体拖动到部件1上，将两个物体组合成一个部件。<br><img src="https://img-blog.csdnimg.cn/20210211183417631.png" alt="在这里插入图片描述"></li>
<li>创建夹爪<br><img src="https://img-blog.csdnimg.cn/20210211185037224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210211185210299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h4 id="创建机械装置"><a href="#创建机械装置" class="headerlink" title="创建机械装置"></a>创建机械装置</h4></li>
<li>点击创建机械装置，装置名称写“夹具”，装置类型选“工具”<br><img src="https://img-blog.csdnimg.cn/20210211185601702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>添加链接，为刚才创建的三个部件分别添加链接。如果是导入的模型，也需要为各个部件添加链接。其中基座部分需要勾选BaseLink，其它部分不需要。<br><img src="https://img-blog.csdnimg.cn/2021021118590865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210211190145202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210211190132510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210211190122529.png" alt="在这里插入图片描述"><br>3. 创建接点<br><img src="https://img-blog.csdnimg.cn/20210211190707491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210211191438163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol start="4">
<li>创建工具数据<br><img src="https://img-blog.csdnimg.cn/20210211191249823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>添加一个新姿态<br><img src="https://img-blog.csdnimg.cn/20210211220048957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="Smart组件设置"><a href="#Smart组件设置" class="headerlink" title="Smart组件设置"></a>Smart组件设置</h3></li>
<li>创建Smart组件，将夹具拖动到Smart组件下，并将夹具设置为Smart组件的角色Role<br><img src="https://img-blog.csdnimg.cn/20210211220910621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>添加以下组件<br><img src="https://img-blog.csdnimg.cn/20210211221433525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>添加信号<br><img src="https://img-blog.csdnimg.cn/20210211222422794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>对各个组件进行设置，首先先设置夹具不可由传感器检测<br><img src="https://img-blog.csdnimg.cn/20210211222651888.png" alt="在这里插入图片描述"></li>
<li>设置直线传感器，设置为图示圆柱状，用于检测夹具下方是否有物体<br><img src="https://img-blog.csdnimg.cn/20210211223201571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>设置Attacher安装对象组件<br><img src="https://img-blog.csdnimg.cn/20210211223352233.png" alt="在这里插入图片描述"></li>
<li>设置PoseMover，机械装置运动的属性<br><img src="https://img-blog.csdnimg.cn/20210211223612946.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210211223631433.png" alt="在这里插入图片描述"></li>
<li>按图示设计程序框图<br><img src="https://img-blog.csdnimg.cn/20210211224200115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1pVwEuCmvoiwFlHMjRqEjLQ">https://pan.baidu.com/s/1pVwEuCmvoiwFlHMjRqEjLQ</a><br>提取码：rs04 </p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>RobotStudio码垛机器人创建过程</title>
    <url>/2021/02/13/051-RobotStudio%E7%A0%81%E5%9E%9B%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="一、安装夹具"><a href="#一、安装夹具" class="headerlink" title="一、安装夹具"></a>一、安装夹具</h3><ol>
<li>导入一个IRB2600机器人<br><img src="https://img-blog.csdnimg.cn/20210213164433918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>移动夹具的本地坐标原点，使原点位置为顶面中心（与法兰盘连接的部位）<br><img src="https://img-blog.csdnimg.cn/20210213164735705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210213164924385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>对齐夹爪Smart组件的本地坐标和机器人末端法兰盘的坐标，使夹具的本地坐标与法兰盘的本地坐标重合，为下一步安装夹具做准备。<br><img src="https://img-blog.csdnimg.cn/20210213165530663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>在布局菜单内，将夹具拖动到IRB2600机器人上，完成夹具的安装<br><img src="https://img-blog.csdnimg.cn/20210213165939792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="二、创建传送带"><a href="#二、创建传送带" class="headerlink" title="二、创建传送带"></a>二、创建传送带</h3></li>
<li>导入传送带并设定传送带的位置<br><img src="https://img-blog.csdnimg.cn/20210213170317940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>创建码垛用的物体，并将其移动到传送带的起点。<br><img src="https://img-blog.csdnimg.cn/20210213171128797.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210213171755770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>创建一个Smart组件，用于传送带物体的运动。添加如下组件<br><img src="https://img-blog.csdnimg.cn/20210213172158659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>对各个组件进行设置<br><img src="https://img-blog.csdnimg.cn/20210213173500255.png" alt="在这里插入图片描述"></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210213172636348.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210213172918414.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210213173026596.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210213175804683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="三、创建码垛底盘"><a href="#三、创建码垛底盘" class="headerlink" title="三、创建码垛底盘"></a>三、创建码垛底盘</h3><p><img src="https://img-blog.csdnimg.cn/20210213174505654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="四、创建机器人系统"><a href="#四、创建机器人系统" class="headerlink" title="四、创建机器人系统"></a>四、创建机器人系统</h3><p><img src="https://img-blog.csdnimg.cn/2021021317474614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210213174754268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>选项内选择如下选项<br><img src="https://img-blog.csdnimg.cn/20210213174833386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="？"><a href="#？" class="headerlink" title="？"></a>？</h3><ol>
<li><p>在仿真设定中，将机器人系统后面的框选去除。<br><img src="https://img-blog.csdnimg.cn/20210213175056230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>运行仿真，使物块到达面传感器处，然后停止仿真，捕捉几个目标点。（后面两个目标点是为了码垛时，物块会有两种拜访姿态，所以使用两个目标点）<br><img src="https://img-blog.csdnimg.cn/20210213181432772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>旋转第三个目标点，使其绕Z轴旋转-90度。<br><img src="https://img-blog.csdnimg.cn/20210213182046356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>为目标点配置参数<br><img src="https://img-blog.csdnimg.cn/20210213182546238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>使机器人回到机械原点，然后创建一个空路径，将三个目标点依次拖动到路径中。<br><img src="https://img-blog.csdnimg.cn/20210213183001640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210213183106200.png" alt="在这里插入图片描述"></p>
</li>
<li><p>同步到工作站<br><img src="https://img-blog.csdnimg.cn/20210213183147494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210213183155155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>删除之前仿真出来的物块的copy物体。</p>
</li>
<li><p>添加两个信号，一个是到位信号，用于传送带的等待，另一个是夹具信号。添加完成后重启控制器。<br><img src="https://img-blog.csdnimg.cn/20210213225452844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210213225557921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210213225632720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210213225650174.png" alt="在这里插入图片描述"></p>
</li>
<li><p>打开控制器，可以看到RAPID/T_ROB1下的程序模块，接下来就可以进行程序编写了。</p>
<h3 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h3><p>main程序代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MODULE Module1</span><br><span class="line">	CONST robtarget Target_10:=[[<span class="number">347.037</span>,<span class="number">682.5</span>,<span class="number">875.06</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>]];</span><br><span class="line">	CONST robtarget Target_20:=[[<span class="number">500</span>,<span class="number">-300</span>,<span class="number">100</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>]];</span><br><span class="line">	CONST robtarget Target_30:=[[<span class="number">500</span>,<span class="number">-300</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>]];</span><br><span class="line">	VAR num layer:=<span class="number">1</span>;</span><br><span class="line">    VAR num x:=<span class="number">0</span>;</span><br><span class="line">    VAR num z:=<span class="number">0</span>;</span><br><span class="line">    <span class="function">PROC <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        FOR i FROM 0 TO 20 DO</span></span><br><span class="line"><span class="function">            SetDO JiaJu0,0</span>;</span><br><span class="line">            <span class="function">MoveJ <span class="title">Offs</span><span class="params">(Target_10,<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>)</span>,v500,fine,Tool1</span>;</span><br><span class="line">            WaitDI DaoWei0,<span class="number">1</span>; </span><br><span class="line">            <span class="function">MoveL <span class="title">Offs</span><span class="params">(Target_10,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span>,v500,fine,Tool1</span>;</span><br><span class="line">            SetDO JiaJu0,<span class="number">1</span>;</span><br><span class="line">            WaitTime <span class="number">1</span>;</span><br><span class="line">            <span class="function">MoveL <span class="title">Offs</span><span class="params">(Target_10,<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>)</span>,v500,fine,Tool1</span>;</span><br><span class="line"></span><br><span class="line">            IF layer MOD <span class="number">2</span> = <span class="number">1</span> THEN</span><br><span class="line">                IF i MOD <span class="number">5</span> &lt; <span class="number">4</span> <span class="keyword">and</span> i MOD <span class="number">5</span> &lt;&gt; <span class="number">0</span> THEN</span><br><span class="line">                    MoveL Offs(Target_30,<span class="number">90</span>+x,<span class="number">-150</span>,<span class="number">300</span>+z),v500,fine,Tool1;</span><br><span class="line">                    <span class="function">MoveL <span class="title">Offs</span><span class="params">(Target_30,<span class="number">90</span>+x,<span class="number">-150</span>,<span class="number">100</span>+z)</span>,v500,fine,Tool1</span>;</span><br><span class="line">                    SetDO JiaJu0,<span class="number">0</span>;</span><br><span class="line">                    WaitTime <span class="number">1</span>;</span><br><span class="line">                    <span class="function">MoveL <span class="title">Offs</span><span class="params">(Target_30,<span class="number">90</span>+x,<span class="number">-150</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1</span>;</span><br><span class="line">                    x:=x+<span class="number">210</span>;</span><br><span class="line">                    IF i MOD <span class="number">5</span> = <span class="number">3</span> THEN</span><br><span class="line">                        x:=<span class="number">0</span>;</span><br><span class="line">                    <span class="function">ENDIF</span></span><br><span class="line"><span class="function">                ELSE</span></span><br><span class="line"><span class="function">                    MoveL <span class="title">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-410</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1</span>;</span><br><span class="line">                    <span class="function">MoveL <span class="title">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-410</span>,<span class="number">100</span>+z)</span>,v500,fine,Tool1</span>;</span><br><span class="line">                    SetDO JiaJu0,<span class="number">0</span>;</span><br><span class="line">                    WaitTime <span class="number">1</span>;</span><br><span class="line">                    <span class="function">MoveL <span class="title">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-410</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1</span>;</span><br><span class="line">                    x:=x+<span class="number">300</span>;</span><br><span class="line">                ENDIF</span><br><span class="line">                IF i MOD <span class="number">5</span> = <span class="number">0</span> THEN</span><br><span class="line">                    layer:=<span class="number">2</span>;</span><br><span class="line">                    x:=<span class="number">0</span>;</span><br><span class="line">                    z:=z+<span class="number">100</span>;</span><br><span class="line">                ENDIF</span><br><span class="line">                </span><br><span class="line">            ELSE</span><br><span class="line">                IF i MOD <span class="number">5</span> &lt; <span class="number">3</span> <span class="function">THEN</span></span><br><span class="line"><span class="function">                    MoveL <span class="title">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-100</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1</span>;</span><br><span class="line">                    <span class="function">MoveL <span class="title">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-100</span>,<span class="number">100</span>+z)</span>,v500,fine,Tool1</span>;</span><br><span class="line">                    SetDO JiaJu0,<span class="number">0</span>;</span><br><span class="line">                    WaitTime <span class="number">1</span>;</span><br><span class="line">                    <span class="function">MoveL <span class="title">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-100</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1</span>;</span><br><span class="line">                    x:=x+<span class="number">300</span>;</span><br><span class="line">                    IF i MOD <span class="number">5</span> = <span class="number">2</span> THEN</span><br><span class="line">                        x:=<span class="number">0</span>;</span><br><span class="line">                    <span class="function">ENDIF</span></span><br><span class="line"><span class="function">                ELSE</span></span><br><span class="line"><span class="function">                    MoveL <span class="title">Offs</span><span class="params">(Target_30,<span class="number">100</span>+x,<span class="number">-350</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1</span>;</span><br><span class="line">                    <span class="function">MoveL <span class="title">Offs</span><span class="params">(Target_30,<span class="number">100</span>+x,<span class="number">-350</span>,<span class="number">100</span>+z)</span>,v500,fine,Tool1</span>;</span><br><span class="line">                    SetDO JiaJu0,<span class="number">0</span>;</span><br><span class="line">                    WaitTime <span class="number">1</span>;</span><br><span class="line">                    <span class="function">MoveL <span class="title">Offs</span><span class="params">(Target_30,<span class="number">100</span>+x,<span class="number">-350</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1</span>;</span><br><span class="line">                    x:=x+<span class="number">210</span>;</span><br><span class="line">                ENDIF</span><br><span class="line">                IF i MOD <span class="number">5</span> = <span class="number">0</span> THEN</span><br><span class="line">                    layer:=<span class="number">1</span>;</span><br><span class="line">                    x:=<span class="number">0</span>;</span><br><span class="line">                    z:=z+<span class="number">100</span>;</span><br><span class="line">                ENDIF</span><br><span class="line">            ENDIF</span><br><span class="line">                </span><br><span class="line">        ENDFOR</span><br><span class="line">        z:=<span class="number">0</span>;</span><br><span class="line">    ENDPROC</span><br><span class="line">ENDMODULE</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="仿真测试"><a href="#仿真测试" class="headerlink" title="仿真测试"></a>仿真测试</h3><ol>
<li>将代码同步到工作站<br><img src="https://img-blog.csdnimg.cn/20210213234602340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>删除Path_10路径，只保留main路径<br><img src="https://img-blog.csdnimg.cn/2021021323470717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>设置工作站逻辑<br><img src="https://img-blog.csdnimg.cn/20210214091553226.png" alt="在这里插入图片描述"></li>
<li>进行仿真</li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>ABB RobotStudio6.08安装</title>
    <url>/2021/02/14/052-ABB%20RobotStudio6.08%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>网盘链接<br>链接：<a href="https://pan.baidu.com/s/1yUpRG146dUXC9Gj1D94AHw">https://pan.baidu.com/s/1yUpRG146dUXC9Gj1D94AHw</a><br>提取码：rsaz </p>
</blockquote>
<h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><ol>
<li>解压安装包，运行<code>ABB RobotStudio 6.08.msi</code>程序，按流程一步步安装<img src="https://img-blog.csdnimg.cn/20210214230540700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li>安装完成后再根据自己电脑，解压<code>RobotStudio注册文件-64位系统</code>或者<code>RobotStudio注册文件-32位系统</code>压缩包，双击其中的注册表文件<code>RobotStudio注册.reg</code>。这样就完成了ABB RobotStudio的安装与破解了。</li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>RobotStudio</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>robotstudio</tag>
      </tags>
  </entry>
  <entry>
    <title>【个人网站搭建教程】阿里云服务器+宝塔+wordpress</title>
    <url>/2021/02/14/053-%E3%80%90%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%E3%80%91%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8+%E5%AE%9D%E5%A1%94+wordpress/</url>
    <content><![CDATA[<h2 id="一、服务器和域名的申请"><a href="#一、服务器和域名的申请" class="headerlink" title="一、服务器和域名的申请"></a>一、服务器和域名的申请</h2><h4 id="1-1-服务器的购买"><a href="#1-1-服务器的购买" class="headerlink" title="1.1 服务器的购买"></a>1.1 服务器的购买</h4><ol>
<li>进入阿里云官网，购买ECS云服务器（可以看看<a href="https://developer.aliyun.com/plan/promotion/1?spm=a2c6h.13813017.1364563.d100010001.5ab41d3cmWpHDS&utm_content=g_1000199894">开发者成长计划</a>，虽然我当时是在618这里买的学生ECS）。服务器的系统选择CentOS或Ubuntu。<img src="https://img-blog.csdnimg.cn/20210122111836977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
购买完成后会进入[控制台](https://ecs.console.aliyun.com/)，在这里可以看到自己刚才购买的服务器。
<img src="https://img-blog.csdnimg.cn/2021012211413525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li>服务器使用之前，我们需要先重置root用户密码。<img src="https://img-blog.csdnimg.cn/20210122113927832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li>重置密码完成后就可以通过<strong>公网IP</strong>，使用xshell或者PuTTy或者阿里平台的远程连接工具登陆服务器了。</li>
</ol>
<h4 id="1-2-域名申请与备案"><a href="#1-2-域名申请与备案" class="headerlink" title="1.2 域名申请与备案"></a>1.2 域名申请与备案</h4><ol>
<li>进入<a href="https://wanwang.aliyun.com/domain?utm_content=se_1008301712">域名注册平台</a>，选一个合适的域名，点击结算。（如果之前没有申请过域名的话，在结算时需要创建个人的信息模板，按要求填写信息即可）。<img src="https://img-blog.csdnimg.cn/20210122112538994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li>购买后域名的注册就完成了，然后需要网站备案。进入阿里<a href="https://beian.aliyun.com/">备案首页</a>，开始备案。<img src="https://img-blog.csdnimg.cn/20210122113026126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li>填写完成个人信息，点击信息校验（<strong>注意：要求域名注册后两到三天再来备案</strong>）<img src="https://img-blog.csdnimg.cn/20210122113206149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
然后按要求填写自己的信息，网站的信息，进行身份验证，提交审核。**注意各项信息都要填写准确，不符合要求的后续还要打电话修改**。</li>
<li>提交审核后，在一个工作日之内，阿里云的客服会打电话确认身份，同时告知备案信息需要修改的地方，这期间需要保持电话畅通。</li>
<li>阿里云初审完成后，会将备案信息提交管局，大概一天之内你会收到一条工信部的验证短信，根据短信上的验证码，进入<a href="https://beian.miit.gov.cn/#/Integrated/ComplaintA">工信部官网</a>验证。<img src="https://img-blog.csdnimg.cn/20210125114242561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li>等待7-20天，管局审核完成后，备案也就ok了。<img src="https://img-blog.csdnimg.cn/20210126114111334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
</ol>
<h2 id="二、宝塔面板的安装"><a href="#二、宝塔面板的安装" class="headerlink" title="二、宝塔面板的安装"></a>二、宝塔面板的安装</h2><h4 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h4><p>进入<a href="https://www.bt.cn/">宝塔官网</a>注册一个宝塔账号，后续需要使用。</p>
<h4 id="2-2-安装宝塔面板"><a href="#2-2-安装宝塔面板" class="headerlink" title="2.2 安装宝塔面板"></a>2.2 安装宝塔面板</h4><blockquote>
<p>以下安装过程参考官网：<a href="https://www.bt.cn/bbs/thread-19376-1-1.html">https://www.bt.cn/bbs/thread-19376-1-1.html</a></p>
</blockquote>
<ol>
<li><strong>开放服务器端口</strong><br>进入控制台，点击实例名称，进入安全组-安全组列表页面，点击配置规则。<img src="https://img-blog.csdnimg.cn/20210122115315696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
如下图所示，放行8888端口，并开放所有ip访问，点击保存即可
<img src="https://img-blog.csdnimg.cn/20210122115424138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
另外在这里同时开启其他端口，点击快速添加，选择SSH、HTTP、HTTPS、MySQL添加，方便后续网站的访问。
<img src="https://img-blog.csdnimg.cn/20210122162442629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li><strong>安装面板</strong></li>
</ol>
<ul>
<li>CentOS 安装命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure></li>
<li>Ubuntu 安装命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>安装成功后可以看到显示宝塔后台的地址，以及用户名和密码。打开浏览器登录宝塔后台。</p>
</blockquote>
</li>
</ul>
<ol start="3">
<li><strong>宝塔面板设置</strong><br>为了安全考虑，进入面板后先修改宝塔面板用户和面板密码。（这里的面板用户和密码不是官网账户，而是每个云服务器访问宝塔面板需要用到的账户面板）<img src="https://img-blog.csdnimg.cn/2021012214203651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li><strong>安装LNMP环境</strong><br>LNMP网站环境就是指Linux+Nginx+MySQL+PHP的组合，用来快速搭建各种开源的网站程序如Wordpress、Typecho等。<img src="https://img-blog.csdnimg.cn/20210122142410380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
安装需要10~20分钟，安装过程是自动完成的。稍等一段时间即可。
<img src="https://img-blog.csdnimg.cn/20210122142530495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li><strong>宝塔账号实名认证</strong><br>进入<a href="https://www.bt.cn/">宝塔官网</a>，点击右上角会员后台，或者点此链接进入后台<a href="https://www.bt.cn/admin/userinfo">https://www.bt.cn/admin/userinfo</a>。<img src="https://img-blog.csdnimg.cn/20210122143056349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
左侧选择账户管理，进行实名认证。
<img src="https://img-blog.csdnimg.cn/20210122143134773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li><strong>添加站点</strong><br>点击左侧网站-添加站点<img src="https://img-blog.csdnimg.cn/2021012215401486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
<img src="https://img-blog.csdnimg.cn/2021012215395199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
网站站点添加成功后，就可以进入网站的根目录了。后面搭建网站都会在这个网站的根目录下进行。
<img src="https://img-blog.csdnimg.cn/20210122154617871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
## 三、安装WordPress
#### 3.1 上传WordPress安装包</li>
<li>前往<a href="https://cn.wordpress.org/download/">WordPress中国官网</a>下载zip安装包<blockquote>
<p>下载链接：<a href="https://cn.wordpress.org/latest-zh_CN.zip">https://cn.wordpress.org/latest-zh_CN.zip</a></p>
</blockquote>
</li>
<li>回到宝塔，点击文件，进入域名的根目录，点击左上角上传文件，上传刚才下载的wordpress安装包。<img src="https://img-blog.csdnimg.cn/20210122160012907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li>上传成功后，解压zip格式的安装包<img src="https://img-blog.csdnimg.cn/20210122160251972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
<img src="https://img-blog.csdnimg.cn/20210122160354590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
#### 3.2 修改站点配置文件
<img src="https://img-blog.csdnimg.cn/20210122160922643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
</ol>
<p>由于安装包解压到站点目录/wordpress下，因此配置文件中的root需要改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root /www/wwwroot/huffie.top/wordpress;</span><br></pre></td></tr></table></figure>
<p>修改完成后，点击保存。</p>
<h4 id="3-3-域名解析绑定"><a href="#3-3-域名解析绑定" class="headerlink" title="3.3 域名解析绑定"></a>3.3 域名解析绑定</h4><ol>
<li>进入阿里云的域名控制台<img src="https://img-blog.csdnimg.cn/20210202224621109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li>添加记录<img src="https://img-blog.csdnimg.cn/20210202224652784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
<img src="https://img-blog.csdnimg.cn/20210202230457866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
ps.这里遇到了一个小问题，总是显示**您的请求在Web服务器中没有找到对应的站点！**，尝试了许多方法，最后是将PHP版本从7.4更改为5.6，然后成功的，不知道是不是因为这个原因，后来版本改回7.4后也可以继续访问了。
#### 3.4 WordPress的在线安装
在浏览器地址栏输入自己的域名，即可看到wordpress的欢迎页面。接下来的步骤就是进行wordpress的配置了。
<img src="https://img-blog.csdnimg.cn/20210122162705578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li><strong>填写数据库信息</strong><br>数据库名、用户名、密码可以到宝塔控制台的数据库栏查到。<img src="https://img-blog.csdnimg.cn/20210122162842517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
按要求填写，填写完成后点击提交。
<img src="https://img-blog.csdnimg.cn/20210122163100980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/20210122163213237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li><strong>填写网站信息</strong><img src="https://img-blog.csdnimg.cn/20210122163524276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></li>
<li><strong>安装成功</strong><br>登陆后台，可以看到熟悉的wordpress管理界面。<img src="https://img-blog.csdnimg.cn/20210122163756962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%">
<img src="https://img-blog.csdnimg.cn/2021012216392447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>网站</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>网站建设</tag>
      </tags>
  </entry>
  <entry>
    <title>由于没有公钥，无法验证下列签名 :NO_PUBKEY 的解决方法</title>
    <url>/2021/02/16/054-%E7%94%B1%E4%BA%8E%E6%B2%A1%E6%9C%89%E5%85%AC%E9%92%A5%EF%BC%8C%E6%97%A0%E6%B3%95%E9%AA%8C%E8%AF%81%E4%B8%8B%E5%88%97%E7%AD%BE%E5%90%8D%20NO_PUBKEY%20%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>今天运行apt-get update时突然出现了由于没有公钥，无法验证下列签名的问题，尝试了网上许多方法，最终找到了一种亲测有效的解决方法：</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>在终端输入：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 76F1A20FF987672F</span><br></pre></td></tr></table></figure>
<p>其中最后的代码为报错语句中的最后一部分：由于没有公钥，无法验证下列签名： NO_PUBKEY <strong>76F1A20FF987672F</strong></p>
<h3 id="解决结果"><a href="#解决结果" class="headerlink" title="解决结果"></a>解决结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Executing: /tmp/apt-key-gpghome.uBwlOPqFFF/gpg.1.sh --keyserver hkp://keyserver.ubuntu.com:80 --recv 76F1A20FF987672F</span><br><span class="line">gpg: key 76F1A20FF987672F: 1 signature not checked due to a missing key</span><br><span class="line">gpg: 密钥 76F1A20FF987672F：公钥“WineHQ packages &lt;wine-devel@winehq.org&gt;”已导入</span><br><span class="line">gpg: 合计被处理的数量：1</span><br><span class="line">gpg:               已导入：1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>bug解决</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派4B安装Ubuntu20.04</title>
    <url>/2021/02/17/055-%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85Ubuntu20.04/</url>
    <content><![CDATA[<h2 id="一、树莓派的准备"><a href="#一、树莓派的准备" class="headerlink" title="一、树莓派的准备"></a>一、树莓派的准备</h2><ol>
<li>进入<a href="http://cdimage.ubuntu.com/ubuntu/releases/20.04/release/">Ubuntu官网</a>下载支持树莓派的Ubuntu版本安装包。<img src="https://img-blog.csdnimg.cn/20210216202301823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%"></li>
<li>使用DiskGenius格式化SD卡，将所有扇区删除，然后格式化。<img src="https://img-blog.csdnimg.cn/20210215223910879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="70%"></li>
<li><a href="https://downloads.raspberrypi.org/imager/imager.exe">下载官方烧录工具</a>，镜像选择刚才下载的.xz文件，SD卡选择自己的卡，写入即可。<img src="https://img-blog.csdnimg.cn/20210216202513364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">
## 二、Ubuntu系统配置
### 2.1 进入Ubuntu系统
将TF卡插到树莓派上。可以通过显示器进行系统初始化配置，也可以用网线将树莓派和电脑连接起来，再进行远程配置。建议使用一个外接显示器，操作会简单许多。**以使用外接屏幕+键盘为例**（这些设备只使用一次就够了）</li>
<li>将之前制作好的SD卡插入树莓派中，为树莓派连接电源（电源可以是2.5mm圆头电源线，也可以是microUSB或者TypeC接口的线，但要求充电头能够达到5V 3A，最低5V 2.5A）</li>
<li>开机，等待一段时间后进入系统，首先需要登录，<strong>初始用户名和密码都是ubuntu</strong>，登陆后会要求重新设置密码。<h3 id="2-2-wifi设置"><a href="#2-2-wifi设置" class="headerlink" title="2.2 wifi设置"></a>2.2 wifi设置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/netplan</span><br></pre></td></tr></table></figure>
在该目录下，如果是服务器，则会有一个50-cloud-init.yaml的文件，如果是桌面环境，会有一个01-network-manager-all.yaml<br>这里以50-cloud-init.yaml为例，编辑文件:<br>注意文件的缩进格式，<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  wifis:</span><br><span class="line">    wlan0:</span><br><span class="line">      dhcp4: <span class="literal">true</span></span><br><span class="line">      optional: <span class="literal">true</span></span><br><span class="line">      access-points:</span><br><span class="line">        <span class="string">&quot;你的wifi名称&quot;</span>:</span><br><span class="line">          password: <span class="string">&quot;wifi密码&quot;</span></span><br></pre></td></tr></table></figure>
然后执行命令使配置生效<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo netplan generate</span><br><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>
输入命令<code>ifconfig</code>即可查看ip地址，使用远程访问工具进行访问。<h3 id="2-3-更新源"><a href="#2-3-更新源" class="headerlink" title="2.3 更新源"></a>2.3 更新源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
source.list内容<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal main main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>
进行更新<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<h3 id="2-4-安装桌面环境"><a href="#2-4-安装桌面环境" class="headerlink" title="2.4 安装桌面环境"></a>2.4 安装桌面环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ubuntu-desktop</span><br><span class="line">sudo apt install xrdp</span><br></pre></td></tr></table></figure>
<h3 id="2-5-安装中文环境"><a href="#2-5-安装中文环境" class="headerlink" title="2.5 安装中文环境"></a>2.5 安装中文环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install language-pack-zh-hans language-pack-zh-hans-base language-pack-gnome-zh-hans language-pack-gnome-zh-hans-base</span><br><span class="line">sudo apt install `check-language-support -l zh`</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<h3 id="2-7-允许root登录"><a href="#2-7-允许root登录" class="headerlink" title="2.7 允许root登录"></a>2.7 允许root登录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo passwd root <span class="comment">#设置root密码</span></span><br><span class="line">sudo vim /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf <span class="comment">#编辑此文件</span></span><br></pre></td></tr></table></figure>
添加下列两行到50-ubuntu.conf<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">greeter-show-manual-login=<span class="literal">true</span></span><br><span class="line">allow-guest=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="2-8-远程桌面连接"><a href="#2-8-远程桌面连接" class="headerlink" title="2.8 远程桌面连接"></a>2.8 远程桌面连接</h3>在windows搜索框输入<code>远程桌面连接</code>，选择Xorg模式，输入用户名密码即可连接。</li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu使用VNC实现远程桌面</title>
    <url>/2021/02/18/056-ubuntu%E4%BD%BF%E7%94%A8VNC%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我是在树莓派4B上安装的Ubuntu20.10，想通过VNC实现远程桌面连接，进行接下来的试验。<br>但是在网上搜索了许多关于VNC连接的博客，也尝试了各种方法，但总是出现各种问题，要么连接不上，要么连接上了就黑屏灰屏，总之出现了各种问题，重装了n次系统，最终找到了一种实现的方法。<br><strong>注：已经试验过Ubunt18.04、Ubuntu20.04与Ubuntu20.10，均正常实现</strong></p>
<h3 id="Windows端"><a href="#Windows端" class="headerlink" title="Windows端"></a>Windows端</h3><p>安装VNC Viewer，进入其<a href="https://www.realvnc.com/en/connect/download/viewer/">VNC Viewer官网</a>下载安装。<br><img src="https://img-blog.csdnimg.cn/20210218155650612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Ubuntu端"><a href="#Ubuntu端" class="headerlink" title="Ubuntu端"></a>Ubuntu端</h3><p><strong>进行VNC设置之前，需要有图形界面，没有的可以执行以下代码安装图形界面</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ubuntu-desktop</span><br><span class="line">apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal</span><br><span class="line">sudo reboot <span class="comment">#重启即可看到图形界面</span></span><br></pre></td></tr></table></figure>
<h6 id="1-安装x11vnc程序"><a href="#1-安装x11vnc程序" class="headerlink" title="1. 安装x11vnc程序"></a>1. 安装x11vnc程序</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install x11vnc</span><br></pre></td></tr></table></figure>
<h6 id="2-安装lightdm"><a href="#2-安装lightdm" class="headerlink" title="2. 安装lightdm"></a>2. 安装lightdm</h6><p>因为使用的是gnome图形界面，为了保证x11vnc与图形界面的兼容性，这里需要安装lightdm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install lightdm</span><br></pre></td></tr></table></figure>
<p>安装过程中会跳出一个界面，<strong>选择lightdm</strong>即可<br><img src="https://img-blog.csdnimg.cn/20210218145450888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h6 id="3-创建配置目录"><a href="#3-创建配置目录" class="headerlink" title="3. 创建配置目录"></a>3. 创建配置目录</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -pv /home/【USERNAME】/.vnc</span><br></pre></td></tr></table></figure>
<p>其中的<strong>【USERNAME】</strong>替换成你的用户名</p>
<h6 id="4-生成当前用户的VNC连接密码"><a href="#4-生成当前用户的VNC连接密码" class="headerlink" title="4. 生成当前用户的VNC连接密码"></a>4. 生成当前用户的VNC连接密码</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo x11vnc -storepasswd 【Password】 /home/【USERNAME】/.vnc/passwd</span><br></pre></td></tr></table></figure>
<p>其中的<strong>【Password】</strong>处设置连接VNC时的密码，<strong>【USERNAME】</strong>替换成你的用户名<br><img src="https://img-blog.csdnimg.cn/20210219200621716.png" alt="在这里插入图片描述"></p>
<h6 id="5-生成VNC配置文件"><a href="#5-生成VNC配置文件" class="headerlink" title="5. 生成VNC配置文件"></a>5. 生成VNC配置文件</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat&gt;x11vnc.service&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit] </span></span><br><span class="line"><span class="string">Description=Start x11vnc at startup. </span></span><br><span class="line"><span class="string">After=multi-user.target </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">[Service] </span></span><br><span class="line"><span class="string">Type=simple </span></span><br><span class="line"><span class="string">ExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/【USERNAME】/.vnc/passwd -rfbport 5900 -shared </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">[Install] </span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p>配置文件生成后将其移动到<code>/lib/systemd/sydtem/</code>目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv x11vnc.service /lib/systemd/system/x11vnc.service</span><br></pre></td></tr></table></figure>
<p>修改权限为root</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chown root:root /lib/systemd/system/x11vnc.service</span><br></pre></td></tr></table></figure>
<h6 id="6-重新加载服务配置文件"><a href="#6-重新加载服务配置文件" class="headerlink" title="6. 重新加载服务配置文件"></a>6. 重新加载服务配置文件</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<p>执行以下命令可以查看服务开启情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl list-unit-files | grep x11vnc</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210219125503373.png" alt="在这里插入图片描述"></p>
<h6 id="7-开机启动VNC服务"><a href="#7-开机启动VNC服务" class="headerlink" title="7. 开机启动VNC服务"></a>7. 开机启动VNC服务</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> x11vnc.service</span><br></pre></td></tr></table></figure>
<h6 id="8-重启系统"><a href="#8-重启系统" class="headerlink" title="8. 重启系统"></a>8. 重启系统</h6><p>因为之前安装了lightdm图形管理程序，所以需要重启一下系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<h6 id="9-查看一下监听端口"><a href="#9-查看一下监听端口" class="headerlink" title="9. 查看一下监听端口"></a>9. 查看一下监听端口</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ss -tunlp</span><br></pre></td></tr></table></figure>
<p>可以看到x11vnc的监听端口已经打开了<br><img src="https://img-blog.csdnimg.cn/20210218154948830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><p>打开windows端的VNC Viewer，输入IP地址:5900即<code>192.168.6.6:5900</code>进行远程连接，密码是之前设置的密码。<br><img src="https://img-blog.csdnimg.cn/20210218155229939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210218154903345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu20.04安装ROS Noetic</title>
    <url>/2021/02/20/057-Ubuntu20.04%E5%AE%89%E8%A3%85ROS%20Noetic/</url>
    <content><![CDATA[<blockquote>
<p>本文参考ros官网<a href="http://wiki.ros.org/">http://wiki.ros.org/</a>的有关<a href="http://wiki.ros.org/noetic/Installation/Ubuntu">安装教程</a></p>
</blockquote>
<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><h5 id="1-添加ROS软件源"><a href="#1-添加ROS软件源" class="headerlink" title="1. 添加ROS软件源"></a>1. 添加ROS软件源</h5><p>打开软件与更新，将下载选项前四个都选上。<br><strong>一定要确保都勾选上，不然后续安装时会出现依赖关系问题</strong><br><img src="https://img-blog.csdnimg.cn/20210219145021840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后执行以下命令添加软件源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;deb https://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure>
<h5 id="2-添加公钥"><a href="#2-添加公钥" class="headerlink" title="2. 添加公钥"></a>2. 添加公钥</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-key adv --keyserver <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure>
<h5 id="3-更新索引"><a href="#3-更新索引" class="headerlink" title="3. 更新索引"></a>3. 更新索引</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<h3 id="二、安装ROS"><a href="#二、安装ROS" class="headerlink" title="二、安装ROS"></a>二、安装ROS</h3><h5 id="1-安装ROS"><a href="#1-安装ROS" class="headerlink" title="1. 安装ROS"></a>1. 安装ROS</h5><p>建议安装桌面完整版</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ros-noetic-desktop-full</span><br></pre></td></tr></table></figure>
<h5 id="2-设置环境变量"><a href="#2-设置环境变量" class="headerlink" title="2. 设置环境变量"></a>2. 设置环境变量</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h5 id="3-初始化rosdep"><a href="#3-初始化rosdep" class="headerlink" title="3. 初始化rosdep"></a>3. 初始化rosdep</h5><p>在使用许多ROS工具之前，需要初始化rosdep。rosdep是运行ROS中某些核心组件所必需的，首先安装rosdep</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-rosdep</span><br></pre></td></tr></table></figure>
<p>然后进行初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure>
<blockquote>
<p>rosdep init如果出现【ERROR: cannot download default sources list from:…<br>Website may be down.】<br> rosdep update如果出现超时问题<br> 以上两个问题的都可以通过修改host主机解决，只是update的问题在修改主机后，还要求网络必须可靠<br>参考博客：<a href="https://blog.csdn.net/weixin_44543463/article/details/113875658">https://blog.csdn.net/weixin_44543463/article/details/113875658</a></p>
</blockquote>
<h5 id="4-安装其它工具和依赖包"><a href="#4-安装其它工具和依赖包" class="headerlink" title="4. 安装其它工具和依赖包"></a>4. 安装其它工具和依赖包</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential</span><br></pre></td></tr></table></figure>
<h3 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h3><p><strong>打开</strong>终端，输入<code>roscore</code>，运行ros<br><strong>再打开</strong>一个新终端，输入：<code>rosrun turtlesim turtlesim_node</code>，可以看到小乌龟的仿真界面已经打开了。<strong>再打开</strong>一个新终端输入指令：<code>rosrun turtlesim turtle_teleop_key</code>，可以在这个key终端内，通过键盘的方向键控制小乌龟在界面中移动<br><img src="https://img-blog.csdnimg.cn/20210220234744581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS安装时rosdep init与rosdep update问题解决方法（2021.2.20亲测）</title>
    <url>/2021/02/20/058-ROS%E5%AE%89%E8%A3%85%E6%97%B6rosdep%20init%E4%B8%8Erosdep%20update%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%882021.2.20%E4%BA%B2%E6%B5%8B%EF%BC%89/</url>
    <content><![CDATA[<p>ROS安装过程可见我的上一篇博客<a href="https://blog.csdn.net/weixin_44543463/article/details/113862391">Ubuntu20.04安装ROS Noetic</a></p>
<p>安装过程中<strong>rosdep init</strong>出现【<strong>ERROR: cannot download default sources list from:…Website may be down.<strong>】<br><strong>rosdep update</strong>，总是出现</strong>超时</strong>问题无法更新。<br>最终找到了一种靠谱可用的方法。</p>
<p>这两个问题都是网络连接相关的问题，<strong>解决方法相同，都是修改host主机</strong>。</p>
<p>只是修改完成后rosdep init可以直接成功。而rosdep update还需要可靠的网络才行，如果update仍然失败，建议多试几次，或者试着更换手机热点网络</p>
<h5 id="1-打开ip查询网址"><a href="#1-打开ip查询网址" class="headerlink" title="1. 打开ip查询网址"></a>1. 打开ip查询网址</h5><blockquote>
<p><a href="https://site.ip138.com/">https://site.ip138.com</a></p>
</blockquote>
<h5 id="2-输入raw-githubusercontent-com查询ip"><a href="#2-输入raw-githubusercontent-com查询ip" class="headerlink" title="2. 输入raw.githubusercontent.com查询ip"></a>2. 输入raw.githubusercontent.com查询ip</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">raw.githubusercontent.com</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210220080922104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="3-将解析出来的IP地址全部添加到-etc-hosts文件最后，格式：185-199-109-133-raw-githubusercontent-com"><a href="#3-将解析出来的IP地址全部添加到-etc-hosts文件最后，格式：185-199-109-133-raw-githubusercontent-com" class="headerlink" title="3. 将解析出来的IP地址全部添加到/etc/hosts文件最后，格式：185.199.109.133 raw.githubusercontent.com"></a>3. 将解析出来的IP地址全部添加到/etc/hosts文件最后，格式：185.199.109.133 raw.githubusercontent.com</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/hosts</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210220081304582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">  </span><br><span class="line"><span class="comment"># The following lines are desirable for IPv6 capable hosts</span></span><br><span class="line">::1 ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">ff02::3 ip6-allhosts</span><br><span class="line">185.199.109.133 raw.githubusercontent.com</span><br><span class="line">185.199.108.133 raw.githubusercontent.com</span><br><span class="line">185.199.111.133 raw.githubusercontent.com</span><br><span class="line">185.199.110.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure>
<p>保存回到命令行</p>
<h5 id="5-重新进行rosdep-update"><a href="#5-重新进行rosdep-update" class="headerlink" title="5. 重新进行rosdep update"></a>5. 重新进行rosdep update</h5><p><img src="https://img-blog.csdnimg.cn/20210220081443875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>bug解决</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS学习笔记】（一）常用命令的解释与举例</title>
    <url>/2021/02/22/059-%E3%80%90ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A7%A3%E9%87%8A%E4%B8%8E%E4%B8%BE%E4%BE%8B/</url>
    <content><![CDATA[<h5 id="1-roscore"><a href="#1-roscore" class="headerlink" title="1. roscore"></a>1. roscore</h5><p>roscore是用来启动ros master，是运行ros系统前首先运行的命令<br><img src="https://img-blog.csdnimg.cn/20210222165356292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="2-rosrun"><a href="#2-rosrun" class="headerlink" title="2. rosrun"></a>2. rosrun</h5><p>rosrun是用来运行某个功能包内的某个节点的指令，有两个参数，第一个参数是功能包名，第二个参数是节点名</p>
<blockquote>
<p><strong>例：仿真小海龟</strong><br>在一个终端中输入<code>rosrun turtlesim turtlesim_node</code><br>在另一个终端中输入<code>rosrun turtlesim turtle_teleop_key</code><br><img src="https://img-blog.csdnimg.cn/20210222170156550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<h5 id="3-rosnode"><a href="#3-rosnode" class="headerlink" title="3. rosnode"></a>3. rosnode</h5><p>rosnode，用来显示节点相关信息的指令</p>
<ul>
<li>rosnode list用来把系统中所有节点都列出来<br><img src="https://img-blog.csdnimg.cn/20210222170336242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>rosnode info *，查看节点的具体信息，如正在发布哪些话题、提供的服务、等其他信息<br><img src="https://img-blog.csdnimg.cn/20210222170424585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h5 id="4-rostopic"><a href="#4-rostopic" class="headerlink" title="4. rostopic"></a>4. rostopic</h5></li>
<li>rostopic list，输出当前系统中所有话题的列表<br><img src="https://img-blog.csdnimg.cn/20210222170646797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>rostopic pub 【话题名+tab补全】，显示发布的内容<br><img src="https://img-blog.csdnimg.cn/20210222170805535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><blockquote>
<p><strong>例：通过发布话题(rostopic pub)控制小海龟运动</strong><br>输入代码：<code>rostopic pub -r 10 /turtle1/cmd_vel+两次tab补全</code><br>通过修改linear速度和angular角度，可以控制小海龟的运动。其中 -r 10 是话题发布的频率，每秒发布十次。<br><img src="https://img-blog.csdnimg.cn/20210222171247724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<h5 id="5-rosservice"><a href="#5-rosservice" class="headerlink" title="5. rosservice"></a>5. rosservice</h5></li>
<li>roservice list 可以显示ros系统内所有服务的列表（所有服务端都是上面的海龟仿真器）</li>
<li>rosservice call 【服务名称+tab补全】发布请求<blockquote>
<p>例：产生两只海龟（服务列表中/spawn是产生海龟的请求）<br>输入代码：<code>rosservice call /spawn+两次tab补全</code><br>其中x，y是新海龟的坐标（仿真器左下角为原点）<br><img src="https://img-blog.csdnimg.cn/20210222200421680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<h5 id="6-rosbag"><a href="#6-rosbag" class="headerlink" title="6. rosbag"></a>6. rosbag</h5>记录当前系统内所有话题数据，并在下次复现出来。</li>
</ul>
<blockquote>
<p><strong>例：保存小海龟的运动</strong></p>
<ol>
<li>输入命令：<code>rosbag record -a -O cmd_record</code><br>其中record指做记录，-a指记录所有数据，-o指将数据保存成压缩包，最后是保存文件的名字</li>
<li>回到key终端，用键盘方向键控制小海龟进行运动</li>
<li>运动完成后使用<code>ctrl+C</code>中断rosbag record<br><img src="https://img-blog.csdnimg.cn/2021022220190531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
</blockquote>
<blockquote>
<p><strong>例：复现小海龟的运动</strong></p>
<ol>
<li>关掉之前打开的终端，重新打开一个终端，运行<code>roscore</code></li>
<li>再新开一个终端，启动小海龟的仿真：<code>rosrun turtlesim turtlesim_node</code>（这里不需要启动键盘输入）</li>
<li>再新开一个终端，实现小海龟的动作复现：<code>rosbag play cmd_record.bag</code><br><img src="https://img-blog.csdnimg.cn/20210222202635674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
</blockquote>
<p><strong>本文学习内容来自古月居</strong><br>官方论坛：<a href="https://www.guyuehome.com/">https://www.guyuehome.com/</a><br>学习视频：<a href="https://www.bilibili.com/video/BV1zt411G7Vn">https://www.bilibili.com/video/BV1zt411G7Vn</a></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS学习笔记】（二）工作空间与功能包的创建</title>
    <url>/2021/02/23/060-%E3%80%90ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8C%85%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="工作空间的概念"><a href="#工作空间的概念" class="headerlink" title="工作空间的概念"></a>工作空间的概念</h3><p>工作空间是存放工程开发相关文件的文件夹，类似windows中使用ide时创建的工程。</p>
<h3 id="工作空间包括的文件夹"><a href="#工作空间包括的文件夹" class="headerlink" title="工作空间包括的文件夹"></a>工作空间包括的文件夹</h3><ol>
<li>src：代码空间</li>
<li>build：编译空间，编译过程中的中间文件，一般用不到</li>
<li>devel：开发空间，放置开发过程中的可执行文件、库等</li>
<li>install：安装空间<h3 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h3><h5 id="1-创建工作空间"><a href="#1-创建工作空间" class="headerlink" title="1. 创建工作空间"></a>1. 创建工作空间</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure>
<h5 id="2-编译工作空间"><a href="#2-编译工作空间" class="headerlink" title="2. 编译工作空间"></a>2. 编译工作空间</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line">catkin_make install <span class="comment">#产生install文件夹</span></span><br></pre></td></tr></table></figure>
<h5 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3. 设置环境变量"></a>3. 设置环境变量</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure>
<h5 id="4-检查环境变量"><a href="#4-检查环境变量" class="headerlink" title="4. 检查环境变量"></a>4. 检查环境变量</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$ROS_PACKAGE_PATH</span></span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210223134831798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<h3 id="创建功能包"><a href="#创建功能包" class="headerlink" title="创建功能包"></a>创建功能包</h3><p><code>catkin_creat_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]</code></p>
<h5 id="1-创建功能包"><a href="#1-创建功能包" class="headerlink" title="1. 创建功能包"></a>1. 创建功能包</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg test_pkg std_msgs rospy roscpp</span><br></pre></td></tr></table></figure>
<p><em>注：功能包要放在src文件夹下，同一个工作空间不能有同名的功能包</em></p>
<p>创建功能包后，在功能包test_pkg文件夹下有<strong>src、include</strong>文件夹和<strong>package.xml、CMakeLists.txt</strong>文件</p>
<p>(1)src文件夹：放置代码文件<br>(2)include文件夹：放置头文件<br>(3)package.xml：与功能包相关的信息<br>（如名字、版本号、许可证、作者信息、功能包的依赖信息等）<br>(4)CMakeLists.txt：描述功能包的编译规则</p>
<h5 id="2-编译功能包"><a href="#2-编译功能包" class="headerlink" title="2. 编译功能包"></a>2. 编译功能包</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> ~/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210223135458695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS学习笔记】（三）发布者Publisher的实现</title>
    <url>/2021/02/24/061-%E3%80%90ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%91%E5%B8%83%E8%80%85Publisher%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="一、目标功能"><a href="#一、目标功能" class="headerlink" title="一、目标功能"></a>一、目标功能</h3><p>ROS Master内有两个节点，一个是Subscriber(turtlesim)，一个是Publisher，发布者通过程序实现发布Message，Message的内容包括线速度、角度，通过Topic管道，传递给Subscriber，从而控制小海龟的运动。</p>
<h3 id="二、创建功能包"><a href="#二、创建功能包" class="headerlink" title="二、创建功能包"></a>二、创建功能包</h3><p>首先先创建一个工作空间，具体参考上一节<a href="https://blog.csdn.net/weixin_44543463/article/details/113985223">【ROS学习笔记】（二）工作空间与功能包的创建</a></p>
<p>然后创建一个功能包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_topic roscpp rospy std_msgs geometry_msgs turtlesim</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210224213435285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="三、创建发布者代码"><a href="#三、创建发布者代码" class="headerlink" title="三、创建发布者代码"></a>三、创建发布者代码</h3><p>进入功能包的src文件夹下，创建一个cpp文件（也可以在图形界面直接创建）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/catkin_ws/src/learning_topic/src</span><br><span class="line">touch velocity_publisher.cpp</span><br><span class="line">sudo gedit velocity_publisher.cpp</span><br></pre></td></tr></table></figure>

<p>输入以下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twist</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ROS节点初始化</span></span><br><span class="line">	ros::init(argc, argv, <span class="string">&quot;velocity_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建节点句柄</span></span><br><span class="line">	ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span></span><br><span class="line">	ros::Publisher turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置循环的频率</span></span><br><span class="line">	<span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ros::ok())</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">// 初始化geometry_msgs::Twist类型的消息</span></span><br><span class="line">		geometry_msgs::Twist vel_msg;</span><br><span class="line">		vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">		vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 发布消息</span></span><br><span class="line">		turtle_vel_pub.publish(vel_msg);</span><br><span class="line">		ROS_INFO(<span class="string">&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;</span>, </span><br><span class="line">				vel_msg.linear.x, vel_msg.angular.z);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 按照循环频率延时</span></span><br><span class="line">	    loop_rate.sleep();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210224213513448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="四、配置发布者代码编译规则"><a href="#四、配置发布者代码编译规则" class="headerlink" title="四、配置发布者代码编译规则"></a>四、配置发布者代码编译规则</h3><ol>
<li><p>设置需要编译的代码和生成的可执行文件</p>
</li>
<li><p>设置链接库</p>
</li>
</ol>
<p>在<code>Learning_topic/CMakeList.txt</code>文件的Build下方（Install上方），添加代码如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_executable(velocity_publisher src/velocity_publisher.cpp)	<span class="comment">#描述要把哪个程序文件编译成哪个可执行文件</span></span><br><span class="line">target_link_libraries(velocity_publisher <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)	<span class="comment">#把可执行文件和库做链接</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210224213733508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="五、编译并运行发布者Publisher"><a href="#五、编译并运行发布者Publisher" class="headerlink" title="五、编译并运行发布者Publisher"></a>五、编译并运行发布者Publisher</h3><h5 id="1-编译"><a href="#1-编译" class="headerlink" title="1. 编译"></a>1. 编译</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在<code>~/.bashrc</code>文件最后添加source语句，这样就不用每次再在终端输入source命令创建环境变量（路径中替换成自己的用户名）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /home/【Username】/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210224213913493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="2-运行"><a href="#2-运行" class="headerlink" title="2. 运行"></a>2. 运行</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_topic velocity_publisher</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210224214729896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>参考教程：<strong>古月ROS入门21讲</strong><br>GitHub：<a href="https://github.com/guyuehome/ros_21_tutorials">https://github.com/guyuehome/ros_21_tutorials</a><br>Bilibili：<a href="https://www.bilibili.com/video/BV1zt411G7Vn">https://www.bilibili.com/video/BV1zt411G7Vn</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS学习笔记】（四）订阅者Subscriber的实现</title>
    <url>/2021/02/24/062-%E3%80%90ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E5%9B%9B%EF%BC%89%E8%AE%A2%E9%98%85%E8%80%85Subscriber%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="一、目标功能"><a href="#一、目标功能" class="headerlink" title="一、目标功能"></a>一、目标功能</h3><p>订阅者订阅海龟的位姿信息。</p>
<h3 id="二、创建功能包"><a href="#二、创建功能包" class="headerlink" title="二、创建功能包"></a>二、创建功能包</h3><p>首先创建工作空间，参考<a href="https://blog.csdn.net/weixin_44543463/article/details/113985223">【ROS学习笔记】（二）工作空间与功能包的创建</a></p>
<p>然后创建一个功能包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_creat_pkg learning_topic roscpp rospy std_msgs geometry_msgs turtlesim</span><br></pre></td></tr></table></figure>

<h3 id="三、创建订阅者代码"><a href="#三、创建订阅者代码" class="headerlink" title="三、创建订阅者代码"></a>三、创建订阅者代码</h3><p>进入功能包的src文件夹下，创建一个cpp文件（也可以在图形界面直接创建）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/catkin_ws/src/learning_topic/src</span><br><span class="line">touch pose_subscriber.cpp</span><br><span class="line">sudo gedit pose_subscriber.cpp</span><br></pre></td></tr></table></figure>

<p>输入以下代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">Copyright 2020 GuYueHome (www.guyuehome.com).</span><br><span class="line">***********************************************************************/</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"><span class="comment">#include &lt;ros/ros.h&gt;</span></span><br><span class="line"><span class="comment">#include &quot;turtlesim/Pose.h&quot;</span></span><br><span class="line"></span><br><span class="line">// 接收到订阅的消息后，会进入消息回调函数</span><br><span class="line">void poseCallback(const turtlesim::Pose::ConstPtr&amp; msg)</span><br><span class="line">&#123;</span><br><span class="line">    // 将接收到的消息打印出来</span><br><span class="line">    ROS_INFO(<span class="string">&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;</span>, msg-&gt;x, msg-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化ROS节点</span><br><span class="line">    ros::init(argc, argv, <span class="string">&quot;pose_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    // 创建节点句柄</span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    // 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback</span><br><span class="line">    ros::Subscriber pose_sub = n.subscribe(<span class="string">&quot;/turtle1/pose&quot;</span>, 10, poseCallback);</span><br><span class="line"></span><br><span class="line">    // 循环等待回调函数</span><br><span class="line">    ros::spin();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码思路：</p>
<ol>
<li>初始化ROS节点</li>
<li>订阅需要的话题</li>
<li>循环等待话题消息，接收到消息后进入回调函数</li>
<li>在回调函数中完成消息处理<br><img src="https://img-blog.csdnimg.cn/20210224221639124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<h3 id="四、配置订阅者代码编译规则"><a href="#四、配置订阅者代码编译规则" class="headerlink" title="四、配置订阅者代码编译规则"></a>四、配置订阅者代码编译规则</h3><ol>
<li><p>设置需要编译的代码和生成的可执行文件</p>
</li>
<li><p>设置链接库</p>
</li>
</ol>
<p>在<code>Learning_topic/CMakeList.txt</code>文件的Build下方（Install上方），添加代码如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_executable(pose_subscriber src/pose_subscriber.cpp)		<span class="comment">#描述要把哪个程序文件编译成哪个可执行文件</span></span><br><span class="line">target_link_libraries(pose_subscriber <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)	<span class="comment">#把可执行文件和库做链接</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210224221910627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="五、编译并运行订阅者SubScriber"><a href="#五、编译并运行订阅者SubScriber" class="headerlink" title="五、编译并运行订阅者SubScriber"></a>五、编译并运行订阅者SubScriber</h3><h5 id="1-编译"><a href="#1-编译" class="headerlink" title="1. 编译"></a>1. 编译</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在[.bash]文件最后添加source语句，这样就不用每次再在终端输入source命令</p>
<p>sudo vim ~/catkin_ws<br>source /home/huffie/catkin_ws/devel/setup.bash</p>
</blockquote>
<h5 id="2-运行"><a href="#2-运行" class="headerlink" title="2. 运行"></a>2. 运行</h5><p>打开小海龟的仿真程序，运行subscriber，同时让小海龟动起来，可以看到姿态坐标在实时改变。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_topic pose_subscriber</span><br><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2021022422230869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS学习笔记】（五）话题消息的定义与使用</title>
    <url>/2021/02/25/063-%E3%80%90ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E4%BA%94%EF%BC%89%E8%AF%9D%E9%A2%98%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h3><p>在ROS Master中，可以发布与订阅已经定义好的消息，比如海龟的运动、位姿等信息。但有时我们需要自己定义消息的类型。</p>
<p>本节主要目的为定义一个Person个人信息，Publisher发布个人信息，Subscriber订阅个人信息。</p>
<h3 id="二、自定义话题消息"><a href="#二、自定义话题消息" class="headerlink" title="二、自定义话题消息"></a>二、自定义话题消息</h3><h5 id="1-定义msg文件"><a href="#1-定义msg文件" class="headerlink" title="1. 定义msg文件"></a>1. 定义msg文件</h5><p>在功能包<code>learning_topic</code>文件夹中新建一个文件夹<code>msg</code>，在此文件夹内创建一个<code>Person.msg</code>文件，在其中添加以下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name</span><br><span class="line">uint8 sex</span><br><span class="line">uint8 age</span><br><span class="line"></span><br><span class="line">uint8 unknown=<span class="number">0</span></span><br><span class="line">uint8 male=<span class="number">1</span></span><br><span class="line">uint8 female=<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>注：<code>uint8</code>和<code>string</code>，在不同程序里面需要扩展成对应的格式，因此需要先进行一些配置。<br><img src="https://img-blog.csdnimg.cn/20210225230828509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="2-在package-xml文件中添加功能包依赖"><a href="#2-在package-xml文件中添加功能包依赖" class="headerlink" title="2. 在package.xml文件中添加功能包依赖"></a>2. 在package.xml文件中添加功能包依赖</h5><p>在文件末尾部分，添加如下代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>build_depend，编译依赖，依赖一个动态产生message的功能包</p>
<p>exec_depend，执行依赖， 依赖message运行时间的功能包<br><img src="https://img-blog.csdnimg.cn/20210225230941832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="3-在CMakeLists-txt添加编译选项"><a href="#3-在CMakeLists-txt添加编译选项" class="headerlink" title="3. 在CMakeLists.txt添加编译选项"></a>3. 在CMakeLists.txt添加编译选项</h5><p>首先在<code>find_package</code>内添加一条语句，用以添加依赖的功能包</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  geometry_msgs</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  turtlesim</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210225231105190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在此函数下面再添加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_message_files</span>(</span><br><span class="line">  FILES</span><br><span class="line">  Person.msg</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">generate_messages</span>(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>add_message_files，将Person.msg作为定义的接口</p>
<p>generate_messages，在编译Person.msg文件时需要依赖的功能包<br><img src="https://img-blog.csdnimg.cn/20210225231200743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>然后在下方<code>catkin specific configuration</code>内的<code>catkin_packages</code>中，添加依赖<code>message_runtime</code>，修改后的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">catkin_package</span>(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES learning_topic</span><br><span class="line">   CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2021022523125917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="4-编译生成相关文件"><a href="#4-编译生成相关文件" class="headerlink" title="4. 编译生成相关文件"></a>4. 编译生成相关文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>

<h3 id="三、创建发布者"><a href="#三、创建发布者" class="headerlink" title="三、创建发布者"></a>三、创建发布者</h3><p>在<code>~/catkin_ws/src/learning_topic/src</code>文件夹下创建<code>person_publisher.cpp</code>文件，内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将发布/person_info话题，自定义消息类型learning_topic::Person</span></span><br><span class="line"><span class="comment"> REFERENC:www.guyuehome.com.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_topic/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10</span></span><br><span class="line">    ros::Publisher person_info_pub = n.advertise&lt;learning_topic::Person&gt;(<span class="string">&quot;/person_info&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置循环的频率</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化learning_topic::Person类型的消息</span></span><br><span class="line">    	learning_topic::Person person_msg;</span><br><span class="line">		person_msg.name = <span class="string">&quot;huffie&quot;</span>;</span><br><span class="line">		person_msg.age  = <span class="number">21</span>;</span><br><span class="line">		person_msg.sex  = learning_topic::Person::male;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">		person_info_pub.<span class="built_in">publish</span>(person_msg);</span><br><span class="line"></span><br><span class="line">       	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publish Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line">				  person_msg.name.<span class="built_in">c_str</span>(), person_msg.age, person_msg.sex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照循环频率延时</span></span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、创建订阅者"><a href="#四、创建订阅者" class="headerlink" title="四、创建订阅者"></a>四、创建订阅者</h3><p>在<code>~/catkin_ws/src/learning_topic/src</code>文件夹下创建<code>person_subscriber.cpp</code>文件，内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person</span></span><br><span class="line"><span class="comment"> REFERENC:www.guyuehome.com.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_topic/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">personInfoCallback</span><span class="params">(<span class="keyword">const</span> learning_topic::Person::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将接收到的消息打印出来</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Subcribe Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line">			 msg-&gt;name.<span class="built_in">c_str</span>(), msg-&gt;age, msg-&gt;sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback</span></span><br><span class="line">    ros::Subscriber person_info_sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;/person_info&quot;</span>, <span class="number">10</span>, personInfoCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2021022523161842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="五、配置发布者-订阅者代码编译规则"><a href="#五、配置发布者-订阅者代码编译规则" class="headerlink" title="五、配置发布者/订阅者代码编译规则"></a>五、配置发布者/订阅者代码编译规则</h3><p>在<code>CMakeLists.txt</code>文件的<code>build</code>区域内添加如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(person_publisher src/person_publisher.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(person_publisher $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"><span class="built_in">add_dependencies</span>(person_publisher $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(person_subscriber src/person_subscriber.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(person_subscriber $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"><span class="built_in">add_dependencies</span>(person_subscriber $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210225231750694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="六、编译与运行"><a href="#六、编译与运行" class="headerlink" title="六、编译与运行"></a>六、编译与运行</h3><p>首先进行编译，回到主目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>

<p>运行roscore</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>

<p>运行订阅者Subscriber</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun learning_topic person_subscriber</span><br></pre></td></tr></table></figure>

<p>运行发布者Publisher</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun learning_topic person_Publisher</span><br></pre></td></tr></table></figure>

<p>可以看到发布者在发布个人信息，订阅者在接受信息。<br><img src="https://img-blog.csdnimg.cn/20210225232005379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS学习笔记】（六）客户端Client的编程实现</title>
    <url>/2021/02/26/064-%E3%80%90ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E5%85%AD%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AFClient%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h3><p>通过程序，发布服务请求。</p>
<p>即通过客户端的请求，发给服务端产生一个海龟，反馈回客户端。</p>
<h3 id="二、创建功能包"><a href="#二、创建功能包" class="headerlink" title="二、创建功能包"></a>二、创建功能包</h3><p>回到<code>catkin_ws/src</code>文件夹下，创建一个名为<code>learning_service</code>的功能包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_service roscpp rospy std_msgs geometry_msgs turtlesim</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210226163117850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="三、创建客户端代码"><a href="#三、创建客户端代码" class="headerlink" title="三、创建客户端代码"></a>三、创建客户端代码</h3><p>在<code>~/catkin_ws/src/learning_service/src</code>目录下创建一个<code>turtle_spawn.cpp</code>的文件，其内容为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将请求/spawn服务，服务数据类型turtlesim::Spawn</span></span><br><span class="line"><span class="comment"> REFERENC:www.guyuehome.com.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">	ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化turtlesim::Spawn的请求数据</span></span><br><span class="line">	turtlesim::Spawn srv;</span><br><span class="line">	srv.request.x = <span class="number">2.0</span>;</span><br><span class="line">	srv.request.y = <span class="number">2.0</span>;</span><br><span class="line">	srv.request.name = <span class="string">&quot;turtle2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to spawn turtle[x:%0.6f, y:%0.6f, name:%s]&quot;</span>, srv.request.x, srv.request.y, srv.request.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示服务调用结果</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Spawn turtle successfully [name:%s]&quot;</span>, srv.response.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码👆的实现过程如下：</p>
<ol>
<li>初始化ROS节点</li>
<li>创建一个Client实例</li>
<li>发布服务请求数据</li>
<li>等待Server处理之后的应答结果<br><img src="https://img-blog.csdnimg.cn/20210226163345363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<h3 id="四、配置客户端代码编译规则"><a href="#四、配置客户端代码编译规则" class="headerlink" title="四、配置客户端代码编译规则"></a>四、配置客户端代码编译规则</h3><p>打开<code>learning_service</code>中的<code>CMakeLists.txt</code>，在图示区域添加代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_executable(turtle_spawn src/turtle_spawn.cpp)</span><br><span class="line">target_link_libraries(turtle_spawn <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>add_executable添加编译规则，target_link_libraries链接一些需要的库<br><img src="https://img-blog.csdnimg.cn/20210226163551809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="五、编译与运行"><a href="#五、编译与运行" class="headerlink" title="五、编译与运行"></a>五、编译与运行</h3><p>进行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210226163652374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>运行客户端，可以看到产生了第二个小海龟</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_service turtle_spawn</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2021022616385125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS学习笔记】（七）服务端Server的实现</title>
    <url>/2021/02/26/065-%E3%80%90ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E4%B8%83%EF%BC%89%E6%9C%8D%E5%8A%A1%E7%AB%AFServer%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h3><p>Server端等待信号，每次接收到Client端的信号，海龟的运动状态就切换一次（运动→停止、停止→运动）</p>
<h3 id="二、创建服务器代码"><a href="#二、创建服务器代码" class="headerlink" title="二、创建服务器代码"></a>二、创建服务器代码</h3><p>在<code>~/catkin_ws/src/learning_service/src</code>目录下创建一个<code>turtle_command_server.cpp</code>的文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将执行/turtle_command服务，服务数据类型std_srvs/Trigger</span></span><br><span class="line"><span class="comment"> REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;std_srvs/Trigger.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ros::Publisher turtle_vel_pub;</span><br><span class="line"><span class="keyword">bool</span> pubCommand = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">commandCallback</span><span class="params">(std_srvs::Trigger::Request  &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">         			std_srvs::Trigger::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pubCommand = !pubCommand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示请求数据</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publish turtle velocity command [%s]&quot;</span>, pubCommand==<span class="literal">true</span>?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置反馈数据</span></span><br><span class="line">	res.success = <span class="literal">true</span>;</span><br><span class="line">	res.message = <span class="string">&quot;Change turtle command state!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_command_server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为/turtle_command的server，注册回调函数commandCallback</span></span><br><span class="line">    ros::ServiceServer command_service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/turtle_command&quot;</span>, commandCallback);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span></span><br><span class="line">	turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to receive turtle command.&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置循环的频率</span></span><br><span class="line">	<span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 查看一次回调函数队列</span></span><br><span class="line">    	ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果标志为true，则发布速度指令</span></span><br><span class="line">		<span class="keyword">if</span>(pubCommand)</span><br><span class="line">		&#123;</span><br><span class="line">			geometry_msgs::Twist vel_msg;</span><br><span class="line">			vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">			vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line">			turtle_vel_pub.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//按照循环频率延时</span></span><br><span class="line">	    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现过程：</p>
<ol>
<li>初始化ROS节点</li>
<li>创建Server实例</li>
<li>循环等待服务请求，进入回调函数</li>
<li>在回调函数中完成服务功能的处理，并反馈应答数据<br><img src="https://img-blog.csdnimg.cn/20210226164237476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<h3 id="三、配置服务器代码编译规则"><a href="#三、配置服务器代码编译规则" class="headerlink" title="三、配置服务器代码编译规则"></a>三、配置服务器代码编译规则</h3><p>打开<code>learning_service</code>中的<code>CMakeLists.txt</code>，在图示区域添加代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(turtle_command_server src/turtle_command_server.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(turtle_command_server $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure>

<p>把turtle_command_server.cpp编译成turtle_command_server文件，同时去链接需要依赖的库文件。<br><img src="https://img-blog.csdnimg.cn/20210226164340627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="四、编译并运行"><a href="#四、编译并运行" class="headerlink" title="四、编译并运行"></a>四、编译并运行</h3><p>编译服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">cadkin_make</span><br></pre></td></tr></table></figure>

<p>生效环境变量（如果已经在<code>.bashrc</code>中<a href="https://blog.csdn.net/weixin_44543463/article/details/113985223">添加了环境变量</a>则不需要再执行此步）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure>

<p>再运行以下代码（以下三行需要各自启动一个终端）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_service turtle_command_server</span><br></pre></td></tr></table></figure>

<p>再启动一个终端，输入代码<code>rosservice call /turtle_command+空格+两次Tab</code>发送信号，海龟开始运动，<strong>再次发送同样的信号</strong>，小海龟停止。</p>
<p><img src="https://img-blog.csdnimg.cn/20210226164637534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS学习笔记】（八）服务数据的定义与使用</title>
    <url>/2021/02/28/066-%E3%80%90ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E5%85%AB%EF%BC%89%E6%9C%8D%E5%8A%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h3><p>Client每Request一次数据请求，Server发送一次数据。数据格式为个人信息，如姓名、性别等。</p>
<h3 id="二、自定义服务数据"><a href="#二、自定义服务数据" class="headerlink" title="二、自定义服务数据"></a>二、自定义服务数据</h3><p>此步骤与<a href="https://blog.csdn.net/weixin_44543463/article/details/114108345">话题消息的定义与使用</a>过程类似</p>
<h5 id="1-定义srv文件"><a href="#1-定义srv文件" class="headerlink" title="1. 定义srv文件"></a>1. 定义srv文件</h5><p>再<code>learning_service</code>文件夹下新建一个文件夹<code>srv</code>，再在<code>srv</code>文件夹内新建一个<code>Person.srv</code>文件，内容如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string name</span><br><span class="line">uint8  age</span><br><span class="line">uint8  sex</span><br><span class="line"></span><br><span class="line">uint8 unknown = <span class="number">0</span></span><br><span class="line">uint8 male    = <span class="number">1</span></span><br><span class="line">uint8 female  = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">string result</span><br></pre></td></tr></table></figure>

<p>—以上是request的数据，—以下是response的数据<br><img src="https://img-blog.csdnimg.cn/20210226165019544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="2-在package-xml中添加功能包依赖"><a href="#2-在package-xml中添加功能包依赖" class="headerlink" title="2. 在package.xml中添加功能包依赖"></a>2. 在package.xml中添加功能包依赖</h5><p>打开<code>learning_service/package.xml</code>，在文件最后部分添加如下代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210226165101181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="3-在CMakeLists-txt中添加编译选项"><a href="#3-在CMakeLists-txt中添加编译选项" class="headerlink" title="3. 在CMakeLists.txt中添加编译选项"></a>3. 在CMakeLists.txt中添加编译选项</h5><p>首先在<code>find_package</code>最后一行添加一条语句<code>message_generation</code>，用以添加依赖的功能包</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  geometry_msgs</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  turtlesim</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210226165232230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在此函数下面再添加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_service_files</span>(</span><br><span class="line">  FILES</span><br><span class="line">  Person.srv</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">generate_messages</span>(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>add_message_files，将Person.srv作为定义的接口</p>
<p>generate_messages，在编译Person.srv文件时需要依赖的功能包<br><img src="https://img-blog.csdnimg.cn/20210226170000400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>然后在下方<code>catkin specific configuration</code>内的<code>catkin_packages</code>中，添加依赖<code>message_runtime</code>，修改后的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">catkin_package</span>(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES learning_topic</span><br><span class="line">   CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210226165520183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="4-编译生成相关文件"><a href="#4-编译生成相关文件" class="headerlink" title="4. 编译生成相关文件"></a>4. 编译生成相关文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>

<h3 id="三、创建服务器代码"><a href="#三、创建服务器代码" class="headerlink" title="三、创建服务器代码"></a>三、创建服务器代码</h3><p>在<code>~/catkin_ws/src/learning_service/src</code>目录下创建一个person_server.cpp`的文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将执行/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"><span class="comment">REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_service/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">personCallback</span><span class="params">(learning_service::Person::Request  &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">         			learning_service::Person::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 显示请求数据</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Person: name:%s  age:%d  sex:%d&quot;</span>, req.name.<span class="built_in">c_str</span>(), req.age, req.sex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置反馈数据</span></span><br><span class="line">	res.result = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为/show_person的server，注册回调函数personCallback</span></span><br><span class="line">    ros::ServiceServer person_service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/show_person&quot;</span>, personCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to show person informtion.&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、创建客户端代码"><a href="#四、创建客户端代码" class="headerlink" title="四、创建客户端代码"></a>四、创建客户端代码</h3><p>同样在<code>~/catkin_ws/src/learning_service/src</code>目录下创建一个<code>person_client.cpp</code>的文件，其内容为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将请求/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"><span class="comment">REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_service/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_client&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/show_person&quot;</span>);</span><br><span class="line">	ros::ServiceClient person_client = node.serviceClient&lt;learning_service::Person&gt;(<span class="string">&quot;/show_person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化learning_service::Person的请求数据</span></span><br><span class="line">	learning_service::Person srv;</span><br><span class="line">	srv.request.name = <span class="string">&quot;Huffie&quot;</span>;</span><br><span class="line">	srv.request.age  = <span class="number">21</span>;</span><br><span class="line">	srv.request.sex  = learning_service::Person::Request::male;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to show person[name:%s, age:%d, sex:%d]&quot;</span>, </span><br><span class="line">			 srv.request.name.<span class="built_in">c_str</span>(), srv.request.age, srv.request.sex);</span><br><span class="line"></span><br><span class="line">	person_client.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示服务调用结果</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Show person result : %s&quot;</span>, srv.response.result.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210226170154807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="五、配置服务器-客户端代码编译规则"><a href="#五、配置服务器-客户端代码编译规则" class="headerlink" title="五、配置服务器/客户端代码编译规则"></a>五、配置服务器/客户端代码编译规则</h3><p>打开<code>learning_service</code>中的<code>CMakeLists.txt</code>，在图示区域添加代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(person_server src/person_server.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(person_server $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"><span class="built_in">add_dependencies</span>(person_server $&#123;PROJECT_NAME&#125;_gencpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(person_client src/person_client.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(person_client $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"><span class="built_in">add_dependencies</span>(person_client $&#123;PROJECT_NAME&#125;_gencpp)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210226170247867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="六、编译并运行发布者和订阅者"><a href="#六、编译并运行发布者和订阅者" class="headerlink" title="六、编译并运行发布者和订阅者"></a>六、编译并运行发布者和订阅者</h3><p>首先进行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>

<p>运行发布者和订阅者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun learning_service person_server</span><br><span class="line">rosrun learning_service person_client</span><br></pre></td></tr></table></figure>

<p>client每请求一次，会接受到一次数据<br><img src="https://img-blog.csdnimg.cn/20210226170849300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS学习笔记】（九）参数的使用与编程方法</title>
    <url>/2021/02/28/067-%E3%80%90ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E4%B9%9D%EF%BC%89%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="一、参数模型"><a href="#一、参数模型" class="headerlink" title="一、参数模型"></a>一、参数模型</h3><p>在ROS Master中有一个Parameter Server参数服务器，它是一个全局字典，用来保存各种配置参数，配置参数是各个节点都可以全局访问的。</p>
<h3 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h3><h5 id="1-列出当前所有参数"><a href="#1-列出当前所有参数" class="headerlink" title="1. 列出当前所有参数"></a>1. 列出当前所有参数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam list</span><br></pre></td></tr></table></figure>

<h5 id="2-显示某个参数值"><a href="#2-显示某个参数值" class="headerlink" title="2. 显示某个参数值"></a>2. 显示某个参数值</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam get param_key</span><br></pre></td></tr></table></figure>

<h5 id="3-设置某个参数值"><a href="#3-设置某个参数值" class="headerlink" title="3. 设置某个参数值"></a>3. 设置某个参数值</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam <span class="built_in">set</span> param_key param_value</span><br></pre></td></tr></table></figure>

<h5 id="4-保存参数到文件"><a href="#4-保存参数到文件" class="headerlink" title="4. 保存参数到文件"></a>4. 保存参数到文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam dump file_name</span><br></pre></td></tr></table></figure>

<h5 id="5-从文件读取参数"><a href="#5-从文件读取参数" class="headerlink" title="5. 从文件读取参数"></a>5. 从文件读取参数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam load file_name</span><br></pre></td></tr></table></figure>

<h5 id="6-删除参数"><a href="#6-删除参数" class="headerlink" title="6. 删除参数"></a>6. 删除参数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam delete param_key</span><br></pre></td></tr></table></figure>



<h3 id="三、举例"><a href="#三、举例" class="headerlink" title="三、举例"></a>三、举例</h3><h5 id="1-创建功能包"><a href="#1-创建功能包" class="headerlink" title="1. 创建功能包"></a>1. 创建功能包</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_parameter roscpp rospy std_srvs</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210228114900638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="2-打开小海龟仿真器"><a href="#2-打开小海龟仿真器" class="headerlink" title="2. 打开小海龟仿真器"></a>2. 打开小海龟仿真器</h5><p>打开一个终端，启动roscore：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>

<p>再打开一个终端，运行小海龟仿真程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210228115043902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="3-rosparam命令行的使用"><a href="#3-rosparam命令行的使用" class="headerlink" title="3. rosparam命令行的使用"></a>3. rosparam命令行的使用</h5><p>（1）查看参数列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam list</span><br></pre></td></tr></table></figure>

<p>（2）得到变量的值：背景颜色RGB的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam get /turtlesim/background_r</span><br><span class="line">rosparam get /turtlesim/background_g</span><br><span class="line">rosparam get /turtlesim/background_b</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210228115150535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（3）修改变量的值：更改背景颜色</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam <span class="built_in">set</span> /turtlesim/background_b 100</span><br></pre></td></tr></table></figure>

<p>重新发送请求，刷新背景颜色</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosservice call /clear <span class="string">&quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210228115342345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（4）保存参数到文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam dump param.yaml</span><br></pre></td></tr></table></figure>

<p>参数默认保存到当前目录<br><img src="https://img-blog.csdnimg.cn/20210228115456129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（5）加载参数文件</p>
<p>打开刚刚保存的参数文件，对其中的参数值进行修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam load param.yaml</span><br></pre></td></tr></table></figure>

<p>即可将文件里面的参数内容修改系统内的参数。<br><img src="https://img-blog.csdnimg.cn/20210228115605352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（6）删除参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam delete /turtlesim/background_g</span><br></pre></td></tr></table></figure>


<p>查看参数列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam list</span><br></pre></td></tr></table></figure>

<p>刷新小海龟仿真器背景颜色</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosservice call /clear <span class="string">&quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210228115700341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="四、通过程序获取、设置参数的值"><a href="#四、通过程序获取、设置参数的值" class="headerlink" title="四、通过程序获取、设置参数的值"></a>四、通过程序获取、设置参数的值</h3><h5 id="1-编写cpp程序"><a href="#1-编写cpp程序" class="headerlink" title="1. 编写cpp程序"></a>1. 编写cpp程序</h5><p>在learning_parameter/src/目录下创建一个<code>parameter_config.cpp</code>的文件</p>
<p>其内容为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程设置/读取海龟例程中的参数</span></span><br><span class="line"><span class="comment"> * REFERENCE：www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;std_srvs/Empty.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> red, green, blue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;parameter_config&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, red);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, green);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置背景颜色参数</span></span><br><span class="line">	ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, <span class="number">255</span>);</span><br><span class="line">	ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, <span class="number">255</span>);</span><br><span class="line">	ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Set Backgroud Color[255, 255, 255]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, red);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, green);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Re-get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用服务，刷新背景颜色</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">	ros::ServiceClient clear_background = node.serviceClient&lt;std_srvs::Empty&gt;(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">	std_srvs::Empty srv;</span><br><span class="line">	clear_background.<span class="built_in">call</span>(srv);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2021022812030035.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="2-编译程序"><a href="#2-编译程序" class="headerlink" title="2. 编译程序"></a>2. 编译程序</h5><p>打开<code>learning_parameter/</code>下的<code>CMakeList.txt</code>文件，在其中添加编译规则。(install上方)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(parameter_config src/parameter_config.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(parameter_config $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210228120350415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>进行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>

<h5 id="3-运行程序"><a href="#3-运行程序" class="headerlink" title="3. 运行程序"></a>3. 运行程序</h5><p>运行roscore</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>

<p>运行小海龟仿真程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure>

<p>运行刚才编写的节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun learning_parameter parameter_config</span><br></pre></td></tr></table></figure>

<p>发现小海龟的颜色被改变了，说明程序执行成功<br><img src="https://img-blog.csdnimg.cn/20210228120544142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS学习笔记】（十）ROS中的坐标系管理系统</title>
    <url>/2021/03/01/068-%E3%80%90ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E5%8D%81%EF%BC%89ROS%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="一、机器人中的坐标变换"><a href="#一、机器人中的坐标变换" class="headerlink" title="一、机器人中的坐标变换"></a>一、机器人中的坐标变换</h3><p>TF功能包用来管理所有的坐标系。它可以记录十秒钟之内所有坐标系之间的关系，可以展示夹取的物体相对于机器人中心坐标系的位置在哪里。</p>
<h3 id="二、举例：小海龟跟随实验"><a href="#二、举例：小海龟跟随实验" class="headerlink" title="二、举例：小海龟跟随实验"></a>二、举例：小海龟跟随实验</h3><h5 id="1-小海龟跟随"><a href="#1-小海龟跟随" class="headerlink" title="1. 小海龟跟随"></a>1. 小海龟跟随</h5><p>两只海龟出现之后，一只海龟在中心点，另一只海龟出现在下方，可以控制中心的海龟进行运动，下方的海龟会自动跟随我们控制的海龟进行运动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ros-noetic-turtle-tf</span><br><span class="line">roslaunch turtle_tf turtle_tf_demo.launch</span><br><span class="line"><span class="comment">#rosrun turtlesim turtle_teleop_key</span></span><br></pre></td></tr></table></figure>
<p>其中roslaunch用来启动脚本文件，启动其中的很多节点<br>其中的noetic为ROS版本号</p>
<p>在terminal中按方向键即可控制被跟随的乌龟。<br><img src="https://img-blog.csdnimg.cn/20210301150223793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>如果ubuntu20.04 noetic版本出现报错可以参考下面的方法解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/bin</span><br><span class="line">sudo rm -r python		# 有的可能没有这个文件，就省略这一步</span><br><span class="line">sudo cp python3 python</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="2-查看tf关系"><a href="#2-查看tf关系" class="headerlink" title="2. 查看tf关系"></a>2. 查看tf关系</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun tf view_frames</span><br></pre></td></tr></table></figure>

<p>等待5秒，生成一个pdf文件，打开可以看到当前系统中tf坐标的位置关系。<br><img src="https://img-blog.csdnimg.cn/20210301151603341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>其中world是全局坐标系，另外的turtle1和turtle2是两只海龟上的坐标系。例程的目的是使两个坐标系在坐标上是重叠的。</p>
<blockquote>
<p>此步如果出错则需要执行修改报错的文件<br><code>sudo gedit /opt/ros/noetic/lib/tf/view_frames </code><br>在第88行<code>print(vstr)</code>上方添加一句<code>vstr=str(vstr)</code>就可以了</p>
</blockquote>
<h5 id="3-tf-echo坐标关系"><a href="#3-tf-echo坐标关系" class="headerlink" title="3. tf_echo坐标关系"></a>3. tf_echo坐标关系</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun tf tf_echo turtle1 turtle2</span><br></pre></td></tr></table></figure>

<p>输出两个坐标系之间的关系，描述turtle2坐标系如何变换到turtle1坐标系。包括Translation平移和Rotation旋转（四元数、弧度、角度三种方式描述旋转）。<br><img src="https://img-blog.csdnimg.cn/20210301151641849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="4-rviz三维可视化显示平台"><a href="#4-rviz三维可视化显示平台" class="headerlink" title="4. rviz三维可视化显示平台"></a>4. rviz三维可视化显示平台</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun rviz rviz -d <span class="string">&#x27;rospack find turtle_tf&#x27;</span> /rviz/turtle_rviz.rviz</span><br></pre></td></tr></table></figure>

<p>首先将左侧Fixed Frame改成world</p>
<p>点击左下方Add，添加一个TF，用来显示TF位置关系<br><img src="https://img-blog.csdnimg.cn/20210301152021546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>控制海龟运动，可以看到图中两个坐标系在运动<br><img src="https://img-blog.csdnimg.cn/20210301152153434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="三、TF坐标系广播与监听的编程实现"><a href="#三、TF坐标系广播与监听的编程实现" class="headerlink" title="三、TF坐标系广播与监听的编程实现"></a>三、TF坐标系广播与监听的编程实现</h3><h5 id="1-创建功能包"><a href="#1-创建功能包" class="headerlink" title="1. 创建功能包"></a>1. 创建功能包</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_tf roscpp rospy tf turtlesim</span><br></pre></td></tr></table></figure>

<h5 id="2-创建tf广播器代码"><a href="#2-创建tf广播器代码" class="headerlink" title="2. 创建tf广播器代码"></a>2. 创建tf广播器代码</h5><p>打开<code>learning_tf/src/</code>目录，在其中创建一个<code>turtle_tf_broadcaster.cpp</code></p>
<p>其内容为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程产生tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> * REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/transform_broadcaster.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Pose.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string turtle_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poseCallback</span><span class="params">(<span class="keyword">const</span> turtlesim::PoseConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建tf的广播器</span></span><br><span class="line">	<span class="keyword">static</span> tf::TransformBroadcaster br;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化tf数据</span></span><br><span class="line">	tf::Transform transform;</span><br><span class="line">	transform.<span class="built_in">setOrigin</span>( tf::<span class="built_in">Vector3</span>(msg-&gt;x, msg-&gt;y, <span class="number">0.0</span>) );</span><br><span class="line">	tf::Quaternion q;</span><br><span class="line">	q.<span class="built_in">setRPY</span>(<span class="number">0</span>, <span class="number">0</span>, msg-&gt;theta);</span><br><span class="line">	transform.<span class="built_in">setRotation</span>(q);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 广播world与海龟坐标系之间的tf数据</span></span><br><span class="line">	br.<span class="built_in">sendTransform</span>(tf::<span class="built_in">StampedTransform</span>(transform, ros::Time::<span class="built_in">now</span>(), <span class="string">&quot;world&quot;</span>, turtle_name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_broadcaster&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输入参数作为海龟的名字</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ROS_ERROR</span>(<span class="string">&quot;need turtle name as argument&quot;</span>); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	turtle_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 订阅海龟的位姿话题</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line">	ros::Subscriber sub = node.<span class="built_in">subscribe</span>(turtle_name+<span class="string">&quot;/pose&quot;</span>, <span class="number">10</span>, &amp;poseCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">	ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-创建监听器listener代码"><a href="#3-创建监听器listener代码" class="headerlink" title="3. 创建监听器listener代码"></a>3. 创建监听器listener代码</h5><p>同样的，再创建一个<code>turtle_tf_listener.cpp</code>，其内容为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程监听tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> * REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/transform_listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_listener&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 请求产生turtle2</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">	ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">	turtlesim::Spawn srv;</span><br><span class="line">	add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建发布turtle2速度控制指令的发布者</span></span><br><span class="line">	ros::Publisher turtle_vel = node.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle2/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建tf的监听器</span></span><br><span class="line">	tf::TransformListener listener;</span><br><span class="line"></span><br><span class="line">	<span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (node.<span class="built_in">ok</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 获取turtle1与turtle2坐标系之间的tf数据</span></span><br><span class="line">		tf::StampedTransform transform;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			listener.<span class="built_in">waitForTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), ros::<span class="built_in">Duration</span>(<span class="number">3.0</span>));</span><br><span class="line">			listener.<span class="built_in">lookupTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), transform);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in"><span class="keyword">catch</span></span> (tf::TransformException &amp;ex) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ROS_ERROR</span>(<span class="string">&quot;%s&quot;</span>,ex.<span class="built_in">what</span>());</span><br><span class="line">			ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>).<span class="built_in">sleep</span>();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令</span></span><br><span class="line">		geometry_msgs::Twist vel_msg;</span><br><span class="line">		vel_msg.angular.z = <span class="number">4.0</span> * <span class="built_in">atan2</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(),</span><br><span class="line">				                        transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>());</span><br><span class="line">		vel_msg.linear.x = <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>(), <span class="number">2</span>) +</span><br><span class="line">				                      <span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(), <span class="number">2</span>));</span><br><span class="line">		turtle_vel.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line"></span><br><span class="line">		rate.<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="4-配置tf广播器与监听器代码编译规则"><a href="#4-配置tf广播器与监听器代码编译规则" class="headerlink" title="4. 配置tf广播器与监听器代码编译规则"></a>4. 配置tf广播器与监听器代码编译规则</h5><p>配置<code>learning_tf</code>中的<code>CMakeLists.txt</code>，在图示位置添加如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(turtle_tf_broadcaster $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(turtle_tf_listener src/turtle_tf_listener.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(turtle_tf_listener $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210301152515882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>即分别把两个cpp文件编译成两个可执行文件，然后对库进行链接。</p>
<h5 id="5-编译"><a href="#5-编译" class="headerlink" title="5. 编译"></a>5. 编译</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>

<h5 id="6-运行程序"><a href="#6-运行程序" class="headerlink" title="6. 运行程序"></a>6. 运行程序</h5><p>以下程序每一行均需要一个单独的terminal运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_tf turtle_tf_broadcaster __name:=turtle1_tf_broadcaster /turtle1</span><br><span class="line">rosrun learning_tf turtle_tf_broadcaster __name:=turtle2_tf_broadcaster /turtle2</span><br><span class="line">rosrun learning_tf turtle_tf_listener</span><br><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210301153221708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS学习笔记】（十一）launch启动文件的使用方法</title>
    <url>/2021/03/02/069-%E3%80%90ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89launch%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="一、Launch文件作用"><a href="#一、Launch文件作用" class="headerlink" title="一、Launch文件作用"></a>一、Launch文件作用</h3><ul>
<li>通过XML文件实现多节点的配置和启动。</li>
<li>同时可以自动启动ROS Master（不需要单独<code>roscore</code>）。</li>
</ul>
<h3 id="二、Launch文件语法"><a href="#二、Launch文件语法" class="headerlink" title="二、Launch文件语法"></a>二、Launch文件语法</h3><h5 id="1-lt-launch-gt"><a href="#1-lt-launch-gt" class="headerlink" title="1. &lt;launch&gt;"></a>1. <code>&lt;launch&gt;</code></h5><p>launch文件中的根元素采用<code>&lt;launch&gt;</code>标签定义</p>
<h5 id="2-lt-node-gt"><a href="#2-lt-node-gt" class="headerlink" title="2. &lt;node&gt;"></a>2. <code>&lt;node&gt;</code></h5><p>启动节点：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;package-name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;executable-name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;node-name&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>pkg：节点所在功能包名称</li>
<li>type：节点的可执行文件名称</li>
<li>name：节点运行时的名称</li>
<li>其他可选属性：<ul>
<li>output（是否打印日志信息）</li>
<li>respawn（是否在出现错误时重启）</li>
<li>require（是否要求某个节点必须启动）</li>
<li>ns（namespace定义命名空间，避免命名冲突）</li>
<li>args（给每个节点输入参数）</li>
</ul>
</li>
</ul>
<h5 id="3-参数设置"><a href="#3-参数设置" class="headerlink" title="3. 参数设置"></a>3. 参数设置</h5><ul>
<li><p><code>&lt;param&gt;</code>或<code>&lt;param&gt;</code></p>
<p>设置系统中的参数，存储在参数服务器中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;output_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abcd&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>加载参数文件中的多个参数：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> <span class="attr">ns</span>=<span class="string">&quot;params&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>&lt;arg&gt;</code></p>
<p>launch文件内部的局部变量</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;arg-name&quot;</span> <span class="attr">default</span>=<span class="string">&quot;arg-value&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="4-重映射-lt-remap-gt"><a href="#4-重映射-lt-remap-gt" class="headerlink" title="4. 重映射&lt;remap&gt;"></a>4. 重映射<code>&lt;remap&gt;</code></h5><p>重映射ROS计算图资源的命名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;/turtlebot/cmd_vel&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/cmd_vel&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="5-嵌套-lt-include-gt"><a href="#5-嵌套-lt-include-gt" class="headerlink" title="5. 嵌套&lt;include&gt;"></a>5. 嵌套<code>&lt;include&gt;</code></h5><p>包含其他launch文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(dirname)/other.launch&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="三、Launch示例"><a href="#三、Launch示例" class="headerlink" title="三、Launch示例"></a>三、Launch示例</h3><h5 id="1-新建一个功能包"><a href="#1-新建一个功能包" class="headerlink" title="1. 新建一个功能包"></a>1. 新建一个功能包</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_launch</span><br></pre></td></tr></table></figure>

<h5 id="2-创建launch文件夹"><a href="#2-创建launch文件夹" class="headerlink" title="2. 创建launch文件夹"></a>2. 创建launch文件夹</h5><p>在learning_launch文件夹下新建一个名为<code>launch</code>的文件夹。</p>
<h5 id="3-创建launch文件"><a href="#3-创建launch文件" class="headerlink" title="3. 创建launch文件"></a>3. 创建launch文件</h5><p>在刚才创建的文件夹内新建一个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touchs simple.launch</span><br></pre></td></tr></table></figure>

<p>其内容为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_topic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;person_subscriber&quot;</span> <span class="attr">name</span>=<span class="string">&quot;talker&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_topic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;person_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;listener&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210302172409787.png" alt="在这里插入图片描述"></p>
<h5 id="4-运行launch文件"><a href="#4-运行launch文件" class="headerlink" title="4. 运行launch文件"></a>4. 运行launch文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roslaunch learning_launch simple.launch</span><br></pre></td></tr></table></figure>

<p>可以看到两个节点都运行起来了。<br><img src="https://img-blog.csdnimg.cn/20210302172453240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS学习笔记】（十二）常用可视化工具</title>
    <url>/2021/03/03/070-%E3%80%90ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%B8%B8%E7%94%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="Qt工具箱"><a href="#Qt工具箱" class="headerlink" title="Qt工具箱"></a>Qt工具箱</h3><h5 id="1-rqt-console"><a href="#1-rqt-console" class="headerlink" title="1. rqt_console"></a>1. rqt_console</h5><p>（1）回到系统内，首先启动海龟例程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rqt_console</span><br></pre></td></tr></table></figure>
<p>上面的窗口显示日志的输出信息，info信息、warning警告、error错误等<br><img src="https://img-blog.csdnimg.cn/20210303171340312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（2）运行键盘控制程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure>

<p>当小海龟碰到边界时，可以看到控制台会输出warning<br><img src="https://img-blog.csdnimg.cn/20210303171438842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="2-rqt-plot"><a href="#2-rqt-plot" class="headerlink" title="2. rqt_plot"></a>2. rqt_plot</h5><p>关闭rot_console控制台，再在终端输入<code>rqt_plot</code></p>
<p>在Topic栏输入<code>/turtle1/pose</code></p>
<p>可以看到小海龟的位姿信息都会被输出出来<br><img src="https://img-blog.csdnimg.cn/2021030317173236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>如果打不开的可以在终端输入rqt，进入后选择plugin-visualization-plot打开</p>
<p>如果出现核心已转：运行<code>sudo apt-get install python-pip</code>和<code>python -m pip install -U matplotlib</code></p>
</blockquote>
<h5 id="3-rqt-image-view"><a href="#3-rqt-image-view" class="headerlink" title="3. rqt_image_view"></a>3. rqt_image_view</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rqt_image_view</span><br></pre></td></tr></table></figure>
<p>需要驱动摄像头，在这里显示镜头的图像，选择图像的信息后会渲染出来。<br><img src="https://img-blog.csdnimg.cn/20210303171944840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="4-rqt"><a href="#4-rqt" class="headerlink" title="4. rqt"></a>4. rqt</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rqt</span><br></pre></td></tr></table></figure>
<p>集成了所有rqt工具，在plugins可以看到所有插件。<br><img src="https://img-blog.csdnimg.cn/20210303172113987.png" alt="在这里插入图片描述"></p>
<h3 id="Rviz"><a href="#Rviz" class="headerlink" title="Rviz"></a>Rviz</h3><p>在命令行输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun rviz rviz</span><br></pre></td></tr></table></figure>

<p>Rviz是一款三维可视化工具，可以很好的兼容基域ROS软件框架的机器人平台。</p>
<ul>
<li>在Rviz中，可以使用扩展标记语言XML对机器人、周围物体等任何实物进行尺寸、质量、位置、材质等属性的描述，并在界面中显示出来。</li>
<li>Rviz可以通过图形化的方式显示机器人传感器信息、机器人运动状态、环境信息等。</li>
</ul>
<p>Rviz界面主要包括：3D视图区，视角设置区，工具栏，显示项列表，时间显示区</p>
<p>Rviz是数据显示平台，所以显示数据时，需要选择Topic。<br><img src="https://img-blog.csdnimg.cn/20210303172221272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Gazebo"><a href="#Gazebo" class="headerlink" title="Gazebo"></a>Gazebo</h3><p>Gazebo是一款功能强大的三位物理仿真平台，用来仿真机器人、传感器、环境的平台。</p>
<p>在Gazebo也包括：0-3D视图区，1-工具栏，2-模型列表，3-模型属性，4-时间显示区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roslaunch gazebo_ros willow</span><br></pre></td></tr></table></figure>

<p>可能运行不成功，Gazebo对计算机性能要求较高，而且第一次加载会从远程服务器下载一些材质包、环境等。<br><img src="https://img-blog.csdnimg.cn/20210303172558320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++笔记】函数的用法：函数的默认参数、占位参数、函数重载</title>
    <url>/2021/03/04/071-%E3%80%90C++%E7%AC%94%E8%AE%B0%E3%80%91%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code>返回值类型 函数名 (参数=默认值)&#123;&#125;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">20</span>, <span class="keyword">int</span> c = <span class="number">30</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果给形参传入了数据，就用自己的数据；如果没有，就用默认值</p>
<p><strong>注意事项：</strong></p>
<ul>
<li><p>如果某个位置已经有了默认参数，那么从这个位置往后，必须都有默认值。（即有默认参数的形参必须放在最后）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误示例：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果函数的声明有了默认参数，函数实现就不能有默认参数。（即声明和实现只能有一个有默认参数）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误示例：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">error C2572: <span class="string">&quot;func2&quot;</span>：重定义默认参数</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p>语法：<code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is a function.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">10</span>);	<span class="comment">//这里必须要传两个数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>占位参数还可以有默认参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is a function.&quot;</span> &lt;&lt;endl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><h5 id="1-函数重载概述"><a href="#1-函数重载概述" class="headerlink" title="1. 函数重载概述"></a>1. 函数重载概述</h5><p><strong>作用：</strong>函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同、个数不同、顺序不同</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="comment">//func函数都在全局作用域下</span></span><br><span class="line"><span class="comment">//func函数名称相同</span></span><br><span class="line"><span class="comment">//func函数参数类型不同、或个数不同、或顺序不同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func().&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int a).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(double a).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int a, double b).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(double a, int b).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-函数重载注意事项"><a href="#2-函数重载注意事项" class="headerlink" title="2. 函数重载注意事项"></a>2. 函数重载注意事项</h5><ul>
<li><p>函数的返回值不可以作为函数重载的条件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line"><span class="comment">//无法重载仅按返回类型区分的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(double a, int b).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(double a, int b).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>引用作为重载条件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个函数类型不同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int &amp;a).&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(const int &amp;a).&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(a);	<span class="comment">//调用func(int &amp;a)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);	<span class="comment">//调用func(const int &amp;a)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数重载碰到默认参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int a).&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int a, int b).&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);	<span class="comment">//X 当函数重载碰到默认参数，出现二义性报错，尽量避免重载时使用默认参数</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">20</span>);	<span class="comment">//√</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++笔记】封装的意义，结构体和类的区别</title>
    <url>/2021/03/05/072-%E3%80%90C++%E7%AC%94%E8%AE%B0%E3%80%91%E5%B0%81%E8%A3%85%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="一、封装的意义"><a href="#一、封装的意义" class="headerlink" title="一、封装的意义"></a>一、封装的意义</h4><ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>1.1 设计类时，属性和行为写在一起，表现事物</strong></p>
<p><strong>语法：</strong><code>class 类名&#123; 访问权限: 属性/行为 &#125;;</code></p>
<p>类中的属性和行为统一称为成员，属性也称为成员属性或成员变量，行为也成为成员函数或成员方法；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例1：设计一个圆类，求圆的周长</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class代表设计一个类，类后面紧跟着类名称</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">    <span class="comment">//访问权限</span></span><br><span class="line">    <span class="comment">//公共权限</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//属性</span></span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="comment">//行为</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">calcuPerimeter</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * PI * r;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过圆类，创建具体的圆对象</span></span><br><span class="line">    Circle c1;</span><br><span class="line">    <span class="comment">//给圆对象的属性赋值</span></span><br><span class="line">    c1.r = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Perimeter is &quot;</span> &lt;&lt; c1.<span class="built_in">calcuPerimeter</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.2 类在设计时，可以把属性和行为放在不同的权限下加以控制</strong></p>
<p>访问权限有三种</p>
<ol>
<li>public：公共权限，类内可以访问，类外可以访问</li>
<li>protected：保护权限，类内可以访问，类外不可以访问</li>
<li>private：私有权限，类内可以访问，类外不可以访问</li>
</ol>
<blockquote>
<p>保护权限和私有权限区别主要在继承方面，子类可以访问父类的保护权限，而私有权限不可访问</p>
</blockquote>
<h4 id="二、struct和class的区别"><a href="#二、struct和class的区别" class="headerlink" title="二、struct和class的区别"></a>二、struct和class的区别</h4><p>在C++种struct和class的唯一区别在于默认的访问权限不同</p>
<ul>
<li>struct：默认权限为公有</li>
<li>class：默认权限为私有</li>
</ul>
<p>尽管结构体可以包含成员函数，但它们很少这样做。所以，通常情况下，结构体声明只会声明成员变量。结构体声明通常不包括public或private的访问修饰符。</p>
<h4 id="三、成员属性设置为私有"><a href="#三、成员属性设置为私有" class="headerlink" title="三、成员属性设置为私有"></a>三、成员属性设置为私有</h4><ul>
<li>将所有成员属性设置为私有，可以自己控制读写权限</li>
<li>对于写权限，我们可以检测数据的有效性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//设置姓名</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取姓名</span></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置性别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setGender</span><span class="params">(string gender)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(gender == <span class="string">&quot;Male&quot;</span> <span class="keyword">or</span> gender == <span class="string">&quot;Female&quot;</span>)&#123;</span><br><span class="line">            m_Gender = gender;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Wrong Gender!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            m_Gender = <span class="string">&quot;Male&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取性别</span></span><br><span class="line">    <span class="function">string <span class="title">getGender</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置年龄</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//姓名  可读可写</span></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="comment">//性别  可读可写 修改选项只能是 &quot;Male&quot; &quot;Female&quot;</span></span><br><span class="line">    string m_Gender;</span><br><span class="line">    <span class="comment">//年龄  只写</span></span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setName</span>(<span class="string">&quot;Huffie&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name:\t&quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setGender</span>(<span class="string">&quot;Male&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Gender:\t&quot;</span> &lt;&lt; p.<span class="built_in">getGender</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setAge</span>(<span class="number">21</span>);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; p.getAge() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++笔记】构造函数与析构函数相关知识</title>
    <url>/2021/03/06/073-%E3%80%90C++%E7%AC%94%E8%AE%B0%E3%80%91%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>每个对象需要有初始设置以及对象销毁前的清理数据的设置。</p>
<h3 id="一、构造函数和析构函数"><a href="#一、构造函数和析构函数" class="headerlink" title="一、构造函数和析构函数"></a>一、构造函数和析构函数</h3><p>对象的<strong>初始化和清理</strong>是两个非常重要的安全问题。</p>
<ul>
<li>一个对象或变量没有初始状态，对其使用后果未知</li>
<li>使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</li>
</ul>
<p>C++使用<strong>构造函数和析构函数</strong>解决这两个问题，这<strong>两个函数会被编译器自动调用</strong>，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此<strong>如果我们不提供构造和析构，编译器会提供，编译器提供的构造函数和析构函数是空实现</strong>。</p>
<ul>
<li>构造函数：创建对象时为对象的成员属性赋值</li>
<li>析构函数：对象销毁前执行清理工作</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次。</li>
</ol>
<p><strong>析构函数语法：</strong><code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同，在名称前加上~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数，进行初始化操作</span></span><br><span class="line">	<span class="comment">//构造函数没有返回值 不用写void</span></span><br><span class="line">	<span class="comment">//函数名与类名相同</span></span><br><span class="line">	<span class="comment">//构造函数可以有参数，可以发生重载</span></span><br><span class="line">	<span class="comment">//创建对象的时候，构造函数会自动调用，而且只调用一次</span></span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数，执行清理操作</span></span><br><span class="line">	<span class="comment">//没有返回值，不写void</span></span><br><span class="line">	<span class="comment">//函数名和类名相同，前面加~</span></span><br><span class="line">	<span class="comment">//不可以有参数，不可以发生重载</span></span><br><span class="line">	<span class="comment">//创建对象的时候，构造函数会自动调用，而且只调用一次</span></span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	Person p;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、构造函数的分类及调用"><a href="#二、构造函数的分类及调用" class="headerlink" title="二、构造函数的分类及调用"></a>二、构造函数的分类及调用</h3><p>分类方式：</p>
<ul>
<li>按参数分：有参构造和无参构造</li>
<li>按类型分：普通构造和拷贝构造</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通构造、无参构造（默认构造）</span></span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;无参构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通构造、有参构造</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">int</span> a)&#123;</span><br><span class="line">	age = a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;有参构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> Person &amp;p)&#123;</span><br><span class="line">	<span class="comment">//将传入的类中所有的属性传到此对象上</span></span><br><span class="line">	age = p.age;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;拷贝构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<ul>
<li>括号法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person p1;		<span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//调用有参构造函数</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;	<span class="comment">//调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：调用默认构造函数的时候，不要加()</p>
<p>因为 <code>Person p1();</code> ，编译器会认为是一个函数的声明</p>
</blockquote>
<ul>
<li>显示法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person p1;				<span class="comment">//调用无参构造函数</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>);	<span class="comment">//调用有参构造函数</span></span><br><span class="line">Person p3 = <span class="built_in">Person</span>(p2);	<span class="comment">//调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Person(10)</code> 是匿名对象。</p>
<p>特点：当前行执行结束后，系统会立即回收掉匿名对象。</p>
</blockquote>
<blockquote>
<p>不要用拷贝构造函数初始化匿名对象</p>
<p><code>Person(p3);    //报错重定义</code></p>
<p>编译器会认为 Person (p3) 等价于 Person p3;</p>
</blockquote>
<ul>
<li>隐式转换法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person p1;		<span class="comment">//调用无参构造函数</span></span><br><span class="line">Person p2 = <span class="number">10</span>;	<span class="comment">//调用有参构造函数</span></span><br><span class="line">Person p3 = p2;	<span class="comment">//调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Person p2 = 10;</code> 相当于 <code>Person p2 = Person(10);</code></p>
</blockquote>
<h3 id="三、拷贝构造函数调用时机"><a href="#三、拷贝构造函数调用时机" class="headerlink" title="三、拷贝构造函数调用时机"></a>三、拷贝构造函数调用时机</h3><p>C++中拷贝构造函数的调用时机通常有以下情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>以值传递的方式给函数参数传值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age)&#123;</span><br><span class="line">		m_Age = age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">const</span> Person &amp;p)&#123;</span><br><span class="line">		m_Age = p.m_Age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用已经创建完毕的对象初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;	<span class="comment">//调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递的方式给函数参数传值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Person p)</span></span>&#123;&#125;<span class="comment">//值传递相当于 Person p = p 的隐式写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	<span class="built_in">doWork</span>(p);	<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	test03;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、构造函数调用规则"><a href="#四、构造函数调用规则" class="headerlink" title="四、构造函数调用规则"></a>四、构造函数调用规则</h3><p>默认情况下，c++中类至少有三个函数</p>
<ul>
<li>默认构造函数（无参，函数体为空）</li>
<li>默认析构函数（无参，函数体为空）</li>
<li>默认拷贝构造函数，对属性值进行拷贝</li>
</ul>
<p>构造函数调用规则：</p>
<ul>
<li>如果用户定义了有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造</li>
<li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li>
</ul>
<h3 id="五、深拷贝与浅拷贝"><a href="#五、深拷贝与浅拷贝" class="headerlink" title="五、深拷贝与浅拷贝"></a>五、深拷贝与浅拷贝</h3><p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">例<span class="number">1</span>：浅拷贝的问题，此程序的问题是，m_Height指向的区域，经过两次析构函数的调用，被重复释放了。</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> height)&#123;</span><br><span class="line">		m_Age = age;</span><br><span class="line">		m_Height = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(height);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		<span class="comment">//析构函数，将堆区开辟的数据做释放操作</span></span><br><span class="line">		<span class="keyword">if</span> (m_Height != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Height;</span><br><span class="line">			m_Height = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">	<span class="keyword">int</span> *m_Height;	<span class="comment">//身高数据开辟到堆区</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">21</span>, <span class="number">160</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;P1的年龄为：&quot;</span> &lt;&lt; p1.m_Age &lt;&lt; <span class="string">&quot;\t身高为：&quot;</span> &lt;&lt; *p1.m_Height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;P1的年龄为：&quot;</span> &lt;&lt; p1.m_Age &lt;&lt; <span class="string">&quot;\t身高为：&quot;</span> &lt;&lt; *p2.m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">解决方法：自己实现拷贝构造函数，解决浅拷贝带来的问题</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">const</span> Person &amp;p)&#123;</span><br><span class="line">		m_Age = p.m_Age;</span><br><span class="line">		<span class="comment">//m_Height = p.m_Height;//编译器默认实现的是这行代码</span></span><br><span class="line">		m_Height = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p.m_Height);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="六、初始化列表"><a href="#六、初始化列表" class="headerlink" title="六、初始化列表"></a>六、初始化列表</h3><p><strong>作用：</strong>为类中的属性进行初始化操作</p>
<p><strong>语法：</strong><code>构造函数(): 属性1(值1),属性2(值2)...&#123;&#125;</code></p>
<p><strong>优点：</strong>类成员存在常量时，只能初始化而不能赋值；类成员存在引用时，只能初始化不能赋值；提高效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//传统的初始化</span></span><br><span class="line">	<span class="comment">//Person(int a, int b, int c)&#123;</span></span><br><span class="line">	<span class="comment">//	m_A = a;</span></span><br><span class="line">	<span class="comment">//	m_B = b;</span></span><br><span class="line">	<span class="comment">//	m_C = c;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表进行初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):<span class="built_in">m_A</span>(a),<span class="built_in">m_B</span>(b),<span class="built_in">m_C</span>(c)&#123;&#125;</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line">	<span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m_B = &quot;</span> &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m_B = &quot;</span> &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、类对象作为类成员"><a href="#七、类对象作为类成员" class="headerlink" title="七、类对象作为类成员"></a>七、类对象作为类成员</h3><p>C++中类的成员可以是另一个类的对象，<strong>一般称该成员为对象成员</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    A a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当其它类的对象作为本类成员</p>
<p>构造时：先构造类对象，再构造自身。</p>
<p>析构时：顺序与构造相反。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手机类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Phone</span>(string brand)&#123;</span><br><span class="line">		m_Brand = brand;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Phone</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Brand;<span class="comment">//品牌</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//人类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//这里的m_Phone(brand)相当于使用括号法Phone m_Phone(brand)创建对象</span></span><br><span class="line">	<span class="built_in">Person</span>(string name, string brand):<span class="built_in">m_Name</span>(name),<span class="built_in">m_Phone</span>(brand)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Huffie&quot;</span>,<span class="string">&quot;Huawei&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; with &quot;</span> &lt;&lt; p.m_Phone.m_Brand &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="八、静态成员"><a href="#八、静态成员" class="headerlink" title="八、静态成员"></a>八、静态成员</h3><p>静态成员就是在成员变量和成员函数前加上static</p>
<ul>
<li>静态成员变量：<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存（全局区）</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
</ul>
<blockquote>
<p>静态成员变量有两种访问方式（若为私有权限，类外无法访问）：</p>
<ol>
<li><p>通过对象访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person p;</span><br><span class="line">cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
<li><p>通过类名访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; Person::m_A &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//类内声明</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外初始化</span></span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> Person::m_B = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; p1.m_A &lt;&lt; endl;	<span class="comment">//输出100</span></span><br><span class="line">	</span><br><span class="line">	Person p2;</span><br><span class="line">	p2.m_A = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; p1.m_A &lt;&lt; endl;	<span class="comment">//输出200，说明数据共享</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量不属于某个对象，所有对象都共享同一份数据，因此静态成员变量有两种访问方式</span></span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	cout &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; Person::m_B &lt;&lt; endl;错误，私有权限类外访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态成员函数<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<blockquote>
<p>静态成员函数有两种访问方式（若为私有权限，类外同样无法访问）：</p>
<ol>
<li><p>通过对象访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person p;</span><br><span class="line">p.<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure></li>
<li><p>通过类名访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person::<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//静态成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_B = 200;静态成员函数不可以访问非静态成员变量</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;static void func的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">	<span class="comment">//非静态成员变量</span></span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;static void func2的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	Person p;</span><br><span class="line">	p.<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person::func2();类外无法访问私有的静态成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++笔记】友元</title>
    <url>/2021/03/08/075-%E3%80%90C++%E7%AC%94%E8%AE%B0%E3%80%91%E5%8F%8B%E5%85%83/</url>
    <content><![CDATA[<p>有些私有属性，可需要让类外特殊的一些函数或类进行访问，就需要利用友元。</p>
<p>友元的关键字为fiend</p>
<p>友元的三种实现方法</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h3 id="一、全局函数作友元"><a href="#一、全局函数作友元" class="headerlink" title="一、全局函数作友元"></a>一、全局函数作友元</h3><p>将全局函数的声明写在类的定义内，并在前面添加关键字friend。</p>
<p>例：<code>friend void func(Person *person);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="comment">//goodFriend全局函数可以访问Person中的私有成员</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodFriend</span><span class="params">(Person *person)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		m_Name = <span class="string">&quot;Huffie&quot;</span>;</span><br><span class="line">		m_Money = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> m_Money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodFriend</span><span class="params">(Person *person)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Friends is getting:&quot;</span> &lt;&lt; person-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Friends is getting:&quot;</span> &lt;&lt; person-&gt;m_Money &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二、类作友元"><a href="#二、类作友元" class="headerlink" title="二、类作友元"></a>二、类作友元</h3><p>语法：<code>friend class className;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person类的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">goodFriend</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> m_Money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>()&#123;</span><br><span class="line">	m_Name = <span class="string">&quot;Huffie&quot;</span>;</span><br><span class="line">	m_Money = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//goodFriend类的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodFriend</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">goodFriend</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;	<span class="comment">//获取函数，获取Person中的属性</span></span><br><span class="line"></span><br><span class="line">	Person * person;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">goodFriend::<span class="built_in">goodFriend</span>()&#123;</span><br><span class="line">	person = <span class="keyword">new</span> Person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodFriend::get</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;goodFriend类正在访问：&quot;</span> &lt;&lt; person-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;goodFriend类正在访问：&quot;</span> &lt;&lt; person-&gt;m_Money &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	goodFriend gf;</span><br><span class="line">	gf.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、成员函数作友元"><a href="#三、成员函数作友元" class="headerlink" title="三、成员函数作友元"></a>三、成员函数作友元</h3><p>例：<code>friend void className::func();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodFriend</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">goodFriend</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">get1</span><span class="params">()</span></span>;	<span class="comment">//让get函数可以访问Person中私有成员</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">get2</span><span class="params">()</span></span>;	<span class="comment">//让get函数不可以访问Person中私有成员</span></span><br><span class="line"></span><br><span class="line">	Person * person;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodFriend::get1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>();</span><br><span class="line">	string m_Name;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> m_Money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>()&#123;</span><br><span class="line">	m_Name = <span class="string">&quot;Huffie&quot;</span>;</span><br><span class="line">	m_Money = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodFriend::<span class="built_in">goodFriend</span>()&#123;</span><br><span class="line">	person = <span class="keyword">new</span> Person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodFriend::get1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;get函数正在访问：&quot;</span> &lt;&lt; person-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;get函数正在访问：&quot;</span> &lt;&lt; person-&gt;m_Money &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodFriend::get2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;get函数正在访问：&quot;</span> &lt;&lt; person-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;get函数正在访问：&quot; &lt;&lt; person-&gt;m_Money &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	goodFriend gf;</span><br><span class="line">	gf.<span class="built_in">get1</span>();</span><br><span class="line">	gf.<span class="built_in">get2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++笔记】对象模型和this指针</title>
    <url>/2021/03/07/074-%E3%80%90C++%E7%AC%94%E8%AE%B0%E3%80%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h3 id="一、成员变量和成员函数分开存储"><a href="#一、成员变量和成员函数分开存储" class="headerlink" title="一、成员变量和成员函数分开存储"></a>一、成员变量和成员函数分开存储</h3><p>C++中，类内的成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象</p>
<ol>
<li><p>空对象也会占用内存</p>
<p>C++编译器会给每个空对象也分配一个字节空间，是为了标志此对象占内存的位置。每个空对象也应该有一个独一无二的内存地址</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span>&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>空对象占用1个字节内存</p>
</blockquote>
</li>
<li><p><strong>只有</strong>类的非静态成员变量，属于类的对象</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>只含一个int非静态成员变量的对象占用4个字节内存</p>
</blockquote>
</li>
<li><p>类的静态成员变量，不属于类的对象</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Person::m_B = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>对象还是占用4个字节内存</p>
</blockquote>
</li>
<li><p>成员变量和成员函数是分开存储的</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_B;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>对象还是占用4个字节内存</p>
</blockquote>
</li>
</ol>
<h3 id="二、this指针"><a href="#二、this指针" class="headerlink" title="二、this指针"></a>二、this指针</h3><p>有上述可知，C++中成员变量和成员函数是分开存储的。</p>
<p>每一个非静态成员函数只会产生一份函数实例，也就是多个同类型的对象会共用一块代码，而代码如何区分哪个对象调用自己。</p>
<p>这里就用到了this指针，<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li><p>形参和成员变量同名时，可以用this指针来区分</p>
</li>
<li><p>在类的非静态成员函数中返回对象本身，可使用return *this</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> money)&#123;</span><br><span class="line">		<span class="comment">//this指针指向被调用的成员函数所属的对象</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;money = money;	<span class="comment">//如果不加this，则赋值两侧会认为是同一个money</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddMoney</span><span class="params">(Person &amp;p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;money += p.money;	<span class="comment">//将传入的p对象的money加到此对象上</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;	<span class="comment">//this是指向对象的指针，*this就是指向对象本体</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的财产为：&quot;</span> &lt;&lt; p1.money &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p2.<span class="built_in">PersonAddMoney</span>(p1).<span class="built_in">PersonAddMoney</span>(p1).<span class="built_in">PersonAddMoney</span>(p1);<span class="comment">//链式编程</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的财产为：&quot;</span> &lt;&lt; p2.money &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、空指针访问成员函数"><a href="#三、空指针访问成员函数" class="headerlink" title="三、空指针访问成员函数"></a>三、空指针访问成员函数</h3><p>C++中空指针也可以调用成员函数，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加判断保证代码的健壮性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showClassName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;This is Person class.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPersonAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span> == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;	<span class="comment">//报错原因是传入的指针为空</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person * p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">showClassName</span>();	<span class="comment">//空指针也可以正常执行</span></span><br><span class="line">	p-&gt;<span class="built_in">showPersonAge</span>();	<span class="comment">//如果不加if语句会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、const修饰成员函数"><a href="#四、const修饰成员函数" class="headerlink" title="四、const修饰成员函数"></a>四、const修饰成员函数</h3><p><strong>常函数：</strong></p>
<ul>
<li><p>成员函数后加const后我们称为这个函数为常函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>常函数不可以修改成员属性</p>
<blockquote>
<p>常函数也存在this指针，而<strong>this指针的本质是指针常量</strong>，指针的指向是不可修改的。</p>
<p>在成员函数后面加this，修饰的是this指向，让指针指向的值也不可以修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = <span class="number">100</span>;	<span class="comment">//报错</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>成员属性声明时加关键字mutable，在常函数中依然可以修改</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> m_B;</span><br></pre></td></tr></table></figure>

<p>创建了一个特殊的变量，即使在常函数中也可以修改，常对象也可以修改</p>
</blockquote>
</li>
</ul>
<p><strong>常对象</strong></p>
<ul>
<li><p>对象前加const，创建的是常对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person p;</span><br></pre></td></tr></table></figure></li>
<li><p>常对象无法修改成员变量，值可以修改加mutable的变量</p>
</li>
<li><p>常对象只能调用常函数，不能调用普通成员函数，因为普通成员函数可以修改属性</p>
</li>
</ul>
<blockquote>
<p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++笔记】运算符重载</title>
    <url>/2021/03/09/076-%E3%80%90C++%E7%AC%94%E8%AE%B0%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>运算符重载的目的是对已有的运算符重新定义，赋予其另一种功能，以适应不同的数据类型。</p>
<h3 id="一、加号运算符重载"><a href="#一、加号运算符重载" class="headerlink" title="一、加号运算符重载"></a>一、加号运算符重载</h3><p>作用：实现两个自定义数据类型的加法运算</p>
<p><strong>1.1 通过成员函数重载+号</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    Person <span class="keyword">operator</span>+(Person &amp;p)&#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用方法：</p>
<ol>
<li>本质调用：<code>Person p3 = p1.operator+(p2);</code></li>
<li>简化调用：<code>Person p3 = p1 + p2;</code></li>
</ol>
<p><strong>1.2 通过全局函数重载+号</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1, Person &amp;p2)&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p1.m_A + p2.m_A;</span><br><span class="line">	temp.m_B = p1.m_B + p2.m_B;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1, <span class="keyword">int</span> num)&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p1.m_A + num;</span><br><span class="line">	temp.m_B = p1.m_B + num;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方法：</p>
<ol>
<li>本质调用：<code>Person p3 = operator+(p1, p2);</code></li>
<li>简化调用：<code>Person p3 = p1 + p2;</code></li>
</ol>
<p>运算符重载也可以发生函数重载：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person p3 = p1 + p2;</span><br><span class="line">Person p4 = p1 + <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p><strong>1.3 注意事项</strong>：</p>
<ul>
<li>对于内置的数据类型的表达式的运算符是不可能改变的</li>
<li>不要滥用运算符重载</li>
</ul>
<h3 id="二、左移运算符重载"><a href="#二、左移运算符重载" class="headerlink" title="二、左移运算符重载"></a>二、左移运算符重载</h3><p><strong>通过全局函数重载&lt;&lt;左移运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,Person &amp;p)&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p.m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p.m_B = &quot;</span> &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选中cout，右键转到声明，可以看到cout属于ostream这个类</li>
<li>返回cout是为了实现链式编程，使得可以无限追加&lt;&lt;</li>
<li>不通过成员函数重载是因为，成员函数重载只能实现p.operator&lt;&lt;(cout)，即p&lt;&lt;cout，与预期不符。</li>
</ul>
<p>调用方法：</p>
<p><code>cout &lt;&lt; p &lt;&lt; endl;</code></p>
<h3 id="三、递增运算符重载"><a href="#三、递增运算符重载" class="headerlink" title="三、递增运算符重载"></a>三、递增运算符重载</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>()&#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载前置++运算符</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">		++m_Num;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载后置++运算符	此处的int代表占位参数，可以用于区分前置和后置递增</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>;</span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_Num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前置++：</p>
<ul>
<li>返回值是引用，是因为需要实现++(++a)，保证自增的都是同一个数据</li>
</ul>
<p>后置++：</p>
<ul>
<li>因为后置++要先返回当前值，再递增。因此先把当前值记录下来，递增之后，再返回记录值。</li>
<li>返回值以值传递形式，是因为返回的是局部对象temp，局部对象不能通过引用返回。</li>
</ul>
<h3 id="四、赋值运算符重载"><a href="#四、赋值运算符重载" class="headerlink" title="四、赋值运算符重载"></a>四、赋值运算符重载</h3><p>c++编译器至少给一个类添加四个函数</p>
<ol>
<li>默认构造函数（无参，函数体为空）</li>
<li>默认析构函数（无参，函数体为空）</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator=对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题。</p>
<p>解决方法：利用深拷贝，解决浅拷贝带来的问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age)&#123;</span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span>(m_Age != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载赋值运算符</span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person &amp;p)&#123;</span><br><span class="line">		<span class="comment">//先判断是否有属性在堆区，如果有，先释放干净，再深拷贝</span></span><br><span class="line">		<span class="keyword">if</span>(m_Age != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//进行深拷贝</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p.m_Age);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">24</span>)</span></span>;</span><br><span class="line">	p3 = p2 = p1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_Age = &quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.m_Age = &quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3.m_Age = &quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>重载=的逻辑是，如p2=p1，先释放p2内的属性（因为浅拷贝p2和p1内的m_Age指向同一块内存），然后再重新开辟内存空间进行深拷贝。</li>
<li>返回值是Person&amp;，是为了连续赋值操作</li>
</ul>
<h3 id="五、关系运算符重载"><a href="#五、关系运算符重载" class="headerlink" title="五、关系运算符重载"></a>五、关系运算符重载</h3><p><strong>作用：</strong>重载关系运算符时，可以让两个自定义类型对象进行对比操作。（如==、!=）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：重载==运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(Person &amp;p)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、函数调用运算符重载"><a href="#六、函数调用运算符重载" class="headerlink" title="六、函数调用运算符重载"></a>六、函数调用运算符重载</h3><ul>
<li>函数调用运算符是()</li>
<li>由于重载后使用方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：重载()实现自定义打印</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">---------</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">	MyPrint myprint;</span><br><span class="line">	<span class="built_in">myprint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重载()很像函数调用，比如上面的功能也可以用函数实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(string test)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">---------</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++笔记】继承</title>
    <url>/2021/03/10/077-%E3%80%90C++%E7%AC%94%E8%AE%B0%E3%80%91%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p><strong>继承是面向对象的三大特性之一</strong></p>
<p>定义类时，下级别的成员除了拥有上一级的共性，还有自己的特性</p>
<h4 id="6-1-继承的基本语法"><a href="#6-1-继承的基本语法" class="headerlink" title="6.1 继承的基本语法"></a>6.1 继承的基本语法</h4><p>作用：减少代码重复量</p>
<p>语法：<code>class 子类 : 继承方式 父类</code></p>
<p>例：<code>class MyPage : public BasePage </code></p>
<blockquote>
<p>子类也称为派生类、父类也称为基类</p>
<p>派生类中的成员，包含两大部分：一类是从基类继承过来的，一类是自己增加的成员。从基类继承过来的表现其共性，新增的表现其个性</p>
</blockquote>
<h4 id="6-2-继承方式"><a href="#6-2-继承方式" class="headerlink" title="6.2 继承方式"></a>6.2 继承方式</h4><p>继承方式一共有三种：</p>
<ul>
<li>公共继承<ul>
<li>父类中的公共权限成员，子类中也是公共权限</li>
<li>父类中的保护权限成员，子类中也是保护权限</li>
<li>父类的私有权限成员，子类无法访问</li>
</ul>
</li>
<li>保护继承<ul>
<li>父类中的公共权限成员，子类中也是保护权限</li>
<li>父类中的保护权限成员，子类中也是保护权限</li>
<li>父类的私有权限成员，子类无法访问</li>
</ul>
</li>
<li>私有继承<ul>
<li>父类中的公共权限成员，子类中是私有权限</li>
<li>父类中的保护权限成员，子类中是私有权限</li>
<li>父类的私有权限成员，子类无法访问<br><img src="https://img-blog.csdnimg.cn/20210308144516842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<h4 id="6-3-继承中的对象模型"><a href="#6-3-继承中的对象模型" class="headerlink" title="6.3 继承中的对象模型"></a>6.3 继承中的对象模型</h4><p>父类中所有非静态成员属性都会被子类继承下去。父类中私有成员属性，是被编译器隐藏了，因此是访问不到，但是确实被继承下去了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of Son = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出结果：16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-继承中构造和析构顺序"><a href="#6-4-继承中构造和析构顺序" class="headerlink" title="6.4 继承中构造和析构顺序"></a>6.4 继承中构造和析构顺序</h4><p>子类继承父类后，创建子类对象，也会调用父类的构造函数</p>
<p>继承中的构造和析构顺序如下：</p>
<ul>
<li>构造：先构造父类，在构造子类</li>
<li>析构：顺序与构造相反</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Base</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Son</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Base的构造函数</span><br><span class="line">Son的构造函数</span><br><span class="line">Son的析构函数</span><br><span class="line">Base的析构函数</span><br></pre></td></tr></table></figure>

<h4 id="6-5-继承同名成员处理方式"><a href="#6-5-继承同名成员处理方式" class="headerlink" title="6.5 继承同名成员处理方式"></a>6.5 继承同名成员处理方式</h4><ul>
<li>访问子类同名成员，直接访问即可</li>
<li>访问父类同名成员，需要加作用域</li>
</ul>
<p>例：<code>s.Base::m_A</code>或<code>s.Base::func()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试案例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base func 函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son func 函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son : m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base : m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：</p>
<p>如果子类中出现和父类同名的成员函数，子类中的同名成员会隐藏掉父类中所有同名成员函数（包括重载）。如果先要访问父类同名成员，需要加作用域</p>
</blockquote>
<h4 id="6-6-继承同名静态成员处理方式"><a href="#6-6-继承同名静态成员处理方式" class="headerlink" title="6.6 继承同名静态成员处理方式"></a>6.6 继承同名静态成员处理方式</h4><p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员，直接访问即可</li>
<li>访问父类同名成员，需要加作用域</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - static void func&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son - m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base - m_A =  &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son - m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第一个::代表通过类名方式访问	第二个::代表访问父类作用域下的成员</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base - m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-7-多继承语法"><a href="#6-7-多继承语法" class="headerlink" title="6.7 多继承语法"></a>6.7 多继承语法</h4><p>C++允许一个类继承多个类</p>
<p>语法：<code>class 子类 : 继承方式 父类1, 继承方式 父类2...</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br></pre></td></tr></table></figure>

<p>如果多继承中父类出现了同名情况，子类使用时要加作用域</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base1 - m_A = &quot;</span> &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base2 - m_A = &quot;</span> &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="6-8-菱形继承"><a href="#6-8-菱形继承" class="headerlink" title="6.8 菱形继承"></a>6.8 菱形继承</h4><p><strong>概念</strong>：</p>
<ol>
<li>两个派生类继承同一个类</li>
<li>又有某个类同时继承这两个类</li>
<li>这种继承称为菱形继承</li>
</ol>
<p><strong>菱形继承的问题</strong>：</p>
<ol>
<li><p>Son1继承了Base的数据，Son2也继承了Base的数据，当GrandSon使用数据时，就会产生二义性</p>
<blockquote>
<p>解决方法：两个父类因为相同的数据，需要加以作用域区分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g.Son1::m_A = <span class="number">100</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>GrandSon继承来自Base的数据有两份，但实际上有一份就可以</p>
<blockquote>
<p>利用虚继承，解决菱形继承数据重复的问题。发生虚继承之后，数据只有一个，且可以不加作用域直接访问。</p>
<p>在继承前加上关键字virtual。此时的Base称为虚基类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<blockquote>
<p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++笔记】文件操作</title>
    <url>/2021/03/11/078-%E3%80%90C++%E7%AC%94%E8%AE%B0%E3%80%91%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过文件可以将数据持久化</p>
<p>C++中对文件操作需要包含头文件<code>#include&lt;fstream&gt;</code></p>
<p>文件类型分为两种：</p>
<ul>
<li>文本文件：文件以文本的ASCII码形式存储在计算机中</li>
<li>二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂</li>
</ul>
<p>文件的操作：</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream：读操作</li>
<li>fstream：读写操作</li>
</ol>
<h3 id="一、文本文件"><a href="#一、文本文件" class="headerlink" title="一、文本文件"></a>一、文本文件</h3><h4 id="1-1-写文件"><a href="#1-1-写文件" class="headerlink" title="1.1 写文件"></a>1.1 写文件</h4><p>写文件步骤如下</p>
<ol>
<li><p>包含头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>创建流对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ofstream ofs;</span><br></pre></td></tr></table></figure></li>
<li><p>打开文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>, 打开方式)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p>文件打开方式可以配合使用，利用|操作符<br>例如：<code>ios::binary | ios::out</code></p>
</li>
<li><p>写数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ofs &lt;&lt; <span class="string">&quot;写入的数据&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>关闭文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ofs.close</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-2-读文件"><a href="#1-2-读文件" class="headerlink" title="1.2 读文件"></a>1.2 读文件</h4><p>读文件步骤如下：</p>
<ol>
<li><p>包含头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>创建流对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifstream ifs;</span><br></pre></td></tr></table></figure></li>
<li><p>打开文件并判断文件是否打开成功</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>, 打开方式)</span><br><span class="line"><span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Error: File open failed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>读数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string buf;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(ifs, buf))&#123;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>关闭文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ifs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line">	<span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Error: File open failed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	string buf;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">getline</span>(ifs, buf))&#123;</span><br><span class="line">		cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、二进制文件"><a href="#二、二进制文件" class="headerlink" title="二、二进制文件"></a>二、二进制文件</h3><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为<code>ios::binary</code></p>
<h4 id="2-1-写文件"><a href="#2-1-写文件" class="headerlink" title="2.1 写文件"></a>2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数<code>write</code></p>
<p>函数原型：<code>ostream&amp; write(const char * buffer, int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：将Person类中的数据写入文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>,ios::out | ios::binary)</span></span>;</span><br><span class="line">	Person p = &#123;<span class="string">&quot;Huffie&quot;</span>, <span class="number">21</span>&#125;;</span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;p, <span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-读文件"><a href="#2-2-读文件" class="headerlink" title="2.2 读文件"></a>2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数<code>read</code></p>
<p>函数原型：<code>istream&amp; read(const char * buffer, int len);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：读取文件中的数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>,ios::in | ios::binary);</span><br><span class="line">	<span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Error: File open failed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="keyword">char</span> *)&amp;p, <span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p.m_Name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>前端笔记 | CSS基础</title>
    <url>/2021/03/13/080-%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%20%20CSS%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="一、CSS简介"><a href="#一、CSS简介" class="headerlink" title="一、CSS简介"></a>一、CSS简介</h2><p>CSS的主要使用目的就是美化网页，布局页面</p>
<h4 id="1-1-HTML的局限性"><a href="#1-1-HTML的局限性" class="headerlink" title="1.1 HTML的局限性"></a>1.1 HTML的局限性</h4><p>HTML只关注内容的语义，比如<code>&lt;h1&gt; </code>只表明这是一个标题，<code>&lt;p&gt; </code>只表明这是一个段落等。</p>
<p>只用HTML时，网页显示效果很不好看。因为HTML可以做简单的样式，但是十分繁琐和臃肿。</p>
<p><strong>即，HTML主要做结构，显示元素内容。</strong></p>
<h4 id="1-2-CSS的作用"><a href="#1-2-CSS的作用" class="headerlink" title="1.2 CSS的作用"></a>1.2 CSS的作用</h4><p>CSS是层叠样式表的简称，也成为CSS样式表或级联样式表。</p>
<p>CSS也是一种标记语言，主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。</p>
<p><strong>简单来说，CSS可以美化HTML，让页面布局更简单。</strong></p>
<h4 id="1-3-CSS语法规范"><a href="#1-3-CSS语法规范" class="headerlink" title="1.3 CSS语法规范"></a>1.3 CSS语法规范</h4><p>CSS规则有两个主要部分组成：选择器以及一条或多条声明。</p>
<p><code>选择器 &#123;属性:值 属性:值&#125;</code></p>
<p>选择器是用于指定CSS样式的HTML标签，花括号内是对该对象设置的具体样式。</p>
<p>属性和属性值以“键值对”的形式出现</p>
<h4 id="1-4-CSS代码风格"><a href="#1-4-CSS代码风格" class="headerlink" title="1.4 CSS代码风格"></a>1.4 CSS代码风格</h4><p>代码风格推荐</p>
<ol>
<li><p>样式格式书写</p>
<ul>
<li><p>展开格式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">h3 &#123;</span><br><span class="line">	color: blue;</span><br><span class="line">	font-size: 12px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>样式大小写</p>
<ul>
<li>样式选择器，属性名，属性值关键字全部使用小写字母，特殊情况除外。</li>
</ul>
</li>
<li><p>空格规范</p>
<ul>
<li>在属性值前面，冒号后面，保留一个空格；</li>
<li>选择器和大括号中间保留空格</li>
</ul>
</li>
</ol>
<h2 id="二、CSS基础选择器"><a href="#二、CSS基础选择器" class="headerlink" title="二、CSS基础选择器"></a>二、CSS基础选择器</h2><h4 id="2-1-CSS选择器的作用"><a href="#2-1-CSS选择器的作用" class="headerlink" title="2.1 CSS选择器的作用"></a>2.1 CSS选择器的作用</h4><p>选择器就是根据不同需求把不同的标签选出来，这就是选择器的作用，简单来说，<strong>就是选择标签用的</strong>。</p>
<h4 id="2-2-选择器的分类"><a href="#2-2-选择器的分类" class="headerlink" title="2.2 选择器的分类"></a>2.2 选择器的分类</h4><p>选择器分为<strong>基础选择器和复合选择器</strong></p>
<p>其中，基础选择器是由单个选择器组成的</p>
<p>基础选择器又包括：标签选择器、类选择器、id选择器和通配符选择器</p>
<h4 id="2-3-标签选择器"><a href="#2-3-标签选择器" class="headerlink" title="2.3 标签选择器"></a>2.3 标签选择器</h4><p>使用<strong>HTML标签名</strong>作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。</p>
<p><strong>语法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">标签名 &#123;</span><br><span class="line">	属性1: 属性值1;</span><br><span class="line">	属性2: 属性值2;</span><br><span class="line">	属性3: 属性值3;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：把某一类标签全部选择出来，例如所有的<code>&lt;div&gt;</code>标签，所有的<code>&lt;p&gt;</code>标签。</p>
<p><strong>优点</strong></p>
<p>能快速为页面中同类型的标签统一设置样式。</p>
<p><strong>缺点</strong></p>
<p>不能差异化设置，只能选择全部的当前标签。</p>
<h4 id="2-4-类选择器"><a href="#2-4-类选择器" class="headerlink" title="2.4 类选择器"></a>2.4 类选择器</h4><p>如果想要差异化选择不同的标签，单独选一个或者选几个标签，可以使用类选择器。</p>
<p><strong>语法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.类名 &#123;</span><br><span class="line">	属性1: 属性值1;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.red &#123;</span><br><span class="line">	color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=`<span class="attr">red</span>`&gt;</span> 红色 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> <strong>类选择器口诀</strong>：样式点定义，结构类调用，一个或多个，开发最常用。</p>
</blockquote>
<p><strong>注意事项</strong></p>
<ol>
<li>长名称或词组可以使用短横线来表示。</li>
<li>不要使用纯数字、中文等命名，尽量使用英文字母来表示。</li>
<li>命名要有意义，尽量使别人一眼就知道这个类名的目的。</li>
</ol>
<p><strong>多类名</strong></p>
<p>我们可以给一个标签指定多个类名，从而达到更多的选择目的，这些类名都可以选出这个标签，简单理解就是一个标签有多个名字。</p>
<ol>
<li><p>多类名使用方式</p>
<p><code>&lt;div class=&quot;red fong35&quot;&gt;Huffie&lt;/div&gt;</code></p>
<ul>
<li>在标签class属性中写多个类名</li>
<li>多个类名中间必须用空格分开</li>
<li>这个标签就可以分别具有这些类名的样式</li>
</ul>
</li>
<li><p>多类名的优点</p>
<ul>
<li>节省CSS代码，统一修改也非常方便</li>
<li>多类名选择器在后期布局比较复杂的情况下，使用比较多</li>
</ul>
</li>
</ol>
<h4 id="2-5-id选择器"><a href="#2-5-id选择器" class="headerlink" title="2.5 id选择器"></a>2.5 id选择器</h4><p>id选择器可以为标有特定id的HTML元素指定特定的样式</p>
<p>HTML元素以<strong>id属性</strong>来设置id选择器，CSS中id选择器以”<strong>#</strong>“来定义</p>
<p><strong>语法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#id名&#123;</span><br><span class="line">	属性: 属性值1;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>口诀：样式#定义，结构id调用，只能调用一次，别人切勿使用</p>
</blockquote>
<h4 id="2-6-通配符选择器"><a href="#2-6-通配符选择器" class="headerlink" title="2.6 通配符选择器"></a>2.6 通配符选择器</h4><p>在CSS中，通配符选择器使用”*”定义，他表示选取页面中的所有元素</p>
<p><strong>语法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">	属性1: 属性值1;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通配符选择器不需要调用，自动就给所有的元素使用样式</li>
<li>特殊情况下才使用</li>
</ol>
<h4 id="2-7-基础选择器总结"><a href="#2-7-基础选择器总结" class="headerlink" title="2.7 基础选择器总结"></a>2.7 基础选择器总结</h4><table>
<thead>
<tr>
<th>基础选择器</th>
<th>作用</th>
<th>特点</th>
<th>使用情况</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>标签选择器</td>
<td>可以选出所有相同的标签</td>
<td>不能差异化选择</td>
<td>较多</td>
<td>p {color: red;}</td>
</tr>
<tr>
<td>类选择器</td>
<td>可以选出1个或多个标签</td>
<td>可以根据需求选择</td>
<td>非常多</td>
<td>.nav{color: red;}</td>
</tr>
<tr>
<td>id选择器</td>
<td>一次只能选择1个标签</td>
<td>ID属性只能在每个HTML文档中出现一次</td>
<td>一般和js搭配</td>
<td>#nav{color: red;}</td>
</tr>
<tr>
<td>通配符选择器</td>
<td>选择所有标签</td>
<td>选择的太多，有部分不需要</td>
<td>特殊情况使用</td>
<td>* {color: red;}</td>
</tr>
</tbody></table>
<h2 id="三、CSS字体属性"><a href="#三、CSS字体属性" class="headerlink" title="三、CSS字体属性"></a>三、CSS字体属性</h2><p>CSS Fonts字体属性用于定义字体系列、大小、粗细和文字样式。</p>
<h4 id="3-1-字体系列"><a href="#3-1-字体系列" class="headerlink" title="3.1 字体系列"></a>3.1 字体系列</h4><p>CSS使用<strong>font-family</strong>属性定义文本的字体系列。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">h2 &#123;font-family: &quot;Microsoft Yahei&quot;;&#125;</span><br><span class="line">p &#123;font-family: Arial, &quot;Times New Roman&quot;;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以写多个字体，字体之间用英文逗号分隔</p>
<p>浏览器会优先使用第一个字体，如果用户电脑上没有安装第一个字体，则会按顺序检索。</p>
</li>
<li><p>如果字体名由多个单词组成，用引号包含</p>
</li>
<li><p>尽量使用系统默认的字体，保证任何用户的浏览器都能正确显示</p>
<p>常用字体：”Microsoft Yahei”, tahoma, arial, “Hiragino Sans GB”</p>
</li>
</ul>
<h4 id="3-2-字体大小"><a href="#3-2-字体大小" class="headerlink" title="3.2 字体大小"></a>3.2 字体大小</h4><p>CSS使用font-size属性定义字体大小</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">p &#123;font-size 20px;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>谷歌浏览器默认文字大小为16px</li>
<li>不同浏览器可能默认现实的字号大小不一致，我们尽量给字体大小一个明确值</li>
<li>可以给body指定整个页面文字的大小</li>
</ul>
<h4 id="3-3-字体粗细"><a href="#3-3-字体粗细" class="headerlink" title="3.3 字体粗细"></a>3.3 字体粗细</h4><p>CSS使用font-weight属性设置文本字体的粗细</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.bold &#123;font-weight: bold;&#125;</span><br><span class="line">.bold &#123;font-weight: 700;&#125;</span><br></pre></td></tr></table></figure>

<p>参数：normal正常，bold加粗，数字100-900也可表示字体粗细</p>
<p>实际开发中我们提倡使用数字：<strong>400 正常，700 加粗</strong></p>
<h4 id="3-4-文字样式"><a href="#3-4-文字样式" class="headerlink" title="3.4 文字样式"></a>3.4 文字样式</h4><p>CSS使用font-style属性设置文本的风格</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>默认值，浏览器会显示标准的字体样式</td>
</tr>
<tr>
<td>italic</td>
<td>浏览器会显示斜体的字体样式</td>
</tr>
</tbody></table>
<p>注意：我们很少给文字加斜体，反而要给斜体标签(em, i)改为正常</p>
<h4 id="3-5-字体复合属性"><a href="#3-5-字体复合属性" class="headerlink" title="3.5 字体复合属性"></a>3.5 字体复合属性</h4><p>字体属性可以把文字样式综合起来写，这样可以更节约代码</p>
<p><strong>语法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div &#123;font: font-style font-weight font-size/line-height font-family;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">font: italic 700 16px &quot;Microsoft Yahei&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用font属性时，必须按照上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开</li>
<li>不需要设置属性可以省略，但必须保留font-size和font-family属性，否则font属性不起作用</li>
</ul>
<h4 id="3-6-字体属性总结"><a href="#3-6-字体属性总结" class="headerlink" title="3.6 字体属性总结"></a>3.6 字体属性总结</h4><table>
<thead>
<tr>
<th>属性</th>
<th>表示</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>font-size</td>
<td>字号</td>
<td>通常的单位是px像素，一定要加单位</td>
</tr>
<tr>
<td>font-family</td>
<td>字体</td>
<td>“Microsoft Yahei”, tahoma, arial, “Hiragino Sans GB”</td>
</tr>
<tr>
<td>font-weight</td>
<td>粗细</td>
<td>加粗是700/bold，不加粗是400/normal，数字没有单位</td>
</tr>
<tr>
<td>font-style</td>
<td>样式</td>
<td>倾斜是italic，正常是normal，常用normal</td>
</tr>
<tr>
<td>font</td>
<td>复合属性</td>
<td>符合属性是有顺序的，不能随意换位置，字号和字体必须有</td>
</tr>
</tbody></table>
<h2 id="四、CSS文本属性"><a href="#四、CSS文本属性" class="headerlink" title="四、CSS文本属性"></a>四、CSS文本属性</h2><p>CSS Text文本属性可以定义文本的外观，别如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。</p>
<h4 id="4-1-文本颜色"><a href="#4-1-文本颜色" class="headerlink" title="4.1 文本颜色"></a>4.1 文本颜色</h4><p><strong>color属性</strong>用于定义文本的颜色。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div &#123;color: red;&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>表示形式</th>
<th>属性值</th>
</tr>
</thead>
<tbody><tr>
<td>预定义的颜色值</td>
<td>red, green, blue, pink</td>
</tr>
<tr>
<td>十六进制</td>
<td>#FF0000, #123456, #666666</td>
</tr>
<tr>
<td>RGB代码</td>
<td>rgb(255,0,0)或rgb(100%,0%,0%)</td>
</tr>
</tbody></table>
<h4 id="4-2-对齐文本"><a href="#4-2-对齐文本" class="headerlink" title="4.2 对齐文本"></a>4.2 对齐文本</h4><p><strong>text-align属性</strong>用于设置元素内文本内容的水平对齐方式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div &#123;text-align: center;&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性值</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>左对齐（默认）</td>
</tr>
<tr>
<td>right</td>
<td>右对齐</td>
</tr>
<tr>
<td>center</td>
<td>居中</td>
</tr>
</tbody></table>
<h4 id="4-3-装饰文本"><a href="#4-3-装饰文本" class="headerlink" title="4.3 装饰文本"></a>4.3 装饰文本</h4><p><strong>text-decoration属性</strong>规定添加到文本的装饰，可以给文本添加下划线、删除线、上划线等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div &#123;text-decoration: underline;&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>无（最常用，超链接去下划线）</td>
</tr>
<tr>
<td>underline</td>
<td>下划线（常用）</td>
</tr>
<tr>
<td>overline</td>
<td>上划线（几乎不用）</td>
</tr>
<tr>
<td>line-through</td>
<td>删除线（几乎不用）</td>
</tr>
</tbody></table>
<h4 id="4-4-文本缩进"><a href="#4-4-文本缩进" class="headerlink" title="4.4 文本缩进"></a>4.4 文本缩进</h4><p><strong>text-indent属性</strong>用来指定文本的第一行的缩进，通常是将段落的首行缩进。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">p &#123;text-indent: 2em;&#125;</span><br></pre></td></tr></table></figure>

<p>通过设置该属性，该元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值。</p>
<p>em是一个相对单位，是当前元素的文字大小。</p>
<h4 id="4-5-行间距"><a href="#4-5-行间距" class="headerlink" title="4.5 行间距"></a>4.5 行间距</h4><p><strong>line-height属性</strong>用于设置行间的距离（行高），可以控制文字行与行之间的距离</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">p &#123;line-height: 26px;&#125;</span><br></pre></td></tr></table></figure>

<p>行间距=上间距+文本高度+下间距，行高改变的是上下两个间距。</p>
<h4 id="4-6-文本属性总结"><a href="#4-6-文本属性总结" class="headerlink" title="4.6 文本属性总结"></a>4.6 文本属性总结</h4><table>
<thead>
<tr>
<th>属性</th>
<th>表示</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>文本颜色</td>
<td>通常使用16进制</td>
</tr>
<tr>
<td>text-align</td>
<td>文本对齐</td>
<td>可以设定文字水平的对齐方式</td>
</tr>
<tr>
<td>text-indent</td>
<td>文本缩进</td>
<td>用于设定段落首行缩进两字符 text-indent: 2em</td>
</tr>
<tr>
<td>text-decoration</td>
<td>文本修饰</td>
<td>添加下划线underline，取消下划线none</td>
</tr>
<tr>
<td>line-height</td>
<td>行高</td>
<td>控制行与行的距离</td>
</tr>
</tbody></table>
<h2 id="五、CSS的引入方式"><a href="#五、CSS的引入方式" class="headerlink" title="五、CSS的引入方式"></a>五、CSS的引入方式</h2><h4 id="5-1-CSS的三种样式表"><a href="#5-1-CSS的三种样式表" class="headerlink" title="5.1 CSS的三种样式表"></a>5.1 CSS的三种样式表</h4><p>按照CSS样式书写的位置（或者引入的样式），CSS样式表可以分为三大类：</p>
<ol>
<li>行内样式表（行内式）</li>
<li>内部样式表（嵌入式）</li>
<li>外部样式表（链接式）</li>
</ol>
<h4 id="5-2-内部样式表"><a href="#5-2-内部样式表" class="headerlink" title="5.2 内部样式表"></a>5.2 内部样式表</h4><p>内部样式表是写到html页面内部，将所有的CSS代码抽取出来，单独放到一个<code>&lt;style&gt;</code>标签中。内部样式表设定CSS，也被称为嵌入式引入。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>理论上<code>&lt;style&gt;</code>标签可以放到任何位置，但一般放在<code>&lt;head&gt;</code>标签。</li>
<li>这种方式可以控制整个页面的元素样式</li>
<li>代码结构清晰，但并没有实现结构和样式的完全分离</li>
</ul>
<h4 id="5-3-行内样式表"><a href="#5-3-行内样式表" class="headerlink" title="5.3 行内样式表"></a>5.3 行内样式表</h4><p>行内样式表是在元素标签内部的style属性中设定CSS杨适。适合于修改简单样式。通常也称为行内式引入。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>Hello world.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>style其实就是标签的属性</li>
<li>在双引号中间，写法要符合CSS规范</li>
<li>只可以控制当前标签样式</li>
<li>书写过于繁琐，不推荐大量使用，只有对当前元素添加简单样式的时候考虑使用。</li>
</ul>
<h4 id="5-4-外部样式表"><a href="#5-4-外部样式表" class="headerlink" title="5.4 外部样式表"></a>5.4 外部样式表</h4><p>实际开发都是外部样式表，适合样式比较多的情况，核心是：样式单独写到CSS文件中，之后把CSS文件引入到HTML页面中使用。</p>
<p>引入外部样式表分为两步：</p>
<ol>
<li>新建一个后缀名为.css的样式文件，把所有CSS代码都放入此文件中。</li>
<li>在HTML页面中，使用<code>&lt;link&gt;</code>标签引入这个文件</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css文件路径&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>rel</td>
<td>定义当前文档与被链接文档之间的关系，这里需要指定为”stylesheet”，即被链接的文档是一个样式表文件</td>
</tr>
<tr>
<td>href</td>
<td>定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径</td>
</tr>
</tbody></table>
<h4 id="5-5-CSS引入方式总结"><a href="#5-5-CSS引入方式总结" class="headerlink" title="5.5 CSS引入方式总结"></a>5.5 CSS引入方式总结</h4><table>
<thead>
<tr>
<th>样式表</th>
<th>优点</th>
<th>缺点</th>
<th>使用情况</th>
<th>控制范围</th>
</tr>
</thead>
<tbody><tr>
<td>行内样式表</td>
<td>书写方便，权重高</td>
<td>结构样式混写</td>
<td>较少</td>
<td>控制一个标签</td>
</tr>
<tr>
<td>内部样式表</td>
<td>部分结构和样式相分离</td>
<td>没有彻底分离</td>
<td>较多</td>
<td>控制一个页面</td>
</tr>
<tr>
<td>外部样式表</td>
<td>完全实现结构和样式相分离</td>
<td>需要引入</td>
<td>最多</td>
<td>控制多个页面</td>
</tr>
</tbody></table>
<h2 id="六、Chrome调试工具"><a href="#六、Chrome调试工具" class="headerlink" title="六、Chrome调试工具"></a>六、Chrome调试工具</h2><p>Chrome浏览器提供了一个非常好用的调试工具，可以用来调试我们的HTML结构和CSS样式。</p>
<h4 id="6-1-打开调试工具"><a href="#6-1-打开调试工具" class="headerlink" title="6.1 打开调试工具"></a>6.1 打开调试工具</h4><p>在页面右键点击审查元素，或者按F12</p>
<h4 id="6-2-使用调试工具"><a href="#6-2-使用调试工具" class="headerlink" title="6.2 使用调试工具"></a>6.2 使用调试工具</h4><ol>
<li>左边是HTML，右边是CSS杨适</li>
<li>使用<code>Ctrl+滚轮</code>可以放大代码字体大小</li>
<li>右边CSS样式可以改动数值和查看颜色</li>
<li><code>Ctrl+0</code>复原浏览器大小</li>
<li>如果点击元素，发现右侧没有样式引入，极有可能是类名或者样式引入错误</li>
<li>如果有样式，但是样式前面有黄色感叹号提示，则是样式属性书写错误</li>
</ol>
<blockquote>
<p>本文参考了黑马程序员pink老师的视频教程<br>        <strong>黑马程序员pink老师前端入门视频教程：</strong> <a href="https://www.bilibili.com/video/BV14J4114768">https://www.bilibili.com/video/BV14J4114768</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>前端笔记 | CSS进阶</title>
    <url>/2021/03/14/081-%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%20%20CSS%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="一、CSS的复合选择器"><a href="#一、CSS的复合选择器" class="headerlink" title="一、CSS的复合选择器"></a>一、CSS的复合选择器</h2><h4 id="1-1-复合选择器"><a href="#1-1-复合选择器" class="headerlink" title="1.1 复合选择器"></a>1.1 复合选择器</h4><p>CSS中根据选择器的类型把选择器分为基础选择器和复合选择器，复合选择器是建立在基础选择器之上，对基本选择器进行组合而成的。</p>
<ul>
<li><p>复合选择器可以更准确、更高效的选择目标标签</p>
</li>
<li><p>复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的。</p>
</li>
<li><p>常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等等</p>
</li>
</ul>
<h4 id="1-2-后代选择器"><a href="#1-2-后代选择器" class="headerlink" title="1.2 后代选择器"></a>1.2 后代选择器</h4><p>后代选择器又称包含选择器，可以选择父元素里面的子元素。其写法就是把<strong>外层元素写在前面</strong>，<strong>内层元素写在后面</strong>，<strong>中间用空格分离</strong>。放标签发生嵌套时，内层标签就成为外层标签的后代。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">元素1 元素2 &#123;属性1: 属性值1...&#125;</span><br></pre></td></tr></table></figure>

<p>上述语法表示：<strong>选择元素1里面的所有元素2</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 例:选择ul里面所有li标签 --&gt;</span></span><br><span class="line">ul li &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>元素2可以是子元素，也可是子元素的子元素,只要是元素1的后代即可</p>
</li>
<li><p>元素1和元素2可以是任意基础选择器，例如<code>.nav li a</code> {}</p>
</li>
</ul>
<h4 id="1-3-子选择器"><a href="#1-3-子选择器" class="headerlink" title="1.3 子选择器"></a>1.3 子选择器</h4><p>子元素选择器，只能选择某元素的最近一级元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">元素1&gt;元素2 &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure>

<p>上述语法表示：<strong>选择元素1里面的所有直接后代元素2</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 例:选择div里面所有最近一级p标签 --&gt;</span></span><br><span class="line">div&gt;p &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-并集选择器"><a href="#1-4-并集选择器" class="headerlink" title="1.4 并集选择器"></a>1.4 并集选择器</h4><p>并集选择器可以选择多组标签，通常用于集体声明</p>
<p>并集选择器是各选择器通过<strong>英文逗号“，”连接而成</strong>，<strong>任何形式的选择器都可以</strong>作为并集选择器的一部分</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">元素1, 元素2 &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure>

<p>上述语法表示<strong>选择元素1和元素2</strong></p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 选择u1和div标签元素 --&gt;</span></span><br><span class="line">u1, div &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-伪类选择器"><a href="#1-5-伪类选择器" class="headerlink" title="1.5 伪类选择器"></a>1.5 伪类选择器</h4><p>伪类选择器用于向某些选择器添加特殊效果，比如给链接添加特殊效果，或者选择第1个，第n个元素</p>
<p>伪类选择器书写的最大特点是用**冒号“:”表示，比如<code>:first-child</code>，<code>:hover</code></p>
<p>伪类选择器有很对，如链接伪类、结构伪类等。</p>
<p><strong>（1）链接伪类选择器</strong></p>
<p>链接伪类选择器常用于，鼠标经过链接时，链接的颜色或其他样式发生改变。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>a:link</td>
<td>选择所有未被访问的链接</td>
</tr>
<tr>
<td>a:visited</td>
<td>选择所有已被访问的链接</td>
</tr>
<tr>
<td>a:hover</td>
<td>选择鼠标指针位于其上的链接</td>
</tr>
<tr>
<td>a:active</td>
<td>选择活动链接（鼠标按下未弹起的链接）</td>
</tr>
</tbody></table>
<p>注意事项：</p>
<ul>
<li>为了确保生效，请按照<strong>LVHA</strong>的顺序声明：link - visited - hover active</li>
<li>因为a链接在浏览器中有默认的样式，因此实际工作中都需要给链接单独指定样式</li>
</ul>
<p>例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">	color: gray;</span><br><span class="line">	text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a:hover &#123;</span><br><span class="line">	color: skyblue;</span><br><span class="line">	text-decoration: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）:focus伪类选择器</strong></p>
<p><strong>:focus伪类选择器</strong>用于选取获得焦点的表单元素</p>
<p>焦点就是光标，一般情况<code>&lt;input&gt;</code>类表单元素才能获取，因此这个选择器也主要针对表单元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">input:focus &#123;</span><br><span class="line">	background-color: skyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-复合选择器总结"><a href="#1-6-复合选择器总结" class="headerlink" title="1.6 复合选择器总结"></a>1.6 复合选择器总结</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>作用</th>
<th>特征</th>
<th>使用情况</th>
<th>隔开符号及用法</th>
</tr>
</thead>
<tbody><tr>
<td>后代选择器</td>
<td>用来选择后代元素</td>
<td>可以是子、孙</td>
<td>较多</td>
<td>符号是<strong>空格</strong>，.nav a</td>
</tr>
<tr>
<td>子代选择器</td>
<td>选择最近一级元素</td>
<td>只选子</td>
<td>较少</td>
<td>符号是<strong>大于</strong>，.nav&gt;p</td>
</tr>
<tr>
<td>并集选择器</td>
<td>选择某些相同样式的元素</td>
<td>可以用于集体声明</td>
<td>较多</td>
<td>符号是<strong>逗号</strong>，.nav, .header</td>
</tr>
<tr>
<td>链接伪类选择器</td>
<td>选择不同状态的链接</td>
<td>跟链接相关</td>
<td>较多</td>
<td>重点记住a{}和a:hover实际开发的写法</td>
</tr>
<tr>
<td>:focus选择器</td>
<td>选择获得光标的表单</td>
<td>跟表单相关</td>
<td>较少</td>
<td>input:focus</td>
</tr>
</tbody></table>
<h2 id="二、CSS的元素显示模式"><a href="#二、CSS的元素显示模式" class="headerlink" title="二、CSS的元素显示模式"></a>二、CSS的元素显示模式</h2><h4 id="2-1-什么是元素显示模式"><a href="#2-1-什么是元素显示模式" class="headerlink" title="2.1 什么是元素显示模式"></a>2.1 什么是元素显示模式</h4><p>网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好地布局我们的网页。</p>
<p>元素显示模式就是元素（标签）以什么形式进行显示，比如<code>&lt;div&gt;</code>自己占一行，而一行可以放多个<code>&lt;span&gt;</code></p>
<p>HTML元素一般分为<strong>块元素</strong>和<strong>行内元素</strong>两种类型</p>
<h4 id="2-2-块元素"><a href="#2-2-块元素" class="headerlink" title="2.2 块元素"></a>2.2 块元素</h4><p>常见的块元素有 <code>&lt;h1&gt;~&lt;h6&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>等，其中<code>div</code>是最典型的块元素</p>
<ul>
<li>块元素子集独占一行</li>
<li>高度，宽度，外边距，内边距都可以控制</li>
<li>宽度默认是容器父级的100%</li>
<li>是一个容器或盒子，里面可以放行内元素或块元素</li>
</ul>
<p>注意：文字类的元素内不能使用块级元素，<code>&lt;p&gt;</code>内不能放块级元素<code>&lt;div&gt;</code>等，同理<code>&lt;h1&gt;~&lt;h6&gt;</code>等都是文字类块级标签，里面也不能放其他块级元素。</p>
<h4 id="2-3-行内元素"><a href="#2-3-行内元素" class="headerlink" title="2.3 行内元素"></a>2.3 行内元素</h4><p>常见的行内元素有<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;b&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;i&gt;</code>、<code>&lt;del&gt;</code>、<code>&lt;s&gt;</code>、<code>&lt;ins&gt;</code>、<code>&lt;u&gt;</code>、<code>&lt;span&gt;</code>等，其中<code>&lt;span&gt;</code>是最典型的行内元素，有些地方也称行内元素为内联元素。</p>
<ul>
<li>相邻行内元素在一行上，一行可以放多个行内元素</li>
<li>高、宽直接设置是无效的</li>
<li>默认宽度就是本身内容的宽度</li>
<li>行内元素只能容纳文本或其他行内元素</li>
</ul>
<p>注意：链接里面不能再放链接，但特殊情况下a标签内可以放块级元素。</p>
<h4 id="2-4-行内块元素"><a href="#2-4-行内块元素" class="headerlink" title="2.4 行内块元素"></a>2.4 行内块元素</h4><p>在行内元素中有几个特殊的标签：<code>&lt;img&gt;</code>、<code>&lt;imput&gt;</code>、<code>&lt;td&gt;</code>，他们同时具有块元素和行内元素的特点。</p>
<ul>
<li>和相邻行内元素或行内块元素在一行上，但是它们之间会有空隙，一行可以显示多个</li>
<li>默认宽度是本身内容的宽度</li>
<li>高度、行高、外边距和内边距都可以控制</li>
</ul>
<h4 id="2-5-元素显示模式总结"><a href="#2-5-元素显示模式总结" class="headerlink" title="2.5 元素显示模式总结"></a>2.5 元素显示模式总结</h4><table>
<thead>
<tr>
<th>元素模式</th>
<th>元素排列</th>
<th>设置样式</th>
<th>默认宽度</th>
<th>包含</th>
</tr>
</thead>
<tbody><tr>
<td>块级元素</td>
<td>一行只能放一个块级元素</td>
<td>可以设置宽度高度</td>
<td>容器的100%</td>
<td>可以包含任何标签</td>
</tr>
<tr>
<td>行内元素</td>
<td>一行可以放多个行内元素</td>
<td>不可以直接设置宽度高度</td>
<td>本身内容的宽度</td>
<td>只可以包含行内元素</td>
</tr>
<tr>
<td>行内块元素</td>
<td>一行可以放多个行内块元素</td>
<td>可以直接设置宽度高度</td>
<td>本身内容的宽度</td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-6-元素显示模式的转换"><a href="#2-6-元素显示模式的转换" class="headerlink" title="2.6 元素显示模式的转换"></a>2.6 元素显示模式的转换</h4><p>特殊情况下，我们需要元素模式的转换，简单理解就是，一个模式的元素需要另外一种模式的特性</p>
<p>例如，想要增大链接<code>&lt;a&gt;</code>的触发范围</p>
<p><strong>转换为块元素：<code>display:block</code></strong></p>
<p>转换为行内元素：<code>display:inline</code></p>
<p><strong>转换为行内块元素：<code>display:inline-block</code></strong></p>
<p>例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、CSS的背景"><a href="#三、CSS的背景" class="headerlink" title="三、CSS的背景"></a>三、CSS的背景</h2><p>通过CSS背景属性可以为页面内元素添加背景样式</p>
<p>背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。</p>
<h4 id="3-1-背景颜色"><a href="#3-1-背景颜色" class="headerlink" title="3.1 背景颜色"></a>3.1 背景颜色</h4><p><strong>background-color</strong> 可以设置背景颜色</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">background-color: 颜色值</span><br></pre></td></tr></table></figure>

<p>颜色参数：transparent 透明（默认）或color</p>
<h4 id="3-2-背景图片"><a href="#3-2-背景图片" class="headerlink" title="3.2 背景图片"></a>3.2 背景图片</h4><p><strong>background-image</strong> 属性描述了元素的背景图像。实际开发常见于logo或者一些装饰性的小图片或者超大的背景图片，优点是非常便于控制位置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">background-image: none|url</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>无背景（默认）</td>
</tr>
<tr>
<td>url</td>
<td>使用绝对或相对地址指定背景图像</td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	width: 300px;</span><br><span class="line">	height: 300px;</span><br><span class="line">	background-image: url(images/background.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-背景平铺"><a href="#3-3-背景平铺" class="headerlink" title="3.3 背景平铺"></a>3.3 背景平铺</h4><p><strong>background-repeat</strong> 使HTML页面上对背景图像进行平铺</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">background-repeat: repeat | no-repeat | repeat-x | repeat-y</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>repeat</td>
<td>背景图像在纵向和横向上平铺（默认）</td>
</tr>
<tr>
<td>no-repeat</td>
<td>背景图像不平铺</td>
</tr>
<tr>
<td>repeat-x</td>
<td>背景图像在横向平铺</td>
</tr>
<tr>
<td>repeat-y</td>
<td>背景图像在纵向平铺</td>
</tr>
</tbody></table>
<p>页面元素既可以添加背景颜色，也可以添加背景图片，背景图片在上层。</p>
<h4 id="3-4-背景位置"><a href="#3-4-背景位置" class="headerlink" title="3.4 背景位置"></a>3.4 背景位置</h4><p><strong>background-position</strong> 可以改变图片在背景中的位置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">background-position: x y;</span><br></pre></td></tr></table></figure>

<p>参数是：x坐标和y坐标，可以使用方位名词或者精确单位</p>
<table>
<thead>
<tr>
<th>参数值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>百分数|由浮点数字和单位标识符组成的长度值</td>
</tr>
<tr>
<td>position</td>
<td>top|center|bottom|left|center|right 等方位名词</td>
</tr>
</tbody></table>
<p><strong>（1）参数为方位名词</strong></p>
<ul>
<li>如果指定的两个词都是方位名词，则两个值前后顺序无关，比如left top和top left效果一致</li>
<li>如果只指定了一个方位名词，另一个忽略，则第二个默认居中对齐</li>
</ul>
<p><strong>（2）参数为精确单位</strong></p>
<ul>
<li>如果参数值是精确坐标，那么第一个一定是x坐标，第二个一定是y坐标</li>
<li>如果只指定了一个数值，则数值一定指x，y坐标默认垂直居中</li>
</ul>
<p><strong>（3）参数为混合单位</strong></p>
<ul>
<li>如果指定的两个值是精确单位和方位名词混合使用，第一个值一定是x坐标，第二个是y坐标</li>
</ul>
<h4 id="3-5-背景固定"><a href="#3-5-背景固定" class="headerlink" title="3.5 背景固定"></a>3.5 背景固定</h4><p><strong>background-attachment</strong> 属性设置背景图像是否固定或者随着页面的区域部分滚动，可以制作视差滚动的效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">background-attachment: scroll | fixed</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>scroll</td>
<td>背景图像是否随对象内容滚动（默认）</td>
</tr>
<tr>
<td>fixed</td>
<td>背景图像固定</td>
</tr>
</tbody></table>
<h4 id="3-6-背景属性复合写法"><a href="#3-6-背景属性复合写法" class="headerlink" title="3.6 背景属性复合写法"></a>3.6 背景属性复合写法</h4><p>为了简化背景属性的代码，我们可以将这些属性合并简写在同一个background属性中，减少代码量。</p>
<p>当使用简写属性时，没有特定的书写顺序，一般习惯约定顺序为：</p>
<p><strong>background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置</strong></p>
<p>例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">background: transparent url(image.jpg) repeat-none fixed top center</span><br></pre></td></tr></table></figure>

<h4 id="3-7-背景色半透明"><a href="#3-7-背景色半透明" class="headerlink" title="3.7 背景色半透明"></a>3.7 背景色半透明</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">background: rgba(0, 0, 0, 0.3);</span><br></pre></td></tr></table></figure>

<p>四个参数分别为<strong>r，g，b和alpha透明度</strong>，最后一个alpha透明度取值范围为0~1，0代表完全透明。</p>
<p>此属性只是让背景颜色半透明，里面的内容不受影响。</p>
<h4 id="3-8-背景总结"><a href="#3-8-背景总结" class="headerlink" title="3.8 背景总结"></a>3.8 背景总结</h4><table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>background-color</td>
<td>背景颜色</td>
<td>预定义的颜色值/十六进制/RGB代码</td>
</tr>
<tr>
<td>background-image</td>
<td>背景图片</td>
<td>url(图片路径)</td>
</tr>
<tr>
<td>background-repeat</td>
<td>是否平铺</td>
<td>repeat/no-repeat/repeat-x/repeat-y</td>
</tr>
<tr>
<td>background-position</td>
<td>背景位置</td>
<td>length/position 分别是x 和 y坐标</td>
</tr>
<tr>
<td>background-attachment</td>
<td>背景附着</td>
<td>scroll背景滚动、fixed背景固定</td>
</tr>
<tr>
<td>背景简写</td>
<td>减少代码量</td>
<td>背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置</td>
</tr>
<tr>
<td>背景色半透明</td>
<td>颜色半透明</td>
<td>background: rgba(0,0,0,0.3);</td>
</tr>
</tbody></table>
<p>背景图片：实际开发中常用于装饰性的小图片，或者超大的背景图片，优点是非常便于控制位置。</p>
<h2 id="四、CSS三大特性"><a href="#四、CSS三大特性" class="headerlink" title="四、CSS三大特性"></a>四、CSS三大特性</h2><p>CSS由三个非常重要的特性：层叠性、继承性、优先级</p>
<h4 id="4-1-层叠性"><a href="#4-1-层叠性" class="headerlink" title="4.1 层叠性"></a>4.1 层叠性</h4><p>相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题。</p>
<p>层叠的原则是：</p>
<ul>
<li>样式冲突，遵循就近原则，哪个样式离结构近，就执行哪个样式</li>
<li>样式不冲突，则不会层叠</li>
</ul>
<h4 id="4-2-继承性"><a href="#4-2-继承性" class="headerlink" title="4.2 继承性"></a>4.2 继承性</h4><p>子标签会继承父标签的某些样式，如文本颜色和字号等。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>div内的p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时如果设置div的样式，则p标签也会继承div的样式。</p>
<p>可继承的样式有：text-，font-，line-这些元素开头的可以继承，以及color属性。</p>
<p><strong>行高的继承性</strong>：</p>
<p>行高可以跟单位，也可以不跟单位</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">	font: 12px/1.5;</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">	font-size: 14px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的1.5代表当前元素文字大小的1.5倍。即div中的行高是21px，body中其它标签的行高默认是18px。</p>
<h4 id="4-3-优先级"><a href="#4-3-优先级" class="headerlink" title="4.3 优先级"></a>4.3 优先级</h4><p>当同一个元素指定多个选择器，就会有优先级的产生。</p>
<ul>
<li>选择器相同，则执行层叠性</li>
<li>选择器不同，则根据选择器权重执行</li>
</ul>
<table>
<thead>
<tr>
<th>选择器</th>
<th>选择器权重</th>
</tr>
</thead>
<tbody><tr>
<td>继承 或 通配符选择器*</td>
<td>0,0,0,0</td>
</tr>
<tr>
<td>元素选择器</td>
<td>0,0,0,1</td>
</tr>
<tr>
<td>类选择器，伪类选择器</td>
<td>0,0,1,0</td>
</tr>
<tr>
<td>ID选择器</td>
<td>0,1,0,0</td>
</tr>
<tr>
<td>行内样式 style=””</td>
<td>1,0,0,0</td>
</tr>
<tr>
<td>!important</td>
<td>最大</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: skyblue <span class="meta">!important</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        </span></span><br><span class="line"><span class="css">        <span class="selector-class">.test</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: greenyellow;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        </span></span><br><span class="line"><span class="css">        <span class="selector-id">#demo</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: pink;&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>总而言之，<strong>作用范围越大，权重越低，作用范围越小，权重越高。</strong></p>
<p><strong>权重叠加</strong>：</p>
<p>如果是复合选择器，则会有权重叠加，需要计算权重</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ul内的li权重是0,0,0,1+0,0,0,1=0,0,0,2 */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: darkcyan;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* li的权重是0,0,0,1 */</span></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* .nav内的li权重是0,0,1,0+0,0,0,1=0,0,1,1 */</span></span><br><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>权重只会叠加，不会进位</li>
<li>权重比较是从左到右逐位进行比较</li>
</ul>
<blockquote>
<p>本文参考了黑马程序员pink老师的视频教程<br>        <strong>黑马程序员pink老师前端入门视频教程：</strong> <a href="https://www.bilibili.com/video/BV14J4114768">https://www.bilibili.com/video/BV14J4114768</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>前端笔记 | CSS盒子模型</title>
    <url>/2021/03/15/082-%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%20%20CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="一、盒子模型"><a href="#一、盒子模型" class="headerlink" title="一、盒子模型"></a>一、盒子模型</h2><p>网页布局学习有三大核心，盒子模型，浮动和定位，学习盒子模型可以帮助我们很好的布局页面。</p>
<h4 id="1-1-网页布局的本质"><a href="#1-1-网页布局的本质" class="headerlink" title="1.1 网页布局的本质"></a>1.1 网页布局的本质</h4><p>网页布局过程：</p>
<ol>
<li>先准备好相关的网页元素，网页元素基本都是盒子Box</li>
<li>利用CSS设置盒子样式，然后摆放到相应位置</li>
<li>往盒子里面装内容</li>
</ol>
<p>因此网页布局的本质：利用CSS摆盒子</p>
<h4 id="1-2-盒子模型的组成"><a href="#1-2-盒子模型的组成" class="headerlink" title="1.2 盒子模型的组成"></a>1.2 盒子模型的组成</h4><p>CSS盒子模型本质上是一个盒子，封装周围的HTML元素，它包括：边框、外边距、内边距和实际内容</p>
<ol>
<li>border边框</li>
<li>content内容</li>
<li>padding内边距</li>
<li>margin外边距</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210315114805168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-3-边框border"><a href="#1-3-边框border" class="headerlink" title="1.3 边框border"></a>1.3 边框border</h4><p><strong>boder</strong>可以设置元素的边框。边框有三部分组成：边框粗细、边框样式、边框颜色</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: border-width || border-style || border-color</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>border-width</td>
<td>定义边框粗细，单位是px</td>
</tr>
<tr>
<td>border-style</td>
<td>边框的样式（none默认无|solid实线|dashed虚线|dotted点线）</td>
</tr>
<tr>
<td>border-color</td>
<td>边框颜色（默认黑色）</td>
</tr>
</tbody></table>
<p><strong>（1）边框的复合写法：</strong>（没有顺序）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br></pre></td></tr></table></figure>

<p><strong>（2）边框的分开写法：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-top</span>: <span class="number">1px</span> solid red;</span><br></pre></td></tr></table></figure>

<p><strong>（3）表格的细线边框</strong></p>
<p><strong>border-collapse</strong>属性控制浏览器绘制表格边框的方式。（绘制表格时两个单元格的边框重叠在一起，边框宽度会变粗）</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>-collpse: collapse;</span><br></pre></td></tr></table></figure>

<ul>
<li>collpse单词是合并的意思</li>
<li>border-collapse: collapse;表示相邻边框合并在一起</li>
</ul>
<p><strong>（4）边框会影响盒子大小</strong></p>
<p>边框会额外增加盒子的实际大小，因此我们有两种方案解决：</p>
<ol>
<li>测量盒子大小的时候，不量边框</li>
<li>如果测量的时候包含了边框，则需要width/height减去边框宽度</li>
</ol>
<p>例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210315114900771.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-4-内边距padding"><a href="#1-4-内边距padding" class="headerlink" title="1.4 内边距padding"></a>1.4 内边距padding</h4><p>padding属性用于设置内边距，即边框与内容之间的距离。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>padding-left</td>
<td>左内边距</td>
</tr>
<tr>
<td>padding-right</td>
<td>右内边距</td>
</tr>
<tr>
<td>padding-top</td>
<td>上内边距</td>
</tr>
<tr>
<td>padding-bottom</td>
<td>下内边距</td>
</tr>
</tbody></table>
<p><strong>padding简写</strong>：</p>
<table>
<thead>
<tr>
<th>值的个数</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>padding: 5px;</td>
<td>1个值，代表上下左右都有5px内边距</td>
</tr>
<tr>
<td>padding: 5px 10px;</td>
<td>2个值，代表上下内边距是5px，左右内边距是10px</td>
</tr>
<tr>
<td>padding: 5px 10px 20px;</td>
<td>3个值，代表上内边距5px，左右内边距10px，下内边距20px</td>
</tr>
<tr>
<td>padding: 5px 10px 20px 30px;</td>
<td>4个值，上是5px，右是10px，下是20px，左是30px（顺时针）</td>
</tr>
</tbody></table>
<p><strong>padding影响了盒子实际大小</strong></p>
<p>如果盒子已经有了宽度和高度，此时再指定内边框，会增大盒子。即内容不变只能使盒子变大。</p>
<p>解决方案：width/height减去多出来的内边距大小</p>
<p>例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210315114945457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-5-外边距margin"><a href="#1-5-外边距margin" class="headerlink" title="1.5 外边距margin"></a>1.5 外边距margin</h4><p><strong>margin</strong>属性用于设置外边距，即控制盒子和盒子之间的距离</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>margin-left</td>
<td>左外边距</td>
</tr>
<tr>
<td>margin-right</td>
<td>右外边距</td>
</tr>
<tr>
<td>margin-top</td>
<td>上外边距</td>
</tr>
<tr>
<td>margin-bottom</td>
<td>下外边距</td>
</tr>
</tbody></table>
<p>margin的简写方式与padding一致。</p>
<p><strong>（1）外边距的典型应用</strong></p>
<p>margin可以让<strong>块级盒子水平居中</strong>，但必须满足两个条件：</p>
<ol>
<li>盒子必须指定宽度（width）</li>
<li>盒子左右的外边距都设置为auto。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123; <span class="attribute">width</span>: <span class="number">960px</span>; <span class="attribute">margin</span>: <span class="number">0</span> auto; &#125;</span><br></pre></td></tr></table></figure>

<p>以下三种写法都可以：</p>
<ul>
<li>margin-left:auto; margin-right:auto;</li>
<li>margin: auto;</li>
<li>margin: 0 auto;</li>
</ul>
<p><strong>行内元素或行内块元素水平居中</strong>：给父元素添加 text: align:center 即可。</p>
<p><strong>（2）外边距合并</strong></p>
<p>使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。</p>
<ol>
<li>相邻块元素垂直外边距的合并</li>
</ol>
<p>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则它们之间的垂直间距不是两者之和。<strong>取两个值中较大者，这种现象被称为相邻块元素垂直外边距的合并。</strong></p>
<p>解决方案：尽量只给一个盒子添加margin值。</p>
<ol start="2">
<li>嵌套块元素垂直外边距的塌陷</li>
</ol>
<p>对于两个嵌套关系（父子关系）的元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。 </p>
<p><img src="https://img-blog.csdnimg.cn/20210315115009679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>解决方案：</p>
<ol>
<li>为父元素定义上边框</li>
<li>为父元素定义上内边距</li>
<li>为父元素添加overflow:hidden</li>
</ol>
<h4 id="1-6-清除内外边距"><a href="#1-6-清除内外边距" class="headerlink" title="1.6 清除内外边距"></a>1.6 清除内外边距</h4><p>网页元素很多都带有默认的内外编剧，而且不同浏览器默认的值也不一致。因此我们在布局前，首先要清除网页元素的内外边距。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。</p>
<h2 id="二、特殊样式"><a href="#二、特殊样式" class="headerlink" title="二、特殊样式"></a>二、特殊样式</h2><h4 id="2-1-圆角边框"><a href="#2-1-圆角边框" class="headerlink" title="2.1 圆角边框"></a>2.1 圆角边框</h4><p>CSS3中新增了圆角边框杨适，这样我们的盒子就可以变圆角了。</p>
<p><strong>border-radius</strong>属性用于设置元素的外边框圆角</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>:length;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数值可以为数值或百分比</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>如果是正方形，想要设置为一个圆，把数值修改为高度或宽度的一般即可，或者直接写为50%</p>
<p>同理如果是个矩形，半径设置为高度的一般就成了圆角矩形</p>
</li>
<li><p>该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角。跟两个值，分别代表左上右下、右上左下。</p>
</li>
<li><p>圆角边框也可以分开写：如border-top-left-radius</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210315115044767.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-2-盒子阴影"><a href="#2-2-盒子阴影" class="headerlink" title="2.2 盒子阴影"></a>2.2 盒子阴影</h4><p>CSS3中新增了盒子阴影，可以使用box-shadown属性为盒子添加阴影。</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: h-shadow v-shadow blur spread color inset;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>h-shadow</td>
<td>必须。水平阴影的位置，允许负值。</td>
</tr>
<tr>
<td>v-shadow</td>
<td>必须。垂直阴影的位置，允许负值。</td>
</tr>
<tr>
<td>blur</td>
<td>可选。模糊距离。</td>
</tr>
<tr>
<td>spread</td>
<td>可选。阴影的尺寸。</td>
</tr>
<tr>
<td>color</td>
<td>可选。阴影的颜色。</td>
</tr>
<tr>
<td>inset</td>
<td>可选。将外部阴影outset改为内部阴影</td>
</tr>
</tbody></table>
<ul>
<li>默认是外阴影outset，但是不可以写outset，否则会使阴影失效</li>
<li>盒子阴影不占用空间，不影响其他盒子的位置</li>
</ul>
<p>例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span> -<span class="number">3px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210315115203844.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-3-文字阴影"><a href="#2-3-文字阴影" class="headerlink" title="2.3 文字阴影"></a>2.3 文字阴影</h4><p><strong>text-shadow</strong>属性可以将阴影应用于文本</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">text-shadow</span>: h-shadow v-show blur color;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>h-shadow</td>
<td>必须。水平阴影的位置，允许负值。</td>
</tr>
<tr>
<td>v-shadow</td>
<td>必须。垂直阴影的位置，允许负值。</td>
</tr>
<tr>
<td>blur</td>
<td>可选。模糊距离。</td>
</tr>
<tr>
<td>color</td>
<td>可选。阴影的颜色。</td>
</tr>
</tbody></table>
<blockquote>
<p>本文参考了黑马程序员pink老师的视频教程<br>        <strong>黑马程序员pink老师前端入门视频教程：</strong> <a href="https://www.bilibili.com/video/BV14J4114768">https://www.bilibili.com/video/BV14J4114768</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode中HTML与CSS代码的快速写法</title>
    <url>/2021/03/17/084-Vscode%E4%B8%ADHTML%E4%B8%8ECSS%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BF%AB%E9%80%9F%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<p>Emmet语法的前身是Zen coding，它使用缩写来提高html/css的编写速度，vscode内部已经集成该语法</p>
<h3 id="1-快速生成Html结构"><a href="#1-快速生成Html结构" class="headerlink" title="1. 快速生成Html结构"></a>1. 快速生成Html结构</h3><ul>
<li><p>生成标签，直接输入标签名，按<code>tab</code>键即可，比如div然后按tab键，就可以生成<code>&lt;div&gt;&lt;/div&gt;</code></p>
</li>
<li><p>如果想要生成多个相同标签，加上<code>*</code>就可以了，比如<code>div*3</code>可以快速生成三个div</p>
</li>
<li><p>如果有父子级关系的标签，可以用<code>&gt;</code>，比如ul &gt; li</p>
</li>
<li><p>如果有兄弟关系的标签，用<code>+</code>，比如div+p</p>
</li>
<li><p>如果生成带有类名或者id名的，直接写<code>.demo</code>或者<code>#two</code>，再按tab键即可，例如<code>div.banner</code></p>
</li>
<li><p>如果生成的div类名是有顺序的，可以使用自增符号<code>$</code>，例如<code>div.demo$*5</code></p>
</li>
<li><p>如果想要在生成的标签内部写内容可以用{}biaoshi</p>
</li>
</ul>
<h3 id="2-快速生成CSS样式"><a href="#2-快速生成CSS样式" class="headerlink" title="2. 快速生成CSS样式"></a>2. 快速生成CSS样式</h3><p>CSS取每个单词得首字母简写即可：</p>
<p>比如，ti2em，按tab，可以生成text-indent: 2em;</p>
<p>比如，w200，按tab，可以生成width: 200px;</p>
<h3 id="3-格式化代码"><a href="#3-格式化代码" class="headerlink" title="3. 格式化代码"></a>3. 格式化代码</h3><p>在VSCode中，保存时默认格式化代码，如果没有自动格式化可以按照如下步骤设置：</p>
<blockquote>
<p>【新版本】：</p>
<p>打开文件-首选项-设置，搜索format，勾选保存自动格式化。</p>
<p>【旧版本】：</p>
<p>打开：文件-&gt;首选项-&gt;设置</p>
<p>搜索：emmet.include</p>
<p>在setting.json下的【用户】中添加以下语句</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;editor.formatOnType&quot;</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;editor.formatOnSave&quot;</span>:<span class="literal">true</span>,</span><br></pre></td></tr></table></figure>

<p>设置好以后，保存时都会格式化文档</p>
</blockquote>
<p>也可以手动格式化文档：右键-格式化文档，或者<code>Shift+Alt+F</code></p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>前端笔记 | CSS浮动</title>
    <url>/2021/03/16/083-%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%20%20CSS%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="一、浮动"><a href="#一、浮动" class="headerlink" title="一、浮动"></a>一、浮动</h2><h4 id="1-1-传统网页布局的三种方式"><a href="#1-1-传统网页布局的三种方式" class="headerlink" title="1.1 传统网页布局的三种方式"></a>1.1 传统网页布局的三种方式</h4><p>CSS提供了三种传统布局方式：</p>
<ol>
<li>普通流（标准流）</li>
<li>浮动</li>
<li>定位</li>
</ol>
<p>三种布局方式都是用来摆放盒子的，盒子摆放到合适的位置，布局自然就完成了。</p>
<p>实际开发中，一个页面基本都包含了这三种布局方式（移动端有新的布局方式）</p>
<h4 id="1-2-标准流"><a href="#1-2-标准流" class="headerlink" title="1.2 标准流"></a>1.2 标准流</h4><p>所谓标准流：就是标签按照规定好的默认方式排列</p>
<ol>
<li>块级元素独占一行，从上向下顺序排序<ul>
<li>div、hr、p、h1~h6、ul、ol、dl、form、table</li>
</ul>
</li>
<li>行内元素会按照顺序，从左到右顺序排序，碰到父元素边缘则会自动换行<ul>
<li>span、a、i、em</li>
</ul>
</li>
</ol>
<p>标准流是最基本的布局方式</p>
<h4 id="1-3-为什么需要浮动"><a href="#1-3-为什么需要浮动" class="headerlink" title="1.3 为什么需要浮动"></a>1.3 为什么需要浮动</h4><p>有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。因为浮动可以改变元素标签默认的排序方式。</p>
<p><strong>浮动的典型应用：块级元素横向排列</strong></p>
<p>多个块级元素纵向排列用标准流，多个块级元素横向排列找浮动。</p>
<h4 id="1-4-什么是浮动"><a href="#1-4-什么是浮动" class="headerlink" title="1.4 什么是浮动"></a>1.4 什么是浮动</h4><p><strong>float</strong>属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘及包含块或另一个浮动框的边缘。</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">float</span>: 属性值; &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>元素不浮动（默认值）</td>
</tr>
<tr>
<td>left</td>
<td>元素向左浮动</td>
</tr>
<tr>
<td>right</td>
<td>元素向右浮动</td>
</tr>
</tbody></table>
<h4 id="1-5-浮动的特性"><a href="#1-5-浮动的特性" class="headerlink" title="1.5 浮动的特性"></a>1.5 浮动的特性</h4><p><strong>（1）浮动元素会脱离标准流</strong></p>
<ul>
<li><p>多利标准流的控制，移动到指定位置（浮动）</p>
</li>
<li><p>浮动的盒子不再保留原先的位置</p>
<blockquote>
<p>如果有两个盒子一个设置浮动，一个没有</p>
<p><img src="https://img-blog.csdnimg.cn/20210315165336189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
</li>
</ul>
<p><strong>（2）浮动的元素会在一行内显示并且元素顶部对齐</strong></p>
<ul>
<li>要在一行内显示，各个元素都要设置浮动特性</li>
<li>浮动的元素是互相贴靠在一起的，如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐</li>
</ul>
<p><strong>（3）浮动的元素会具有行内块元素的特性</strong></p>
<ul>
<li>任何元素都可以浮动，不管原先是什么元素，添加浮动之后都具有行内块元素相似的特性</li>
</ul>
<h4 id="1-6-浮动元素经常和标准流父级搭配使用"><a href="#1-6-浮动元素经常和标准流父级搭配使用" class="headerlink" title="1.6 浮动元素经常和标准流父级搭配使用"></a>1.6 浮动元素经常和标准流父级搭配使用</h4><p>为了约束浮动元素位置，网页布局一般采取的策略是：</p>
<p>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。<br><img src="https://img-blog.csdnimg.cn/2021031516535332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="二、常见网页布局"><a href="#二、常见网页布局" class="headerlink" title="二、常见网页布局"></a>二、常见网页布局</h2><h4 id="2-1-常见网页布局"><a href="#2-1-常见网页布局" class="headerlink" title="2.1 常见网页布局"></a>2.1 常见网页布局</h4><p><img src="https://img-blog.csdnimg.cn/20210315165419336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210315165438761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210315165453473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-2-浮动布局注意点"><a href="#2-2-浮动布局注意点" class="headerlink" title="2.2 浮动布局注意点"></a>2.2 浮动布局注意点</h4><p><strong>（1）浮动和标准流父盒子配合使用</strong></p>
<p>先用标准流的父元素排列上下位置，之后内部子元素用浮动排列左右位置</p>
<p><strong>（2）一个元素浮动了，理论上其余的兄弟元素也要浮动</strong></p>
<p>一个盒子里面有多个滋贺子，如果其中一个盒子浮动了，那么其他兄弟元素也应该浮动，以防止引起问题。</p>
<p>浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流。</p>
<h2 id="三、清除浮动"><a href="#三、清除浮动" class="headerlink" title="三、清除浮动"></a>三、清除浮动</h2><h4 id="3-1-为什么需要清除浮动"><a href="#3-1-为什么需要清除浮动" class="headerlink" title="3.1 为什么需要清除浮动"></a>3.1 为什么需要清除浮动</h4><p>由于父盒子在很多情况下，不方便给高度，但是子盒子浮动又不占有位置，导致父盒子高度为0，进而影响下面的标准流盒子。<br><img src="https://img-blog.csdnimg.cn/20210315165527115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>浮动元素不在占用原标准流位置，所以会对后面元素的排版产生影响</li>
</ul>
<h4 id="3-2-清除浮动本质"><a href="#3-2-清除浮动本质" class="headerlink" title="3.2 清除浮动本质"></a>3.2 清除浮动本质</h4><ul>
<li><p>清除浮动的本质就是清除浮动元素造成的影响</p>
</li>
<li><p>如果父盒子本身有高度，则不需要清除浮动</p>
</li>
<li><p>清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了</p>
</li>
</ul>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">clear</span>: 属性值; &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>不允许左侧有浮动元素（清除左侧浮动的影响）</td>
</tr>
<tr>
<td>right</td>
<td>不允许右侧有浮动元素（清除右侧浮动的影响）</td>
</tr>
<tr>
<td>both</td>
<td>同时清除左右两侧浮动的影响</td>
</tr>
</tbody></table>
<p>实际工作中，几乎只用<code>clear:both</code></p>
<p>清除浮动的策略是：闭合浮动</p>
<h4 id="3-3-清除浮动的方法"><a href="#3-3-清除浮动的方法" class="headerlink" title="3.3 清除浮动的方法"></a>3.3 清除浮动的方法</h4><p><strong>（1）额外标签法，也称为隔墙法</strong></p>
<p>额外标签法会在浮动元素末尾添加一个空标签。如<code>&lt;div style=&quot;&quot;clear:both&gt;&lt;/div&gt;</code>或其它标签<code>&lt;br/&gt;</code>等。</p>
<ul>
<li>优点：通俗易懂，书写方便</li>
<li>缺点：添加许多无意义的钱钱，结构化较差</li>
<li>注意：新增的空标签必须是一个块级元素。</li>
</ul>
<p><strong>（2）父级添加 overflow 属性</strong></p>
<p>可以给父级添加overflow属性，将其属性设置为hidden、auto或scroll。<code>overflow: hidden;</code></p>
<p>注意：给父元素添加代码</p>
<ul>
<li>优点：代码简洁</li>
<li>缺点：无法显示溢出的部分</li>
</ul>
<p><strong>（3）父级添加 after 伪元素</strong></p>
<p>:after 方式是额外标签发的升级版。也是给父元素添加。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 添加如下样式 */</span></span><br><span class="line"><span class="selector-class">.clearfix</span>:after&#123;</span><br><span class="line">    content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123; <span class="comment">/* IE6、7专有 */</span></span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 为父元素添加clearfix类 */</span></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;clearfix&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：没有增加标签，结构更简单</li>
<li>缺点：照顾低版本浏览器</li>
</ul>
<p>（4）父级添加双伪元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 添加如下样式 */</span></span><br><span class="line"><span class="selector-class">.clearfix</span>:before,</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 为父元素添加clearfix类 */</span></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;clearfix&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：代码更简洁</li>
<li>缺点：照顾低版本浏览器</li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>前端笔记 | CSS定位</title>
    <url>/2021/03/18/085-%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%20%20CSS%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h4 id="一、为什么需要定位"><a href="#一、为什么需要定位" class="headerlink" title="一、为什么需要定位"></a>一、为什么需要定位</h4><p>某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子。</p>
<p>当滚动窗口时，某些模块是固定在屏幕中的某个位置。</p>
<p>以上两个效果通过标准流和浮动都无法快速实现，此时需要定位来实现。</p>
<h4 id="二、定位组成"><a href="#二、定位组成" class="headerlink" title="二、定位组成"></a>二、定位组成</h4><p>定位：将盒子定在某一位置</p>
<p>定位 = 定位模式 + 边偏移</p>
<p>（定位模式用于指定元素在文档中的定位方式，边偏移则决定了该元素的最终位置）</p>
<p><strong>2.1 定位模式</strong></p>
<p>定位模式决定元素的定位方式，通过CSS的position属性设置</p>
<table>
<thead>
<tr>
<th>值</th>
<th>语义</th>
</tr>
</thead>
<tbody><tr>
<td>static</td>
<td>静态定位</td>
</tr>
<tr>
<td>relative</td>
<td>相对定位</td>
</tr>
<tr>
<td>absolute</td>
<td>绝对定位</td>
</tr>
<tr>
<td>fixed</td>
<td>固定定位</td>
</tr>
</tbody></table>
<p><strong>2.2 边偏移</strong></p>
<p>边偏移就是定位盒子移动到最终位置，有top、bottom、left、right四个属性</p>
<table>
<thead>
<tr>
<th>边偏移属性</th>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>top</td>
<td>top: 80px</td>
<td><strong>顶端</strong>偏移量，定义元素相对于其父元素上边线的距离</td>
</tr>
<tr>
<td>bottom</td>
<td>bottom: 80x</td>
<td><strong>底部</strong>偏移量，定义元素相对于其父元素下边线的距离</td>
</tr>
<tr>
<td>left</td>
<td>left: 80px</td>
<td><strong>左侧</strong>偏移量，定义元素相对于其父元素左边线的距离</td>
</tr>
<tr>
<td>right</td>
<td>right: 80px</td>
<td>右侧偏移量，定义元素相对于其父元素右边线的距离</td>
</tr>
</tbody></table>
<h4 id="三、静态定位-static"><a href="#三、静态定位-static" class="headerlink" title="三、静态定位 static"></a>三、静态定位 static</h4><p>静态定位是元素的默认定位方式，无定位的意思。</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: static; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态定位按照标准流摆放位置，没有边偏移</li>
</ul>
<h4 id="四、相对定位-relative"><a href="#四、相对定位-relative" class="headerlink" title="四、相对定位 relative"></a>四、相对定位 relative</h4><p>相对定位是元素在移动位置的时候，是相对于它原来的位置来说的。</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; positon: relative; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>相对定位是相对自己原来的位置进行移动</li>
<li>原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它。即<strong>相对定位并没有脱标</strong>。</li>
</ul>
<h4 id="五、绝对定位-absolute"><a href="#五、绝对定位-absolute" class="headerlink" title="五、绝对定位 absolute"></a>五、绝对定位 absolute</h4><p>绝对定位是元素在移动位置的时候，相对于它祖先元素来说的。</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: absolute; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位</p>
</li>
<li><p>父级有定位时（相对、绝对、固定定位），就会以最近一级带有定位的元素为参考点移动位置</p>
</li>
<li><p><strong>绝对定位不在占有原先位置</strong>。</p>
</li>
</ul>
<h4 id="六、子绝父相"><a href="#六、子绝父相" class="headerlink" title="六、子绝父相"></a>六、子绝父相</h4><p>子级用绝对定位，父级用相对定位。</p>
<ol>
<li>子级绝对位置，不占有位置，可以放到父盒子里面的每一个地方，不会影响到其它的兄弟盒子</li>
<li>父盒子需要加定位限制子盒子在父盒子内显示</li>
<li>父盒子布局时，需要占有位置，因此父亲只能是相对定位</li>
</ol>
<h4 id="七、固定定位"><a href="#七、固定定位" class="headerlink" title="七、固定定位"></a>七、固定定位</h4><p>固定定位是元素固定于浏览器可视区的位置。主要使用场景：可以在浏览器页面滚动时元素的位置不会改变。</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: fixed; &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>以浏览器的可视窗口为参照点移动元素</li>
</ol>
<ul>
<li>跟父元素没有关系</li>
<li>不随着滚动条的滚动而滚动</li>
</ul>
<ol start="2">
<li>固定定位不再占有原先的位置，也是脱标的</li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>【SLAM笔记】SLAM概述</title>
    <url>/2021/03/28/086-%E3%80%90SLAM%E7%AC%94%E8%AE%B0%E3%80%91SLAM%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p><strong>SLAM笔记专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10925276.html">https://blog.csdn.net/weixin_44543463/category_10925276.html</a></p>
<hr>
<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>对于一个移动机器人来说，我们往往需要它知道两件事：</p>
<ul>
<li>我在什么地方——定位</li>
<li>周围环境是什么样——建图<h4 id="1-1-定位方法"><a href="#1-1-定位方法" class="headerlink" title="1.1 定位方法"></a>1.1 定位方法</h4>对于定位来说，有许多方法可以使机器人确定自己的位置。主要分为两类：</li>
</ul>
<ol>
<li>携带与机器人本体上的：轮式编码器、相机、激光等</li>
<li>安装于环境中的：导引线、二维码等</li>
</ol>
<p>其中安装于环境中的设备约束了外部环境，对环境要求较高，无法提供通用普遍的解决方案。而携带于机器人本体的传感器则可适用于未知环境。</p>
<p>在视觉SLAM中，我们更加注重考虑如何用相机解决定位和建图的问题。</p>
<h4 id="1-2-相机"><a href="#1-2-相机" class="headerlink" title="1.2 相机"></a>1.2 相机</h4><p>相机按照工作方式可以分为三类。</p>
<p>单目相机：只使用一个摄像头进行SLAM。它获取的数据是一张张照片，照片以二维的形式反映了三维的世界，因此在单张图像里，无法确定一个物体的真实大小和物体的距离。如果我们想恢复三维结构，就必须转动相机的视角。</p>
<p>双目相机：使用两个摄像头测量。这样就消除了单目相机的尺度不确定性，可以测量物体的大小。并且两个摄像头间距（基线）越大，测量范围就越远。其缺点是配置和标定十分复杂，非常消耗计算资源。</p>
<p>深度相机：通过红外结构光或ToF原理，主动向物体发射并接受返回的光，测出物体离相机的距离。其通过物理手段测量，节省了大量的计算量，但缺点是测量范围窄、噪声大、事业小、易受日光干扰、无法测量投射材料等。</p>
<h2 id="二、经典SLAM框架"><a href="#二、经典SLAM框架" class="headerlink" title="二、经典SLAM框架"></a>二、经典SLAM框架</h2><p><img src="https://img-blog.csdnimg.cn/20210320120140388.png" alt="在这里插入图片描述"></p>
<h4 id="2-1-传感数据读取"><a href="#2-1-传感数据读取" class="headerlink" title="2.1 传感数据读取"></a>2.1 传感数据读取</h4><p>传感数据信息读取主要为图像信息的读取和预处理，还可能有马盘、惯性传感器等信息的读取和同步。</p>
<h4 id="2-2-前端视觉里程计"><a href="#2-2-前端视觉里程计" class="headerlink" title="2.2 前端视觉里程计"></a>2.2 前端视觉里程计</h4><p>视觉里程计的任务是估算相邻图像间相机的运动。由于是估计两张图间相机的运动，然后串联起来得到的机器人轨迹，所以仅通过视觉里程计来估算轨迹，不可避免会出现累计误差。为了解决这个问题所以有了后端优化和回环检测。</p>
<h4 id="2-3-后端优化"><a href="#2-3-后端优化" class="headerlink" title="2.3 后端优化"></a>2.3 后端优化</h4><p>后端优化的任务是接受视觉里程计测得的相机位姿，接合回环检测的新息，得到全局一致的轨迹和地图。<br>后端优化主要是指处理SLAM过程中噪声的问题，主要是滤波和非线性优化算法等。</p>
<h4 id="2-4-回环检测"><a href="#2-4-回环检测" class="headerlink" title="2.4 回环检测"></a>2.4 回环检测</h4><p>目的是判断机器人是否曾到达过先前的位置。主要解决位置随时间漂移的问题。</p>
<h4 id="2-5-建图"><a href="#2-5-建图" class="headerlink" title="2.5 建图"></a>2.5 建图</h4><p>根据估计的轨迹，建立于任务要求对应的地图。地图的形式主要有两种：</p>
<ul>
<li>度量地图：用稀疏和稠密对他们分类。稀疏地图进行了一定程度的抽象，可以满足定位的需求。而导航时，我们需要稠密的地图，稠密地图由小方块或小格子表示，每个小块有占据、空闲、未知三种状态，这种地图可以用于各种导航算法。</li>
<li>拓扑地图：只由节点和边组成，只考虑节点之间的连通性。去掉了细节问题，是一种更紧凑的表达方式，但无法表达具有复杂结构的地图。</li>
</ul>
<h2 id="三、SLAM问题的数学表述"><a href="#三、SLAM问题的数学表述" class="headerlink" title="三、SLAM问题的数学表述"></a>三、SLAM问题的数学表述</h2><p>机器人携带传感器在未知环境内运动时，相机会在离散的时刻采集一系列数据。</p>
<h4 id="3-1-运动方程——定位问题"><a href="#3-1-运动方程——定位问题" class="headerlink" title="3.1 运动方程——定位问题"></a>3.1 运动方程——定位问题</h4><p>在这些离散时刻机器人的位置，用$x$表示机器人的位置。<br>由于传感器的不同，某时刻机器人的位置没有确定的计算方程，但可以知道<strong>每一时刻的位置都取决于上一时刻的位置以及传感器采集的数据</strong>。<br><img src="https://img-blog.csdnimg.cn/20210321112215432.png#pic_center" alt="在这里插入图片描述"><br>其中，$u_k$为传感器读数，$w_k$为噪声。</p>
<h4 id="3-2-观测方程——建图问题"><a href="#3-2-观测方程——建图问题" class="headerlink" title="3.2 观测方程——建图问题"></a>3.2 观测方程——建图问题</h4><p>设地图由多个路标组成，每个时刻传感器会测量到一部分路标点，得到这些点的观测数据。即机器人在$x_k$位置上测量到路标点$y_j$，产生了观测数据$z_{k,j}$。<br><img src="https://img-blog.csdnimg.cn/2021032111260239.png#pic_center" alt="在这里插入图片描述"><br>其中$v_{k,j}$为观测时的噪声。</p>
<h4 id="3-3-方程求解方法"><a href="#3-3-方程求解方法" class="headerlink" title="3.3 方程求解方法"></a>3.3 方程求解方法</h4><p>按照运动和观测方程是否为线性，分为<strong>线性/非线性系统</strong>。<br>按照噪声是否服从高斯分布分类，分为<strong>高斯/非高斯系统</strong>。</p>
<ol>
<li>对于线性高斯系统，无偏最优估计可由卡尔曼滤波器给出。</li>
<li>对于复杂的非线性非高斯系统，使用扩展卡尔曼滤波和非线性优化两类方法解决。</li>
</ol>
<h2 id="四、Linux基础"><a href="#四、Linux基础" class="headerlink" title="四、Linux基础"></a>四、Linux基础</h2><h4 id="4-1-编写程序Hello-SLAM"><a href="#4-1-编写程序Hello-SLAM" class="headerlink" title="4.1 编写程序Hello SLAM"></a>4.1 编写程序Hello SLAM</h4><p>在根目录下创建文件夹<code>/slam/ch01</code><br>使用vim或gedit或nano等编辑器，输入以下代码，保存为<code>helloSLAM.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello SLAM!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-使用cmake"><a href="#4-2-使用cmake" class="headerlink" title="4.2 使用cmake"></a>4.2 使用cmake</h4><p>仍然在此目录下创建一个文件<code>CMakeLists.txt</code>，输入以下内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#声明要求的cmake最低版本</span><br><span class="line">cmake_minimum_required( VERSION <span class="number">2.8</span> )</span><br><span class="line"></span><br><span class="line">#声明一个cmake工程</span><br><span class="line">project( HelloSLAM )</span><br><span class="line"></span><br><span class="line">#添加一个可执行程序	语法：add_executable( 可执行程序名 源代码文件名 )</span><br><span class="line">add_executable( helloSLAM helloSLAM.cpp )</span><br></pre></td></tr></table></figure>
<p>创建一个文件夹<code>mkdir build</code>用于保存变异生成的中间文件<br>进入<code>build</code>文件夹，使用以下代码进行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>此时产生了一个名为<code>helloSLAM</code>的可执行文件，使用<code>./helloSLAM</code>即可执行此程序看到正确的输出。</p>
<h4 id="4-3-使用库"><a href="#4-3-使用库" class="headerlink" title="4.3 使用库"></a>4.3 使用库</h4><p>C++中只有带有main函数的文件才会生成可执行程序，而其他代码，我们只需把它打包成库，供程序调用即可。<br><strong>（1）创建库</strong><br>在刚才的ch01文件夹下，创建一个名为<code>libHelloSLAM.cpp</code>的文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello SLAM!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个库文件提供了一个printHello函数，但它没有main函数，因此不会生成可执行文件，我们需要告诉cmake，我想把这个文件编译成叫“hello”的库。在CmakeLists.txt内添加：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add_library(hello_shared SHARED libHelloSLAM.cpp)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里创建的是共享库。<br>在Linux中，库文件分成<strong>静态库</strong>和<strong>动态库</strong>两种。<br>静态库以.a后缀，每次被调用都会生成一个副本。<br>共享库以.so后缀，只有一个副本，更省空间。</p>
</blockquote>
<p>此时编译的话，可以得到一个libhello_shared.so的库文件</p>
<p><strong>（2）创建头文件</strong><br>创建一个名为<code>libHelloSLAM.cpp</code>的文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIBHELLOSLAM_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBHELLOSLAM_H_</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>（3）创建主程序</strong><br>创建一个名为<code>useHello.cpp</code>的文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libHelloSLAM.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printHello</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在CMakeLists.txt中添加生成可执行程序的生成命令，链接到刚才我们使用的库上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add_executable( useHello useHello.cpp )</span><br><span class="line">target_link_libraries( useHello hello_shared )</span><br></pre></td></tr></table></figure>
<p>进行编译，得到<code>useHello</code>这个可执行文件。</p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>【Proteus仿真】220V转5V向单片机供电</title>
    <url>/2021/04/06/087-%E3%80%90Proteus%E4%BB%BF%E7%9C%9F%E3%80%91220V%E8%BD%AC5V%E5%90%91%E5%8D%95%E7%89%87%E6%9C%BA%E4%BE%9B%E7%94%B5/</url>
    <content><![CDATA[<h3 id="一、所用元器件介绍"><a href="#一、所用元器件介绍" class="headerlink" title="一、所用元器件介绍"></a>一、所用元器件介绍</h3><p>1.1 仿真电源Alternator：用于仿真220v交流电源<br><img src="https://img-blog.csdnimg.cn/20210406175114833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="25%"><br>1.2 变压器Tran-2p2s：对220v交流电源进行降压<br><img src="https://img-blog.csdnimg.cn/2021040617525613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="25%"><br>1.3 桥式整流器2W005G：用于将交流电整流为直流电<br><img src="https://img-blog.csdnimg.cn/20210406175422626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="25%"><br>1.4 无极性电容CAP<br><img src="https://img-blog.csdnimg.cn/20210406175820802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="25%"><br>1.5 电解电容CAP-ELEC<br><img src="https://img-blog.csdnimg.cn/20210406175846429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="25%"><br>1.6 三端稳压芯片7805<br><img src="https://img-blog.csdnimg.cn/20210406175934412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="25%"></p>
<h3 id="二、接线方法"><a href="#二、接线方法" class="headerlink" title="二、接线方法"></a>二、接线方法</h3><img src="https://img-blog.csdnimg.cn/20210406180237156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="80%">

<h3 id="三、仿真结果"><a href="#三、仿真结果" class="headerlink" title="三、仿真结果"></a>三、仿真结果</h3><img src="https://img-blog.csdnimg.cn/20210406180416833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="100%">]]></content>
      <categories>
        <category>嵌入式</category>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>proteus</tag>
      </tags>
  </entry>
  <entry>
    <title>Labview绘制圆/椭圆</title>
    <url>/2021/04/06/088-Labview%E7%BB%98%E5%88%B6%E5%9C%86%E6%A4%AD%E5%9C%86/</url>
    <content><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p>
<hr>
<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>1.1 for循环<br>for循环是固定次数的循环，其也有条件接线端，可以提前结束while循环，相当于C语言的break语句。for循环与数组操作是密不可分的，for循环最重要的功能就是处理数组数据。<br><img src="https://img-blog.csdnimg.cn/20210406210855773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1.2 XY图<br>将x数组和y数组进行捆绑，形成一系列x和y组合的数据，将捆绑后的结果传递给xy图，即可生成一条曲线。<br><img src="https://img-blog.csdnimg.cn/20210406211312382.png" alt="在这里插入图片描述"><br>1.3 创建数组<br>创建数组这个控件的作用是将元素添加入数组，或连接多个数组。向下拖动此控件，会自动增加新的输入端和输出端。<br><img src="https://img-blog.csdnimg.cn/20210406211657298.png" alt="在这里插入图片描述"><br>1.4 移位寄存器<br>添加移位寄存器后，循环结构的左右两侧的平行位置将各增加一个包含三角形的方框。左侧的方框代表上一次循环的运行结果，右侧的代表本次循环要输入的结果。<br><img src="https://img-blog.csdnimg.cn/20210406221034655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="二、实验目标"><a href="#二、实验目标" class="headerlink" title="二、实验目标"></a>二、实验目标</h3><p>显示x坐标随角度的变化曲线，y坐标随角度的变化曲线。同时实时绘制一个椭圆，展示椭圆绘制的全过程。<br><img src="https://img-blog.csdnimg.cn/20210406212734602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="三、实验思路"><a href="#三、实验思路" class="headerlink" title="三、实验思路"></a>三、实验思路</h3><p>以循环次数i作为角度变化，每循环一次相当于角度+1，角度从0到360，因此循环总数设置为360。<br>考虑圆的参数方程，x=r·cos(φ)，y=r·sin(φ)，这里以r=1为例。<br>因为循环次数作为角度，故每个循环对应的x和y的值的计算方法为：$\frac{iπ}{180}$<br>将生成的数据添加到移位寄存器传过来的数组中，再将x数据数组和y数据数组捆绑送给xy图即可。<br><img src="https://img-blog.csdnimg.cn/2021040622160628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>Labview生成三维曲面 | 花瓶</title>
    <url>/2021/04/08/089-Labview%E7%94%9F%E6%88%90%E4%B8%89%E7%BB%B4%E6%9B%B2%E9%9D%A2%20%20%E8%8A%B1%E7%93%B6/</url>
    <content><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p>
<hr>
<h2 id="一、程序思路"><a href="#一、程序思路" class="headerlink" title="一、程序思路"></a>一、程序思路</h2><p>花瓶这种回转曲面生成的本质是<strong>轮廓沿引导线扫描</strong>。<br><img src="https://img-blog.csdnimg.cn/20210408112207884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="30%"><br>而对于花瓶来说，其生成方法就是一个圆沿一条曲线进行扫描</p>
<h4 id="1-1-底面圆轮廓的生成"><a href="#1-1-底面圆轮廓的生成" class="headerlink" title="1.1 底面圆轮廓的生成"></a>1.1 底面圆轮廓的生成</h4><p><strong>圆的生成方法如下：</strong><br>循环总数为360，对应360度，i则对应从0~360的每一角度。将i转换为弧度制，即可得到圆上各点的x坐标和y坐标，将两个坐标进行捆绑，得到的就是圆这个曲线。<br><img src="https://img-blog.csdnimg.cn/202104081113032.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="50%"><br><img src="https://img-blog.csdnimg.cn/20210408114027122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="30%"></p>
<h4 id="1-2-引导线的生成"><a href="#1-2-引导线的生成" class="headerlink" title="1.2 引导线的生成"></a>1.2 引导线的生成</h4><p>花瓶的生成，就是平面曲线圆的基础上，再加一个z轴曲线，作为圆的扫描引导线，这里以正弦曲线作为圆的扫描引导线。<br><img src="https://img-blog.csdnimg.cn/20210408112807110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="30%"></p>
<h4 id="1-3-圆沿引导线扫描"><a href="#1-3-圆沿引导线扫描" class="headerlink" title="1.3 圆沿引导线扫描"></a>1.3 圆沿引导线扫描</h4><p>基本思路为：<br>在刚才生成圆的循环外，再套一个循环。循环的输入是引导线输出的数组。<br>引导线上每一个点位数据进入大循环时，内循环就画一个以此数据为半径的圆。<br>当引导线上所有数据都进入循环，生成了一个一次为半径的圆时，花瓶的侧面就完成了。<br>在前面板插入三维图形中的曲面控件即可看到生成的侧面。<br><img src="https://img-blog.csdnimg.cn/20210408114655948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="40%"><br><img src="https://img-blog.csdnimg.cn/20210408114933130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="100%"><br><img src="https://img-blog.csdnimg.cn/20210408114956810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="50%"><br>生成哑铃状图像的原因是，刚才是以z轴正弦曲线的各个数据作为半径画圆，因此根据正弦图像，可以知道在<strong>起始、终止以及中间位置半径为零</strong>，画出来的图形也就是现在所看到的哑铃。<br><img src="https://img-blog.csdnimg.cn/20210408115436788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="50%"><br>要解决这个问题，只需要将正弦曲线整体向上平移即可。<br><img src="https://img-blog.csdnimg.cn/20210408115817581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="100%"><br><img src="https://img-blog.csdnimg.cn/20210408115845438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%"></p>
<h2 id="二、改进方法"><a href="#二、改进方法" class="headerlink" title="二、改进方法"></a>二、改进方法</h2><h4 id="2-1-修复裂缝"><a href="#2-1-修复裂缝" class="headerlink" title="2.1 修复裂缝"></a>2.1 修复裂缝</h4><p>可以看到生成的曲面上有一条裂缝，原因是起始点和终止点没有重合。<br><img src="https://img-blog.csdnimg.cn/20210408120215414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%"><br><strong>解决方法：</strong>将起始点添加到终止点，手动实现曲面封闭。索引数组中的第一个元素，将其添加到原数组的最后。<br><img src="https://img-blog.csdnimg.cn/20210408121047907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="100%"></p>
<h4 id="2-2-添加底面"><a href="#2-2-添加底面" class="headerlink" title="2.2 添加底面"></a>2.2 添加底面</h4><p>添加底面的方法十分简单，因为labview的三维曲面生成是连接相邻的点组成曲面，因此只需要在底面最中心添加一个点即可。<br><img src="https://img-blog.csdnimg.cn/20210408121426986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="100%"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>【SLAM笔记】三维刚体运动</title>
    <url>/2021/04/10/090-%E3%80%90SLAM%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%89%E7%BB%B4%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/</url>
    <content><![CDATA[<p><strong>SLAM笔记专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10925276.html">https://blog.csdn.net/weixin_44543463/category_10925276.html</a></p>
<hr>
<h2 id="一、旋转矩阵"><a href="#一、旋转矩阵" class="headerlink" title="一、旋转矩阵"></a>一、旋转矩阵</h2><h4 id="1-1-向量"><a href="#1-1-向量" class="headerlink" title="1.1 向量"></a>1.1 向量</h4><p>&emsp;&emsp;向量与坐标是两个不同的概念。向量只是有大小和方向的量。只有当指定了三维空间中某个坐标系的时候，才能谈论向量在此坐标系下的坐标。<strong>因此向量的坐标，既和向量本身有关，也和坐标系的选取有关。</strong><br>&emsp;&emsp;向量的内积描述了向量之间的投影关系。<br><img src="https://img-blog.csdnimg.cn/20210409150857262.png#pic_center"><br>&emsp;&emsp;向量的外积，方向垂直于这两个向量，大小为|a||b|sin&lt;a,b&gt;。<br><img src="https://img-blog.csdnimg.cn/20210410090428395.png#pic_center"></p>
<h4 id="1-2-欧氏变换"><a href="#1-2-欧氏变换" class="headerlink" title="1.2 欧氏变换"></a>1.2 欧氏变换</h4><p>&emsp;&emsp;两个坐标系之间的旋转、平移关系，统称为坐标系之间的变换关系。机器人运动过程中，往往会设定一个惯性坐标系（即世界坐标系），可以认为它是固定不动的。机器人则是一个移动坐标系。<br>&emsp;&emsp;如果需要知道某个向量在机器人坐标系中与世界坐标系中如何转换的，就需要先得到该向量对机器人坐标系的坐标值，再根据机器人位姿转换到世界坐标系中，这个转换关系用矩阵T来描述。<br>&emsp;&emsp;机器人移动是一个刚体运动，即同一个向量在各个坐标系下的长度和夹角都不会发生变化，这种变化就是<strong>欧式变换</strong>。<br><img src="https://img-blog.csdnimg.cn/20210410091352693.png#pic_center" width="40%"></p>
<p><strong>（1）旋转矩阵</strong><br>&emsp;&emsp;假设某个单位正交基($\boldsymbol{e_1}$,$\boldsymbol {e_2}$,$\boldsymbol{e_3}$)经过了一次旋转，变成了($\boldsymbol {e_1}’$,$\boldsymbol{e_2}’$,$\boldsymbol {e_3}’$)，则对于同一个向量$\boldsymbol{a}$（该向量没有随坐标系旋转而运动），则可知<br><img src="https://img-blog.csdnimg.cn/20210410115129293.png#pic_center"><br>用矩阵表示如下<br><img src="https://img-blog.csdnimg.cn/20210409162619682.png#pic_center"><br>&emsp;&emsp;为了表示两个坐标之间的变换关系，等式两边同乘[$\boldsymbol{e_1}^T$ $\boldsymbol{e_2}^T$ $\boldsymbol{e_3}^T$]T，则左侧矩阵变成了单位矩阵：<br><img src="https://img-blog.csdnimg.cn/20210409163540411.png#pic_center"><br>&emsp;&emsp;中间这个行列式为1的正交矩阵，就是所谓的旋转矩阵。<br>&emsp;&emsp;同时，此旋转矩阵的逆描述了一个相反的旋转。<br><img src="https://img-blog.csdnimg.cn/20210409164021886.png#pic_center"><br><strong>（2）平移矩阵</strong><br>&emsp;&emsp;平移矩阵十分简单，只需要将平移量加到旋转之后的坐标上就可以了。<br><img src="https://img-blog.csdnimg.cn/20210409165009954.png#pic_center"></p>
<h4 id="1-3-变换矩阵"><a href="#1-3-变换矩阵" class="headerlink" title="1.3 变换矩阵"></a>1.3 变换矩阵</h4><p>&emsp;&emsp;使用下面这种形式进行变换时，变化多次之后往往会变得过于复杂且不满足线性关系。<br><img src="https://img-blog.csdnimg.cn/2021040916543057.png#pic_center" alt="在这里插入图片描述">&emsp;&emsp;因此通常我们会使用如下的齐次坐标和变换矩阵进行变换。即把三维向量末尾加一，变成四维向量，称为齐次坐标$\tilde{a}$。将旋转矩阵和平移矩阵写在同一个矩阵里面，这个矩阵T称为变换矩阵。<br><img src="https://img-blog.csdnimg.cn/20210409165645446.png#pic_center" alt="在这里插入图片描述">&emsp;&emsp;引入齐次坐标就可以实现多个变换矩阵的连乘，得到一个总的变换矩阵，实现多次变换的累加。<br><img src="https://img-blog.csdnimg.cn/20210409170233936.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="二、角轴和欧拉角"><a href="#二、角轴和欧拉角" class="headerlink" title="二、角轴和欧拉角"></a>二、角轴和欧拉角</h2><h4 id="2-1-问题提出"><a href="#2-1-问题提出" class="headerlink" title="2.1 问题提出"></a>2.1 问题提出</h4><p>&emsp;&emsp;旋转矩阵有九个量，但一次旋转只有三个自由度，变换矩阵用十六个量表达六自由度变换，表达方式可能冗余。同时旋转矩阵本身要求必须是正交矩阵，变换矩阵一样都需要约束条件，有些情况下这些约束会使求解变得困难。</p>
<h4 id="2-2-角轴"><a href="#2-2-角轴" class="headerlink" title="2.2 角轴"></a>2.2 角轴</h4><p><strong>（1）定义</strong><br>&emsp;&emsp;<strong>任意旋转都可以用一个旋转轴和一个旋转角来刻画</strong>。我们可以使用一个向量，其方向与旋转轴一致，长度等于旋转角，这种向量就称为旋转向量或角轴。<br>&emsp;&emsp;使用角轴表示方法只需要一个三维向量即可描述旋转。同样对于变换矩阵，我们使用一个角轴和一个平移向量即可表达。<br><strong>（2）角轴与旋转矩阵的转换</strong><br>&emsp;&emsp;假设有一个旋转轴为$\boldsymbol {n}$，角度为θ的旋转，显然旋转向量为θ$\boldsymbol {n}$。由角轴转化为旋转矩阵，可以使用罗德里格斯公式：<br><img src="https://img-blog.csdnimg.cn/20210410094915120.png#pic_center" alt="在这里插入图片描述"><br>&emsp;&emsp;同样也可以计算从旋转矩阵到角轴的转换。（由于旋转轴上的向量旋转后不发生变化，因此旋转轴就是旋转矩阵$\boldsymbol {R}$的特征值1对应的特征向量）。<br><img src="https://img-blog.csdnimg.cn/20210410095123855.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-3-欧拉角"><a href="#2-3-欧拉角" class="headerlink" title="2.3 欧拉角"></a>2.3 欧拉角</h4><p>&emsp;&emsp;旋转矩阵和角轴都不太直观，而欧拉角的表达方式比较利于人的理解。（但是在程序中不常用）<br>&emsp;&emsp;欧拉将将旋转分解为三次不同轴上的转动，例如按Z-Y-X顺序转动，可以得到yaw-pitch-roll角。</p>
<blockquote>
<ol>
<li>绕物体的 Z 轴旋转，得到偏航角 yaw；</li>
<li>绕旋转之后的 Y 轴旋转，得到俯仰角 pitch；</li>
<li>绕旋转之后的 X 轴旋转，得到滚转角 roll。</li>
</ol>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210410104821111.png#pic_center" alt="在这里插入图片描述"><br>&emsp;&emsp;欧拉角存在万向锁的问题，例如在ZYX顺序中，第一次绕Z轴旋转，第二次绕Y轴旋转90°，这时候x轴和系统初始时的Z轴重合了，导致第三次旋转和第一次是绕同一个轴旋转，丢失了一个自由度。所以程序中很少用欧拉角表示机器人的位姿。<br><img src="https://img-blog.csdnimg.cn/20210410110140330.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="三、四元数"><a href="#三、四元数" class="headerlink" title="三、四元数"></a>三、四元数</h2><h4 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h4><p>&emsp;&emsp;四元数是一种扩展的复数。我们知道复数可以表示复平面内的旋转，乘i表示复平面内逆时针转90度，单位圆上的复数可以表达二维平面的旋转。<br>&emsp;&emsp;四元数有三个虚部，可以表达三维空间中的旋转。<br><img src="https://img-blog.csdnimg.cn/20210410110458117.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210410110521969.png#pic_center" alt="在这里插入图片描述"><br>&emsp;&emsp;四元数的虚部相乘，类似于虚数i的相乘，也有对应的关系，且其关系很想三维空间中的叉积。<br><img src="https://img-blog.csdnimg.cn/20210410110638239.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-2-四元数的运算"><a href="#3-2-四元数的运算" class="headerlink" title="3.2 四元数的运算"></a>3.2 四元数的运算</h4><table>
<thead>
<tr>
<th>运算</th>
<th>公式</th>
</tr>
</thead>
<tbody><tr>
<td>加减法</td>
<td><img src="https://img-blog.csdnimg.cn/20210410110821214.png" alt="在这里插入图片描述"></td>
</tr>
<tr>
<td>乘法</td>
<td><img src="https://img-blog.csdnimg.cn/20210410115827928.png" alt="在这里插入图片描述"></td>
</tr>
<tr>
<td>共轭</td>
<td><img src="https://img-blog.csdnimg.cn/20210410113042373.png" alt="在这里插入图片描述"></td>
</tr>
<tr>
<td>模长</td>
<td><img src="https://img-blog.csdnimg.cn/20210410113127734.png" alt="在这里插入图片描述"></td>
</tr>
<tr>
<td>逆</td>
<td><img src="https://img-blog.csdnimg.cn/20210410113321113.png" alt="在这里插入图片描述"></td>
</tr>
<tr>
<td>数乘</td>
<td><img src="https://img-blog.csdnimg.cn/20210410113341819.png" alt="在这里插入图片描述"></td>
</tr>
<tr>
<td>点乘</td>
<td><img src="https://img-blog.csdnimg.cn/20210410113412414.png" alt="在这里插入图片描述"></td>
</tr>
</tbody></table>
<h4 id="3-3-用四元数表示旋转"><a href="#3-3-用四元数表示旋转" class="headerlink" title="3.3 用四元数表示旋转"></a>3.3 用四元数表示旋转</h4><p><strong>（1）四元数与角轴、旋转矩阵的转换</strong><br>|转换|公式<br>|-|-<br>|角轴到四元数：|<img src="https://img-blog.csdnimg.cn/20210410113741618.png#pic_center" alt="在这里插入图片描述"><br>|四元数到角轴|<img src="https://img-blog.csdnimg.cn/20210410114027477.png" alt="在这里插入图片描述"><br>|四元数到旋转矩阵|<img src="https://img-blog.csdnimg.cn/20210410114303272.png" alt="在这里插入图片描述"><br><strong>（2）使用四元数表示旋转</strong><br>&emsp;&emsp;四元数有三个虚部i, j, k，将三个坐标值作为三个虚部的系数，另实部为零，这样就将一个三维空间坐标转换为纯虚四元数表示的坐标。<br><img src="https://img-blog.csdnimg.cn/20210410114512501.png#pic_center" alt="在这里插入图片描述"><br>&emsp;&emsp;用一个四元数$\boldsymbol{q}$表示旋转。<br><img src="https://img-blog.csdnimg.cn/20210410114650168.png#pic_center" alt="在这里插入图片描述"><br>&emsp;&emsp;空间点的旋转可以用四元数的乘法表示，旋转后的点$\boldsymbol{p’}$如下<br><img src="https://img-blog.csdnimg.cn/20210410114752936.png#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>参考：<strong>高翔-视觉SLAM十四讲</strong><br>相关Github：<a href="https://github.com/gaoxiang12/slambook">https://github.com/gaoxiang12/slambook</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器人</category>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>【SLAM笔记】如何使用Eigen进行矩阵运算</title>
    <url>/2021/04/12/091-%E3%80%90SLAM%E7%AC%94%E8%AE%B0%E3%80%91%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Eigen%E8%BF%9B%E8%A1%8C%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p><strong>SLAM笔记专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10925276.html">https://blog.csdn.net/weixin_44543463/category_10925276.html</a></p>
<hr>
<h2 id="一、Eigen库的介绍与安装"><a href="#一、Eigen库的介绍与安装" class="headerlink" title="一、Eigen库的介绍与安装"></a>一、Eigen库的介绍与安装</h2><h4 id="1-1-Eigen是什么"><a href="#1-1-Eigen是什么" class="headerlink" title="1.1 Eigen是什么"></a>1.1 Eigen是什么</h4><p>&emsp;&emsp;Eigen是一个C++开源的线性代数库，提供了快速的矩阵线性代数运算，解方程等功能。许多上层软件库也使用Eigen进行矩阵运算。<br>&emsp;&emsp;Eigen是一个纯用头文件搭建起来的库，因此使用的时候，只需要引用它的头文件即可，不需要链接库文件。</p>
<h4 id="1-2-Eigen的安装"><a href="#1-2-Eigen的安装" class="headerlink" title="1.2 Eigen的安装"></a>1.2 Eigen的安装</h4><p>&emsp;&emsp;如果你的电脑上没有安装Eigen，可以输入下面的命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libeigen3-dev</span><br></pre></td></tr></table></figure>
<h2 id="二、Eigen库的基本使用"><a href="#二、Eigen库的基本使用" class="headerlink" title="二、Eigen库的基本使用"></a>二、Eigen库的基本使用</h2><h4 id="2-1-Eigen库的引用"><a href="#2-1-Eigen库的引用" class="headerlink" title="2.1 Eigen库的引用"></a>2.1 Eigen库的引用</h4><p>在cpp文件的开头插入如下两个头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在CMakeLists.txt内指定Eigen的头文件目录（如果把Eigen安装在了不同位址，就必须修改这里的头文件目录）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include_directories(<span class="string">&quot;/usr/include/eigen3&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="2-2-Eigen的基本语法"><a href="#2-2-Eigen的基本语法" class="headerlink" title="2.2 Eigen的基本语法"></a>2.2 Eigen的基本语法</h4><table>
<thead>
<tr>
<th>功能</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>声明一个m行n列的 float 矩阵</td>
<td><code>eigen Eigen::Matrix&lt;float,m,n&gt; matrix_name;</code></td>
</tr>
<tr>
<td>声明一个三维列向量</td>
<td><code>Eigen::Vector3d vector_name;</code></td>
</tr>
<tr>
<td>声明一个三阶方阵</td>
<td><code>Eigen::Matrix3d matrix_name;</code></td>
</tr>
<tr>
<td>动态大小矩阵</td>
<td><code>Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic&gt; matrix_name;</code></td>
</tr>
<tr>
<td>初始化矩阵为零矩阵</td>
<td><code>Eigen::Matrix3d matrix_name = Eigen::Matrix3d::Zero();</code></td>
</tr>
<tr>
<td>输入数据</td>
<td><code>matrix_name &lt;&lt; 1,2,3,4,5,6;</code></td>
</tr>
<tr>
<td>输出数据</td>
<td><code>cout &lt;&lt; matrix_name &lt;&lt; endl;</code></td>
</tr>
<tr>
<td>数据类型转换</td>
<td><code>matrix_name.cast&lt;double&gt;()</code></td>
</tr>
<tr>
<td>矩阵乘法</td>
<td><code>matrix_name1 * matrix_name2</code></td>
</tr>
<tr>
<td>转置</td>
<td><code>matrix_name.transpose();</code></td>
</tr>
<tr>
<td>各元素和</td>
<td><code>matrix_name.sum()</code></td>
</tr>
<tr>
<td>迹</td>
<td><code>matrix_name.trace()</code></td>
</tr>
<tr>
<td>逆</td>
<td><code>matrix_name.inverse()</code></td>
</tr>
<tr>
<td>行列式</td>
<td><code>matrix_name.determinant()</code></td>
</tr>
<tr>
<td>共轭矩阵</td>
<td><code>matrix_name.conjugate()</code></td>
</tr>
<tr>
<td>伴随矩阵</td>
<td><code>matrix_adjoint()</code></td>
</tr>
<tr>
<td>求特征值</td>
<td><code>Eigen::SelfAdjointEigenSolver&lt;Eigen::Matrix3d&gt; eigenSolver(matrix3d);</code></td>
</tr>
<tr>
<td>特征值</td>
<td><code>eigenSolver.eigenvalues()</code></td>
</tr>
<tr>
<td>特征向量</td>
<td><code>eigenSolver.eigenvectors()</code></td>
</tr>
</tbody></table>
<h4 id="2-3-使用Eigen实现旋转变换"><a href="#2-3-使用Eigen实现旋转变换" class="headerlink" title="2.3 使用Eigen实现旋转变换"></a>2.3 使用Eigen实现旋转变换</h4><ol>
<li><strong>三维旋转矩阵</strong>：创建一个三维矩阵即可<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：创建一个三阶单位矩阵</span></span><br><span class="line">Eigen::Matrix3d rotation_matrix = Eigen::Matrix3d::<span class="built_in">Identity</span>();</span><br></pre></td></tr></table></figure></li>
<li><strong>旋转向量</strong>：使用AngleAxis，可以使用这个它乘向量实现旋转操作（因为定义了运算符重载），括号内是旋转向量的角度和旋转轴<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个绕z轴旋转45°的旋转向量</span></span><br><span class="line"><span class="function">Eigen::AngleAxisd <span class="title">rotation_vector</span><span class="params">(M_PI/<span class="number">4</span>,Eigen::Vector3d(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>旋转向量转换为三维旋转矩阵</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将rotation_vector这个旋转向量转换为旋转矩阵并打印出来</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;rotation matrix = \n&quot;</span>&lt;&lt;rotation_vector.<span class="built_in">matrix</span>()&lt;&lt;endl;</span><br><span class="line"><span class="comment">//或通过toRotationMatrix转换为旋转矩阵</span></span><br><span class="line">rotation_matrix = rotation_vector.<span class="built_in">toRotationMatrix</span>();</span><br></pre></td></tr></table></figure></li>
<li><strong>旋转矩阵转换为欧拉角</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将旋转矩阵转换为ZYX顺序的欧拉角，即yaw-pitch-roll</span></span><br><span class="line">Eigen::Vector3d euler_angles = rotation_matrix.<span class="built_in">eulerAngles</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;yaw pitch roll = &quot;</span>&lt;&lt;euler_angles.<span class="built_in">transpose</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li>
<li><strong>使用旋转向量进行坐标变换</strong>：因为对进行了运算符重载，旋转操作直接乘向量即可<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个x方向的向量，用前面定义的旋转向量进行旋转，然后输出旋转后的结果。</span></span><br><span class="line"><span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">Eigen::Vector3d v_rotated = rotation_vector * v;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;(1,0,0) after rotation = &quot;</span>&lt;&lt;v_rotated.<span class="built_in">transpose</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li>
<li><strong>用旋转矩阵进行坐标变换</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v_rotated = rotation_matrix * v;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;(1,0,0) after rotation = &quot;</span>&lt;&lt;v_rotated.<span class="built_in">transpose</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li>
<li><strong>使用变换矩阵进行坐标变换</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个名为T的变换矩阵,虽说是3d，但实际是4x4矩阵，Identity说明旋转是0，平移也是0</span></span><br><span class="line">Eigen::Isometry3d T=Eigen::Isometry3d::<span class="built_in">Identity</span>();</span><br><span class="line"><span class="comment">//将左上角的旋转矩阵设为按旋转向量rotation_vector旋转</span></span><br><span class="line">T.<span class="built_in">rotate</span>(rotation_vector);</span><br><span class="line"><span class="comment">//设置右上角的平移矩阵为[1,3,4]（旋转前平移）</span></span><br><span class="line">T.<span class="built_in">pretranslate</span>(Eigen::<span class="built_in">Vector3d</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">//因为运算符重载，变换矩阵可以直接乘三维向量</span></span><br><span class="line">Eigen::Vector3d v_transformed = T*v;</span><br></pre></td></tr></table></figure></li>
<li><strong>使用四元数</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个四元数</span></span><br><span class="line">Eigen::Quaterniond q;</span><br><span class="line"><span class="comment">//可以直接把旋转向量赋值给四元数</span></span><br><span class="line">q = Eigen::<span class="built_in">Quaterniond</span>(rotation_vector);</span><br><span class="line"><span class="comment">//也可以把旋转矩阵赋值给它</span></span><br><span class="line">q=Eigen::<span class="built_in">Quaterniond</span>(rotation_matrix);</span><br><span class="line"><span class="comment">//使用四元数旋转一个向量</span></span><br><span class="line">v_rotated = q*v;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>Labview多点正弦运动轨迹</title>
    <url>/2021/04/13/092-Labview%E5%A4%9A%E7%82%B9%E6%AD%A3%E5%BC%A6%E8%BF%90%E5%8A%A8%E8%BD%A8%E8%BF%B9/</url>
    <content><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p>
<hr>
<h2 id="〇、须知"><a href="#〇、须知" class="headerlink" title="〇、须知"></a>〇、须知</h2><h4 id="0-1-移位寄存器"><a href="#0-1-移位寄存器" class="headerlink" title="0.1 移位寄存器"></a>0.1 移位寄存器</h4><p>&emsp;&emsp;在循环结构的边框上右键，可以创建移位寄存器。</p>
<p>&emsp;&emsp;移位寄存器用于将上一次循环产生的值传递至下一次循环。移位寄存器以成对接线端的形式出现，分别位于循环两侧的边框上，位置相对。</p>
<p>&emsp;&emsp;右侧接线端含有一个向上的箭头，用于存储每次循环结束时的数据。LabVIEW会将连接到右侧寄存器的数据传递到下一次循环中。循环执行完毕后，右侧接线端将返回移位寄存器最后一次保存的值。</p>
<p>&emsp;&emsp;移位寄存器需要初始化，即需要设置移位寄存器传递给第一次循环的值。<br><img src="https://img-blog.csdnimg.cn/2021041317154237.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="0-2-NaN的使用"><a href="#0-2-NaN的使用" class="headerlink" title="0.2 NaN的使用"></a>0.2 NaN的使用</h4><p>&emsp;&emsp;NaN：Not a Number。使用时直接创建常量输入NaN即可。<br>&emsp;&emsp;在绘制曲线时，NaN不会被显示在波形图上。</p>
<h4 id="0-3-启用索引与禁用索引"><a href="#0-3-启用索引与禁用索引" class="headerlink" title="0.3 启用索引与禁用索引"></a>0.3 启用索引与禁用索引</h4><p>&emsp;&emsp;将数组元素传入循环结构时，再循环结构的边框上会出现一个连接端子。<br>&emsp;&emsp;启用索引：指每循环一次，数组的值依次传入一个，此时连接端子为空心。<br>&emsp;&emsp;禁用索引：指无论循环如何，每次循环都会将整个数组传入，此时连接端子为实心。<br><img src="https://img-blog.csdnimg.cn/20210413171325921.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="一、连续五个点正弦运动"><a href="#一、连续五个点正弦运动" class="headerlink" title="一、连续五个点正弦运动"></a>一、连续五个点正弦运动</h2><h4 id="1-1-目标"><a href="#1-1-目标" class="headerlink" title="1.1 目标"></a>1.1 目标</h4><p>&emsp;&emsp;在波形图中生成正弦曲线的基础上，实现连续5个点在正弦曲线上跑的效果，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20210413122553724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h4 id="1-2-实现思路"><a href="#1-2-实现思路" class="headerlink" title="1.2 实现思路"></a>1.2 实现思路</h4><p>（1）产生一个正弦信号数组，数组的索引代表时间，数组的内容代表正弦信号值。<br>（2）将正弦信号数组，和一个长度相等、元素为NaN的数组同时传入循环结构。<br>（3）依次索引正弦信号数组的当前传入值和前4个值（如果有的话），并将NaN数组的对应位置用这五个数替换。<br>（4）正弦信号数组每传入一个数字，NaN数组就替换一次，同时更新一次波形，这样就实现了连续5个点在正弦曲线上运动的效果。</p>
<h4 id="1-3-程序框图设计过程"><a href="#1-3-程序框图设计过程" class="headerlink" title="1.3 程序框图设计过程"></a>1.3 程序框图设计过程</h4><p><strong>（1）产生正弦信号数组</strong><br>&emsp;&emsp;正弦信号数组的长度为360，相当于每个i对应1°，用正弦角度转弧度的公式即可计算出正弦值，360次循环就输出了一个周期的正弦数组。<br><img src="https://img-blog.csdnimg.cn/20210413164210826.png#pic_center" alt="在这里插入图片描述"><br><strong>（2）创建一个长度相等、元素为NaN的数组</strong><br>&emsp;&emsp;用到了<strong>数组大小</strong>和<strong>初始化数组</strong>这两个控件。数组大小控件传入一个数组，输出数组中元素的个数。初始化数组传入初始化元素和数组长度，输出一个数组。<br>&emsp;&emsp;这里将正弦信号数组传入，然后初始化一个长度相同，元素全为NaN的数组。<br><img src="https://img-blog.csdnimg.cn/20210413164708184.png#pic_center" alt="在这里插入图片描述"><br><strong>（3）索引前4个数并于当前值打包成一个数组</strong>（用于接下来按这个数组进行元素替换）<br>&emsp;&emsp;先创建一个for循环，在循环结构的边框上右键-添加移位寄存器，然后拖拉左边的移位寄存器，使左边为4个端子，右边为一个端子，然后为移位寄存器添加初始值。<br>&emsp;&emsp;将正弦数组传入for循环，然后连接到右侧移位寄存器上。（默认是以索引的方式传入数组，即每一次循环传入一个数据）<br>&emsp;&emsp;使用创建数组控件，将当前值和前4个值打包成一个数组。<br><img src="https://img-blog.csdnimg.cn/20210413211244221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>&emsp;&emsp;这样实现的功能为：数组每传入一个值，会将传入的值和前4个值打包成一个数组，同时这个值会进入移位寄存器，更新移位寄存器中的四个值。<br><strong>（4）替换NaN数组的元素</strong><br>&emsp;&emsp;这一步的目的是将NaN数组中的对应位置，替换成前5个打包好的值。这样一来，随着每次循环更新，NaN只有的这5个数也随着更新，表现在图上就是5个点在正弦曲线上跑。<br>&emsp;&emsp;这一步的关键在于找到5个数的索引（即在数组中的位置）。由先前的逻辑可知，右侧for循环的 <strong>i</strong> 就是5个数中最后一个数的索引，前四个数是通过移位寄存器获得的，因此前4个数的索引是依次 -1。<br><img src="https://img-blog.csdnimg.cn/20210413211418635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>&emsp;&emsp;使用<strong>替换数组子集</strong>这个控件，其输入参数有三个：原数组，替换元素的索引，替换的元素。<br>&emsp;&emsp;其中，原数组就是前面的NaN数组，因为每次循环，都需要传入整个数组，因此要<strong>禁用索引</strong>。并且由于内层for循环单次循环只替换一个数，需要将替换后的数组通过<strong>移位寄存器</strong>传到下一次循环继续进行元素替换。<br>&emsp;&emsp;替换的元素，刚才打包的数组通过索引的方式，依次传入到内层for循环中，作为要替换的元素。同时for循环的次数也由这个数组长度确定了。<br>&emsp;&emsp;替换元素的索引使用外层循环的 i （最后一个数的索引），减内层循环的 i （从0~4五次循环对应五个数）。<br><strong>（5）将原先的正弦数组和替换后的NaN数组打包显示</strong><br>&emsp;&emsp;在前面板创建一个波形图控件。在程序框图使用创建数组控件连接两个数组和波形图控件即可。（注意：正弦数组也是每次循环传入全部数组，禁用索引）<br>&emsp;&emsp;然后为大循环添加一个等待延时，否则一旦运行就直接执行完毕，看不到点的运动过程。<br><img src="https://img-blog.csdnimg.cn/20210413211621655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>注：前面板的曲线1（5个点）最好修改成其它线型，否则看不出效果</strong><br><img src="https://img-blog.csdnimg.cn/20210413175710828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-3-运行结果"><a href="#1-3-运行结果" class="headerlink" title="1.3 运行结果"></a>1.3 运行结果</h4><p><img src="https://img-blog.csdnimg.cn/20210413122553724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="二、间隔五个点正弦运动"><a href="#二、间隔五个点正弦运动" class="headerlink" title="二、间隔五个点正弦运动"></a>二、间隔五个点正弦运动</h2><h4 id="2-1-目标"><a href="#2-1-目标" class="headerlink" title="2.1 目标"></a>2.1 目标</h4><p>&emsp;&emsp;仍然是五个点在正弦曲线上跑，但是这次五个点不是连续的，而是有间隔的。<br><img src="https://img-blog.csdnimg.cn/202104132141076.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-2-实现思路"><a href="#2-2-实现思路" class="headerlink" title="2.2 实现思路"></a>2.2 实现思路</h4><p>&emsp;&emsp;因为目标是将NaN数组中的不连续点替换成相应的正弦坐标值。因此只需要将内循环的替换数组的索引乘一个系数，就可以实现不连续点的索引替换。比如系数为5，则之前外i-内i的结果是0-1-2-3-4，现在外i-内i的结果是0-5-15-20-25。<br>&emsp;&emsp;虽然索引变了，但是替换的元素没有变，仍然是上一个元素，这样不是我们要的结果，我们需要将传入的数组也等间隔缩短同样的倍数，再配合移位寄存器找到前4个值，<strong>抽取数组</strong>这个控件可以实现我们的目的。</p>
<h4 id="2-3-程序框图"><a href="#2-3-程序框图" class="headerlink" title="2.3 程序框图"></a>2.3 程序框图</h4><p><img src="https://img-blog.csdnimg.cn/20210413215346309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="拓展——香农采样定律"><a href="#拓展——香农采样定律" class="headerlink" title="拓展——香农采样定律"></a>拓展——香农采样定律</h4><p>&emsp;&emsp;为了不失真地恢复模拟信号，采样频率应该不小于模拟信号频谱中最高频率的2倍。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>Labview实现画板</title>
    <url>/2021/04/15/093-Labview%E5%AE%9E%E7%8E%B0%E7%94%BB%E6%9D%BF/</url>
    <content><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p>
<hr>
<h2 id="一、所用控件介绍"><a href="#一、所用控件介绍" class="headerlink" title="一、所用控件介绍"></a>一、所用控件介绍</h2><h4 id="1-1-二维图片"><a href="#1-1-二维图片" class="headerlink" title="1.1 二维图片"></a>1.1 二维图片</h4><p>&emsp;&emsp;添加方法：前面板右键，图形-控件-二维图片。<br>&emsp;&emsp;二维图片控件可实现像素级控制，能用于创建几乎任何图形对象。如需在二维图片控件中显示图像，必须通过编程向该控件写入一个图像。可使用图片函数VI进行绘制。</p>
<h4 id="1-2-属性节点"><a href="#1-2-属性节点" class="headerlink" title="1.2 属性节点"></a>1.2 属性节点</h4><p>&emsp;&emsp;控件的属性节点和控件本身的属性是相同的，在控件上右键单击，选择  创建-属性节点-值，即可创建一个value属性节点</p>
<h2 id="二、使用二维图片空间画画"><a href="#二、使用二维图片空间画画" class="headerlink" title="二、使用二维图片空间画画"></a>二、使用二维图片空间画画</h2><h4 id="2-1-目的"><a href="#2-1-目的" class="headerlink" title="2.1 目的"></a>2.1 目的</h4><p><img src="https://img-blog.csdnimg.cn/20210415110549537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-2-程序设计思路"><a href="#2-2-程序设计思路" class="headerlink" title="2.2 程序设计思路"></a>2.2 程序设计思路</h4><p>（1）使用二维图片的鼠标位置属性节点，获取当前鼠标的位置。<br>（2）使用图片函数中的绘制点函数，对传入的鼠标位置画点。<br>（3）利用移位寄存器将画好点的图片传入下一次循环，作为下一次循环时画点的画布。<br>（4）使用二维图片的鼠标按下属性节点，通过条件结构判断鼠标是否按下，以此控制是否画点。<br>（5）清屏可以使用一个条件结构，清屏按钮按下时，将空白画布传给移位寄存器。</p>
<h4 id="2-3-程序实现过程"><a href="#2-3-程序实现过程" class="headerlink" title="2.3 程序实现过程"></a>2.3 程序实现过程</h4><p><strong>（1）获取鼠标位置</strong><br>&emsp;&emsp;首先，在前面板创建一个二维图片（右键-图形-控件-二维图片）。然后在<strong>程序框图中</strong>右键二维图片控件，<strong>右键-创建-属性节点-鼠标</strong>。<br><img src="https://img-blog.csdnimg.cn/20210415111946636.png#pic_center" alt="在这里插入图片描述"><br>&emsp;&emsp;将二维图片的属性节点按名称解绑，然后在Mouse Position的输出端点创建显示控件。这样就实现了获取鼠标位置。为整体添加一个while循环，运行看一下效果。<br><img src="https://img-blog.csdnimg.cn/20210415112324995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210415112438869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>（2）画出当前点</strong><br>&emsp;&emsp;在程序框图中，<strong>右键-图形与声音-图片函数-绘制点</strong>，将解绑出来的鼠标位置作为输入，二维图片空间作为输出。然后在颜色、画笔两个接线端上右键-创建输入控件。<br><img src="https://img-blog.csdnimg.cn/2021041511362575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210415113914747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>（3）画出连续的点，即保存之前鼠标经过的点</strong><br>&emsp;&emsp;将刚才画好点的二维图片，通过移位寄存器传入下一次循环，作为下一次循环要画点的初始图片。（注意：移位寄存器使用时一定要初始化）<br><img src="https://img-blog.csdnimg.cn/20210415114631829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021041511473756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>（4）实现鼠标按下时画点</strong><br>&emsp;&emsp;利用二维图片的鼠标属性节点的另一个属性，将鼠标按下这个属性节点拖出来，左键点击，选择<strong>Mouse Modifiers-Button Down</strong>。<br><img src="https://img-blog.csdnimg.cn/20210415115651372.png#pic_center" alt="在这里插入图片描述"><br>&emsp;&emsp;这个属性节点的输出值是一个布尔值，因此我们使用条件结构实现此功能。条件为真，即按键按下时，画当前点；条件为假，即按键未按下时，不做任何操作。<br><img src="https://img-blog.csdnimg.cn/20210415115705970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210415115715409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>（5）设置清屏按钮</strong><br>&emsp;&emsp;清屏操作十分简单，只需要在前面板添加一个布尔按钮，然后在后面板利用条件结构判断按钮状态，如果按下，就将一个空白图片传给二维图片控件，如果未按下，则不进行任何操作。<br><img src="https://img-blog.csdnimg.cn/20210415120235489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021041512025229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021041512091197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>（5）调整一下面板布局、颜色和风格</strong><br><img src="https://img-blog.csdnimg.cn/20210415121101174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>Labview子VI的创建与调用</title>
    <url>/2021/04/20/094-Labview%E5%AD%90VI%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p>
<hr>
<h2 id="一、什么是子VI"><a href="#一、什么是子VI" class="headerlink" title="一、什么是子VI"></a>一、什么是子VI</h2><p>&emsp;&emsp;程序设计中很重要的一个思想就是模块化思想，也就是将程序划分为若干个区块，这样对程序某个区块进行修改就不会影响到其它区块。在Labview中，我们通过子VI来实现模块化的编程。</p>
<p>&emsp;&emsp;任何一个VI本身就可以作为子VI被其他VI调用，子VI只是需要在普通VI的基础上定义连接端子和图标即可。当一个VI被其它VI调用，则该VI被称为子VI，子VI相当于程序语言中的子程序。</p>
<h2 id="二、子VI的创建与调用"><a href="#二、子VI的创建与调用" class="headerlink" title="二、子VI的创建与调用"></a>二、子VI的创建与调用</h2><p>&emsp;&emsp;这里以角度转弧度的函数为例，说明子VI的创建和调用方法。</p>
<h4 id="2-1-子VI的创建"><a href="#2-1-子VI的创建" class="headerlink" title="2.1 子VI的创建"></a>2.1 子VI的创建</h4><p>&emsp;&emsp;如下图是一个将角度转为弧度值的简单程序。<br><img src="https://img-blog.csdnimg.cn/20210420171030130.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420171113415.png#pic_center" alt="在这里插入图片描述"><br><strong>（1）定义接线端</strong><br>&emsp;&emsp;在前面板中右上角的小框框中，点击选择一个接线端的位置，然后再点击这个接线端要对应的输入输出控件，若方块变红，说明这个接线端设置完成了。<br><img src="https://img-blog.csdnimg.cn/20210420171749460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>&emsp;&emsp;例如，先点击小框框左上角的小方块，会发现点击的小方块变黑，然后点击角度控件，会看到小方块变橙色，这就说明子VI左上角的接线端被设定为角度输入。同理可设置右上角的接线端为弧度输出。<br><img src="https://img-blog.csdnimg.cn/20210420172201441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>（2）设置图标</strong><br>&emsp;&emsp;双击右上角的图标，可以打开一个图标编辑器。这里可以使用Labview的模板图标，也可以自己画图标，画图标的方法与windows中的画图工具很类似。<br><img src="https://img-blog.csdnimg.cn/20210420172814312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021042017282462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-2-子VI的调用"><a href="#2-2-子VI的调用" class="headerlink" title="2.2 子VI的调用"></a>2.2 子VI的调用</h4><p>&emsp;&emsp;新建一个VI，在程序框图的空白处**右键-选择VI…**，打开刚才保存的子VI程序，可以看到我们刚刚创建的子VI被调用出来了。<br><img src="https://img-blog.csdnimg.cn/20210420172427396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420172954115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;可以利用这个子VI创建一个简单的正弦曲线。<br><img src="https://img-blog.csdnimg.cn/20210420173227213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>Labview状态机的介绍与程序示例</title>
    <url>/2021/04/20/095-Labview%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="一、状态机简介"><a href="#一、状态机简介" class="headerlink" title="一、状态机简介"></a>一、状态机简介</h2><p>&emsp;&emsp;状态机是在工程应用中使用最多的设计模型。使用状态机，我们可以很容易的实现程序流程图中的判断、分支。<br>&emsp;&emsp;Labview状态机是由<strong>一个While循环、一个条件结构和一个移位寄存器</strong>组成的。其中while循环用来保证程序可以连续的运行；条件结构的各种分支中的代码用来描述状态机的各种状态，以及下一状态的选择；移位寄存器用来将之前状态所作出的选择传递到下一次循环的选择端子。</p>
<h2 id="二、状态机的基本框架"><a href="#二、状态机的基本框架" class="headerlink" title="二、状态机的基本框架"></a>二、状态机的基本框架</h2><p>&emsp;&emsp;在程序框图中创建一个while循环，并在while循环上添加移位寄存器，然后再while循环内创建一个条件结构，条件结构的选择端是一个枚举常量。<br><img src="https://img-blog.csdnimg.cn/20210420175605662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="三、例程"><a href="#三、例程" class="headerlink" title="三、例程"></a>三、例程</h2><h4 id="3-1-运行效果"><a href="#3-1-运行效果" class="headerlink" title="3.1 运行效果"></a>3.1 运行效果</h4><p>按下开始按钮后，LED开始以输入的时间间隔闪烁，按下停止按钮，程序停止运行。<br><img src="https://img-blog.csdnimg.cn/20210420214013472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-2-程序框图"><a href="#3-2-程序框图" class="headerlink" title="3.2 程序框图"></a>3.2 程序框图</h4><p><strong>程序框图如下：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210420214206601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420214221611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420214231106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>枚举类型的分支情况如下：</strong><br>&emsp;&emsp;设置三项分别为：“开始”、“亮”、灭。然后在条件结构的分支处，<strong>右键-为每个值添加分支</strong><br>&emsp;&emsp;其中左侧初始值与”开始“分支内的都是同一个枚举常量（即通过复制粘贴得到的）。<br><img src="https://img-blog.csdnimg.cn/20210420175448105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420175434109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-3-程序逻辑"><a href="#3-3-程序逻辑" class="headerlink" title="3.3 程序逻辑"></a>3.3 程序逻辑</h4><ul>
<li><p>初始条件的输入值为“开始”，进入“开始”的条件分支进行判断。</p>
<ul>
<li>如果按钮按下，输出“亮”，并作为下一次条件的输入；</li>
<li>如果按钮未按下，输出“开始”，并作为下一次条件的输入，即保持原状态。</li>
</ul>
</li>
<li><p>如果条件的输入为“亮”，此时条件输出“灭”，并作为下一次的输入。</p>
</li>
<li><p>如果条件的输入为“灭”，此时条件输出“亮”，并作为下一次的输入。</p>
</li>
</ul>
<p>在“开始”和“灭”分支进行期间，为LED赋值False；在“亮”分支期间，为LED赋值True。</p>
<p>这样就实现了：启动程序后，程序一直循环执行“开始”分支，LED灯灭。按下按钮后，程序在“亮”分支和”灭“分支交替执行，实现LED灯的亮灭变化。</p>
<p>可以通过为while循环添加等待延时调整LED闪烁时间。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>LabVIEW</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>labview</tag>
      </tags>
  </entry>
  <entry>
    <title>Proteus8.9 下载与安装教程</title>
    <url>/2021/04/27/096-Proteus8.9%20%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>百度网盘链接：<a href="https://pan.baidu.com/s/1EHGewnvjcnEpPbXnR1qLIA">https://pan.baidu.com/s/1EHGewnvjcnEpPbXnR1qLIA</a><br>提取码: pr89<br>&emsp;&emsp;<br>阿里云盘链接：<a href="https://www.aliyundrive.com/s/29x1H7qy3Hz">https://www.aliyundrive.com/s/29x1H7qy3Hz</a><br>下载后将后缀改为.zip即可正常解压。</p>
<blockquote>
<p>百度网盘链接：<a href="https://pan.baidu.com/s/1EHGewnvjcnEpPbXnR1qLIA">https://pan.baidu.com/s/1EHGewnvjcnEpPbXnR1qLIA</a><br>提取码: pr89<br>&emsp;&emsp;<br>阿里云盘链接：<a href="https://www.aliyundrive.com/s/29x1H7qy3Hz">https://www.aliyundrive.com/s/29x1H7qy3Hz</a><br>下载后将后缀改为.zip即可正常解压。</p>
</blockquote>
<ol>
<li><p>右键压缩包，进行解压。进入解压的文件夹，右键<strong>p8.9.sp0.exe</strong>文件，使用管理员身份打开。<br><img src="https://img-blog.csdnimg.cn/2021042716183398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427155955965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这里可能有些机器会先弹出安装Visual C++的一个界面，一定要安装这些勾选的组件，否则后续安装会出现问题。<br><img src="https://img-blog.csdnimg.cn/img_convert/a463f19ba7ccc15c4b754107dbd96cfb.png" alt="在这里插入图片描述"></p>
</li>
<li><p>莫得选择，next<br><img src="https://img-blog.csdnimg.cn/20210427160040896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>I accept，然后next<br><img src="https://img-blog.csdnimg.cn/20210427160122443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>选择使用本地的激活证书license key。<br><img src="https://img-blog.csdnimg.cn/20210427160222163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>继续next<br><img src="https://img-blog.csdnimg.cn/20210427160250894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>这里会打开一个激活证书管理界面，点击左下角【Browse For Key File】，找到刚才解压出来的文件夹，里面解压后的【Proteus 8.9】文件夹中的【Crack】文件夹下的【Licence.lxk】文件，点击【打开】。<br><img src="https://img-blog.csdnimg.cn/20210427160407818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427160555445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>点击 【<strong>install</strong>】，在弹出的对话框询问是否继续，选择 【<strong>是</strong>】，安装完成后点击【<strong>Close</strong>】。<br><img src="https://img-blog.csdnimg.cn/20210427160626557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427160803299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427160923597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center0" alt="在这里插入图片描述"></p>
</li>
<li><p>都不用勾选，直接【<strong>next</strong>】<br><img src="https://img-blog.csdnimg.cn/2021042716101041.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>这里选择安装方式，选择【<strong>Custom</strong>】，然后选择要安装的路径，<strong>注意：两个路径一定要一样，否则后期软件使用时会闪退</strong>。<br><img src="https://img-blog.csdnimg.cn/20210427161954839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427162148838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>这里不用管，默认【<strong>Next</strong>】就可以。<br><img src="https://img-blog.csdnimg.cn/20210427162239902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>继续【<strong>Next</strong>】<br><img src="https://img-blog.csdnimg.cn/20210427162332399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>点击【<strong>Install</strong>】开始安装，安装耗时一分钟左右。<br><img src="https://img-blog.csdnimg.cn/20210427162402735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210427161154275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol start="13">
<li><p>点击【<strong>Close</strong>】，不要运行Proteus<br><img src="https://img-blog.csdnimg.cn/20210427161358541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>再次进入安装包解压后的【<strong>Proteus 8.9</strong>】文件夹中的【<strong>Crack</strong>】文件夹，选择所有文件【<strong>复制</strong>】。<br><img src="https://img-blog.csdnimg.cn/20210427162558619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>在桌面找到【<strong>Proteus 8.9</strong>】的快捷方式，右键点击【<strong>打开文件所在的位置</strong>】<br><img src="https://img-blog.csdnimg.cn/20210427162858842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>在空白处【<strong>右键-粘贴</strong>】，将刚才那三个文件复制过来。<br><img src="https://img-blog.csdnimg.cn/20210427163052411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>右键<strong>粘贴后</strong>的【<strong>pp8.9</strong>】选择【<strong>以管理员身份运行</strong>】。（运行完成后不会弹出任何对话窗，运行一下就可以），建议关闭各种安全管家之后再运行。<br><img src="https://img-blog.csdnimg.cn/20210427163431335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>再次打开解压后的【Proteus 8.9】文件夹，鼠标右击【Translations】选择【复制】。<br><img src="https://img-blog.csdnimg.cn/20210427163922127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>再次右键桌面【<strong>Proteus 8.9</strong>】的快捷方式，右键点击【<strong>打开文件所在的位置</strong>】<br><img src="https://img-blog.csdnimg.cn/20210427162858842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>点击路径中的【<strong>Proteus</strong>】文件夹，回到上一级。<br><img src="https://img-blog.csdnimg.cn/20210427163623221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>在空白处【<strong>右键-粘贴</strong>】，将刚才复制的Translation文件夹粘过来，可能会有27/28个同名文件，点击【<strong>替换目标中的文件</strong>】。<br><img src="https://img-blog.csdnimg.cn/20210427164054243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427164207604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>进入【<strong>C:\Program Files (x86)\Labcenter Electronics</strong>】目录下，有一个【<strong>Proteus 8 Professional</strong>】文件夹，进入此文件夹，【<strong>全选-复制这两个文件夹</strong>】。<br><img src="https://img-blog.csdnimg.cn/20210427172105339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>回到Proteus的安装路径（同19、20步），【<strong>右键粘贴，替换目标文件</strong>】<br><img src="https://img-blog.csdnimg.cn/20210427172526413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<p><strong>至此，安装完成！</strong><br><img src="https://img-blog.csdnimg.cn/20210427173415459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>proteus</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】Win10下OpenCV4.5+VS2019安装与环境搭建（详细过程）</title>
    <url>/2021/07/16/097-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91Win10%E4%B8%8BOpenCV4.5+VS2019%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、软件准备"><a href="#一、软件准备" class="headerlink" title="一、软件准备"></a>一、软件准备</h2><h4 id="1-1-下载并解压OpenCV"><a href="#1-1-下载并解压OpenCV" class="headerlink" title="1.1 下载并解压OpenCV"></a>1.1 下载并解压OpenCV</h4><p>&emsp;&emsp;建议到<a href="https://opencv.org/">opencv的官网</a>下载windows版本的安装包。</p>
<blockquote>
<p>如果觉得下载速度过慢，我也把opencv4.5.2安装包上传了阿里云<br><a href="https://www.aliyundrive.com/s/VGkaM7vyuck">https://www.aliyundrive.com/s/VGkaM7vyuck</a></p>
</blockquote>
<img src="https://img-blog.csdnimg.cn/img_convert/58ebcb7903702e479292e81f4ddb70c3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<img src="https://img-blog.csdnimg.cn/img_convert/7fcdd6daaf59b6348a801b75853dce1f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<p>&emsp;&emsp;下载完之后，双击运行这个文件，<strong>注意解压的路径，一定要是一个英文路径</strong>，等待一段时间解压完成即可。<br><img src="https://img-blog.csdnimg.cn/img_convert/d6262de5383006717ba6700941e85e2d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%"></p>
<h4 id="1-2-下载并安装Visual-Studio"><a href="#1-2-下载并安装Visual-Studio" class="headerlink" title="1.2 下载并安装Visual Studio"></a>1.2 下载并安装Visual Studio</h4><p>&emsp;&emsp;这里我使用的是Visual Studio 2019 专业版，<a href="https://visualstudio.microsoft.com/zh-hans/vs/">官网</a>就可以下载。使用其他版本的VS也可以，没有特别要求。</p>
<p>&emsp;&emsp;安装时勾选<strong>使用C++的桌面开发</strong>，然后修改安装位置，其他配置都可以默认。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/cb0c8efb4ceb3ebe695aa460fa232ce5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<img src="https://img-blog.csdnimg.cn/img_convert/7628f067e20237fc9e9db31c838672ad.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<blockquote>
<p>安装完成后，如果需要VS2019 Pro注册码：<code>NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y</code></p>
</blockquote>
<h2 id="二、配置OpenCV环境"><a href="#二、配置OpenCV环境" class="headerlink" title="二、配置OpenCV环境"></a>二、配置OpenCV环境</h2><h4 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h4><p>&emsp;&emsp;新建一个<strong>控制台项目</strong>。<br><img src="https://img-blog.csdnimg.cn/img_convert/7e245920aa0908dabe4943be4a69f3b5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%"></p>
<img src="https://img-blog.csdnimg.cn/img_convert/ba6acdb91b130e1fbe78f7186d1658d1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<p>&emsp;&emsp;配置如下图中为<strong>Release</strong>和<strong>x64</strong>版本。<br><img src="https://img-blog.csdnimg.cn/img_convert/9d2be154393957abac93b482c367d760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%"></p>
<h4 id="2-2-配置属性"><a href="#2-2-配置属性" class="headerlink" title="2.2 配置属性"></a>2.2 配置属性</h4><p>&emsp;&emsp;打开<strong>视图-其他窗口-属性管理器</strong>（其他版本的VS可能是视图-属性管理器）。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/e081a18b614a44e6ce22535970679079.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<p>&emsp;&emsp;在属性管理器内<strong>右键“Microsoft Cpp x64 user”并点击属性</strong>，打开它的属性页。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/e329837facba80b57592d0121cf14ec7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<p>&emsp;&emsp;①配置<strong>VC++ 目录-&gt;包含目录</strong></p>
<img src="https://img-blog.csdnimg.cn/img_convert/51591ac9a403ff5b6249622ad9b91e20.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<p>&emsp;&emsp;在编辑页面添加两个新行，第一个是解压的opencv下面的  <strong><code>opencv/build/include</code></strong>  这个目录，第二个是  <strong><code>opencv/build/include/opencv2</code></strong>  这个目录，添加完成后点击确定回到属性页。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/9ebac5643a03dc6cd366a0c3929d2797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<p>&emsp;&emsp;</p>
<img src="https://img-blog.csdnimg.cn/img_convert/a975fd9e4b9153139a6c1ae7c4bd1037.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<p>&emsp;&emsp;</p>
<img src="https://img-blog.csdnimg.cn/img_convert/00fdf0f70c4d331b1ec609e33c0cd914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<p>&emsp;&emsp;</p>
<img src="https://img-blog.csdnimg.cn/img_convert/891d2e116d39dbe5e5b5478389243106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<p>&emsp;&emsp;②继续配置<strong>VC++目录-&gt;库目录</strong><br>&emsp;&emsp;<br><img src="https://img-blog.csdnimg.cn/img_convert/9836148df92c27e350ab6947e88555ae.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%"><br>&emsp;&emsp;在编辑页面添加项  <strong><code>opencv/build/x64/vc15</code></strong>  ，添加完成后同样点击确定回到属性页。</p>
<blockquote>
<p>这里如果是vs2019，那么用最新的vc15会好一些，如果是之前的版本，可以选择vc14目录</p>
</blockquote>
<img src="https://img-blog.csdnimg.cn/img_convert/b5d8cb486c7af5269a2dfdcfdba1973f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">
&emsp;&emsp;
<img src="https://img-blog.csdnimg.cn/img_convert/df376a1c2392d47b46eebff044ad378a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<p>&emsp;&emsp;③继续配置<strong>链接器-&gt;输入-&gt;附加依赖性</strong></p>
<img src="https://img-blog.csdnimg.cn/img_convert/9f75a83445120d6b60e0653b8e8bf039.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<p>&emsp;&emsp;复制release版本的lib文件名，在编辑项中粘贴即可</p>
<img src="https://img-blog.csdnimg.cn/img_convert/a371f4d584dc84e6875643cf3587ed7d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">
&emsp;&emsp;
<img src="https://img-blog.csdnimg.cn/img_convert/8a632206d5cebaff8a08b3fa1f45aa5d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<p>&emsp;&emsp;完成以上配置之后，点击右下角的<strong>应用-确定</strong>就可以了。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/f6ab12c5f78033318e5bca7cc2af218d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<h4 id="2-3-配置环境变量"><a href="#2-3-配置环境变量" class="headerlink" title="2.3 配置环境变量"></a>2.3 配置环境变量</h4><p>&emsp;&emsp;复制bin文件夹目录。<br><img src="https://img-blog.csdnimg.cn/img_convert/fa6e04a589a630088098d0e60f986dde.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%"><br>&emsp;&emsp;回到桌面，<strong>右键计算机-属性-高级系统设置</strong>，打开环境变量。<br><img src="https://img-blog.csdnimg.cn/img_convert/092696a76edf928b3cbb12a97ff24935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%"></p>
<img src="https://img-blog.csdnimg.cn/img_convert/e98abda2bb7338b82723329c501242ee.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<p>&emsp;&emsp;找到系统变量中的Path，点击编辑。<br><img src="https://img-blog.csdnimg.cn/img_convert/f445d0ff81b7d6a57c7e3a237433f668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%"></p>
<p>&emsp;&emsp;添加一项新项，将刚才复制的bin文件夹目录粘贴过来，然后确定。<br><img src="https://img-blog.csdnimg.cn/img_convert/a20530bdd48fb50af6d2634a020494db.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%"><br>&emsp;&emsp;<strong>关掉Visual Studio，再重新打开软件</strong>。</p>
<h2 id="三、测试程序"><a href="#三、测试程序" class="headerlink" title="三、测试程序"></a>三、测试程序</h2><p>&emsp;&emsp;在创建的cpp文件中，添加如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	Mat src = <span class="built_in">imread</span>(<span class="string">&quot;F:/NutStore/Documents/素材库/Logo/Huffie.jpg&quot;</span>);<span class="comment">//自己找一张图片</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;input&quot;</span>, src);</span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">destroyAllWindows</span>();;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后生成解决方案，如果没有报错，那么恭喜你！    如果出现错误，那么请自习搜索一下错误原因，或者仔细检查以上的每一步。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/d0c491156520fe70d48963852113bb0d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<p>测试-&gt;开始执行（不调试）<br><img src="https://img-blog.csdnimg.cn/img_convert/f931623d36254451538bc83dfd79ea4d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%"></p>
<img src="https://img-blog.csdnimg.cn/img_convert/9994db93fb562b346644f83ee736ebed.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<p>&emsp;&emsp;</p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】图像的基本操作</title>
    <url>/2021/07/17/098-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91%E5%9B%BE%E5%83%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="一、图像色彩空间转换"><a href="#一、图像色彩空间转换" class="headerlink" title="一、图像色彩空间转换"></a>一、图像色彩空间转换</h2><h4 id="1-1-基本知识"><a href="#1-1-基本知识" class="headerlink" title="1.1 基本知识"></a>1.1 基本知识</h4><ol>
<li>色彩空间转换函数：cvtColor<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">COLOR_BGR2GRAY = <span class="number">6</span>	<span class="comment">//6彩色到灰度</span></span><br><span class="line">COLOR_GRAY2BGR = <span class="number">8</span>	<span class="comment">//8灰度到彩色</span></span><br><span class="line">COLOR_BGR2HSV = <span class="number">40</span>	<span class="comment">//40BGR到HSV</span></span><br><span class="line">COLOR_HSV2BGR = <span class="number">54</span>	<span class="comment">//54HSV到BGR</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>GRAY：指灰度，只有一个参数灰度值Channel<br>BGR：指BGR颜色空间，以红绿蓝三基色(0<del>255)为基础，叠加形成各种颜色<br>HSV：指六角椎体模型，色调Hue用角度度量（0</del>180），饱和度Saturation（0 ~ 255），亮度Value（0 ~ 255）</p>
<img src="https://img-blog.csdnimg.cn/20210717084729949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="40%"></blockquote>
</li>
</ol>
<ol start="2">
<li>图像保存函数：imwrite<blockquote>
<p>第一个参数是图像保存路径<br>第二个参数是图像内存对象</p>
</blockquote>
</li>
</ol>
<h4 id="1-2-创建类"><a href="#1-2-创建类" class="headerlink" title="1.2 创建类"></a>1.2 创建类</h4><p>①首先添加一个头文件。</p>
<img src="https://img-blog.csdnimg.cn/20210717085808806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<p>&emsp;&emsp;</p>
<img src="https://img-blog.csdnimg.cn/2021071710584123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">
&emsp;&emsp;

<p>②头文件内定义一个MyDemo类，代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">colorSpace_Demo</span><span class="params">(Mat &amp;image)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>③添加包含目录。首先在项目名称上<strong>右键-属性</strong>，打开属性页后，编辑<strong>VC++目录-&gt;包含目录</strong>这一项，新建项为头文件所在的目录如图。</p>
<img src="https://img-blog.csdnimg.cn/20210717090541121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<p>&emsp;&emsp;</p>
<img src="https://img-blog.csdnimg.cn/20210717090624883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<p>&emsp;&emsp;</p>
<img src="https://img-blog.csdnimg.cn/20210717090745775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<p>&emsp;&emsp;</p>
<p>④创建一个cpp文件，实现刚才定义的类。</p>
<img src="https://img-blog.csdnimg.cn/20210717090834711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="50%">


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mydemo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::colorSpace_Demo</span><span class="params">(Mat &amp;image)</span> </span>&#123;</span><br><span class="line">	Mat gray, hsv;</span><br><span class="line">	<span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);</span><br><span class="line">	<span class="built_in">cvtColor</span>(image, gray, COLOR_BGR2GRAY);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;HSV Image&quot;</span>, hsv);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Gray Image&quot;</span>, gray);</span><br><span class="line">	<span class="built_in">imwrite</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/hsv.png&quot;</span>, hsv);</span><br><span class="line">	<span class="built_in">imwrite</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/gray.png&quot;</span>, gray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-编写主函数"><a href="#1-3-编写主函数" class="headerlink" title="1.3 编写主函数"></a>1.3 编写主函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mydemo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	Mat src = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/opencv.jpg&quot;</span>);<span class="comment">//自己找一张图片</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;opencv.jpg&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">	MyDemo demo;</span><br><span class="line">	demo.<span class="built_in">colorSpace_Demo</span>(src);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">destroyAllWindows</span>();;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-测试结果"><a href="#1-4-测试结果" class="headerlink" title="1.4 测试结果"></a>1.4 测试结果</h4><img src="https://img-blog.csdnimg.cn/20210717100121460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<p>&emsp;&emsp;</p>
<blockquote>
<p>使用技巧：由于RGB三个参数仅代表颜色，HSV分别代表色调、饱和度、亮度。<br>因此对于一个图片想要调整亮度，可以先转换到HSV色彩空间调节亮度，再返回RGB色彩空间即可。</p>
</blockquote>
<h2 id="二、图像对象的创建与复制"><a href="#二、图像对象的创建与复制" class="headerlink" title="二、图像对象的创建与复制"></a>二、图像对象的创建与复制</h2><h4 id="2-1-什么是Mat"><a href="#2-1-什么是Mat" class="headerlink" title="2.1 什么是Mat"></a>2.1 什么是Mat</h4><blockquote>
<p>关于Mat的问题</p>
<ol>
<li>如何操作读进来的图像</li>
<li>如何遍历访问图像的每个像素点</li>
<li>如何创建一个空图像</li>
</ol>
</blockquote>
<p>在OpenCV中Mat的数据分为两个部分，<strong>头部和数据部分</strong>。头部包括数据类型、通道数量。</p>
<h4 id="2-2-创建空白图像"><a href="#2-2-创建空白图像" class="headerlink" title="2.2 创建空白图像"></a>2.2 创建空白图像</h4><p><strong>创建图像的过程</strong><br>①所用函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat m_new = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">8</span>, <span class="number">8</span>),CV_8UC1);</span><br><span class="line">Mat m_new = Mat::<span class="built_in">ones</span>(<span class="built_in">Size</span>(<span class="number">8</span>, <span class="number">8</span>),CV_8UC1);</span><br></pre></td></tr></table></figure>
<p>函数中的参数CV_8UC1，表示8位、unsigned char型、Channel通道数为1。</p>
<p>②添加头文件</p>
<p>接下来写demo尝试创建图像，在头文件内添加一行函数的声明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">colorSpace_Demo</span><span class="params">(Mat&amp; image)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">matCreation_Demo</span><span class="params">()</span></span>;	<span class="comment">//这一行是新加的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>③实现创建图像的函数</p>
<p>在mydemo.cpp文件中添加以下代码实现此函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::matCreation_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建空白图像</span></span><br><span class="line">	Mat m_new = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">8</span>, <span class="number">8</span>),CV_8UC1);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;width = &quot;</span> &lt;&lt; m_new.cols &lt;&lt; <span class="string">&quot;\theight = &quot;</span> &lt;&lt; m_new.rows &lt;&lt; <span class="string">&quot;\tchannels = &quot;</span> &lt;&lt; m_new.<span class="built_in">channels</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; m_new &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>④主函数调用并测试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mydemo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	MyDemo demo;</span><br><span class="line">	demo.<span class="built_in">matCreation_Demo</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">destroyAllWindows</span>();;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下图所示，是一个8x8的矩阵：<br><img src="https://img-blog.csdnimg.cn/20210717112130660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%"></p>
<p><strong>注意事项：</strong><br>&emsp;&emsp;<br>如果将通道数改为3，也就是<code>Mat m_new = Mat::zeros(Size(8, 8),CV_8UC3);</code>，那么输出结果会变成8x24的矩阵，也就是每个像素点会有三个值：</p>
<img src="https://img-blog.csdnimg.cn/20210717112233126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="100%">
&emsp;&emsp;

<p>如果对三通道使用ones进行初始化，那么只会使每个像素点的第一个通道初始化为1，第二、第三通道仍然初始化为0.</p>
<img src="https://img-blog.csdnimg.cn/2021071711305096.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="100%">
&emsp;&emsp;

<p>可以通过使用<code>Scalar</code>函数对图像所有像素点同时进行赋值。<strong>Scalar的三个参数分别为B、G、R</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::matCreation_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建空白图像</span></span><br><span class="line">	Mat m_new = Mat::<span class="built_in">ones</span>(<span class="built_in">Size</span>(<span class="number">8</span>, <span class="number">8</span>),CV_8UC3);</span><br><span class="line">	m_new = <span class="built_in">Scalar</span>(<span class="number">66</span>, <span class="number">66</span>, <span class="number">66</span>);</span><br><span class="line">	std::cout &lt;&lt; m_new &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/20210717113957742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="100%">

<p>&emsp;&emsp;</p>
<p><strong>图像在哪里</strong><br>刚才我们通过io输出，在控制台将图像的像素点值一个一个打印出来。我们当然也可以将它作为一个图像进行输出。只需要将cout换成imshow即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::matCreation_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建空白图像</span></span><br><span class="line">	Mat m_new = Mat::<span class="built_in">ones</span>(<span class="built_in">Size</span>(<span class="number">800</span>, <span class="number">600</span>),CV_8UC3);</span><br><span class="line">	m_new = <span class="built_in">Scalar</span>(<span class="number">66</span>, <span class="number">66</span>, <span class="number">66</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;new image&quot;</span>,m_new);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是我们生成出来的一个图像</p>
<img src="https://img-blog.csdnimg.cn/20210717114528458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<h4 id="2-3-图像的复制"><a href="#2-3-图像的复制" class="headerlink" title="2.3 图像的复制"></a>2.3 图像的复制</h4><p>对于Mat对象进行赋值操作时，只是相当于两个指针指向了同一块内存空间，只有进行<strong>克隆和拷贝</strong>操作时，才是真正的复制。</p>
<p>①克隆：clone</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m_clone = image.<span class="built_in">clone</span>();</span><br></pre></td></tr></table></figure>

<p>②拷贝：copyTo</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">image.<span class="built_in">copyTo</span>(m_copy);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】如何操作图像中的像素?</title>
    <url>/2021/07/18/099-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E5%9B%BE%E5%83%8F%E4%B8%AD%E7%9A%84%E5%83%8F%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="一、读写操作"><a href="#一、读写操作" class="headerlink" title="一、读写操作"></a>一、读写操作</h2><h4 id="1-1-数组遍历"><a href="#1-1-数组遍历" class="headerlink" title="1.1 数组遍历"></a>1.1 数组遍历</h4><p>&emsp;&emsp;由于图像本质就是Mat矩阵，因此要读写像素点，可以<strong>采用数组遍历的方式访问</strong>Mat矩阵内的每一个元素。但我们要注意，灰度图和彩色图的通道数是不一样的，<strong>灰度图是单通道的，彩色图是三通道的</strong>。因此读写像素点就分为了读写灰度图像素和读写彩色图像素两种情况。</p>
<p>① 读写灰度图像素</p>
<p>&emsp;&emsp;灰度图内每一个像素点对应Mat矩阵的一个值，因此访问灰度图的像素就相当于访问Mat矩阵的元素。其语法如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读灰度图像素</span></span><br><span class="line"><span class="keyword">int</span> pv = image.at&lt;uchar&gt;(row, col);</span><br><span class="line"><span class="comment">//写灰度图像素（反转颜色）</span></span><br><span class="line">image.at&lt;uchar&gt;(row, col) = <span class="number">255</span> - pv;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中由于每个灰度图像素为1个字节（0-255），因此使用uchar。其中的row代表Mat矩阵行数，col代表列数。</p>
<p>② 读写彩色图像</p>
<p>&emsp;&emsp;彩色图像中每个像素点对应Mat矩阵的三个值，访问方式类似灰度图像。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读彩色图像素</span></span><br><span class="line">Vec3b bgr = image.at&lt;Vec3b&gt;(row, col);</span><br><span class="line"><span class="comment">//写彩色图像素（反转颜色）</span></span><br><span class="line">image.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = <span class="number">255</span> - bgr[<span class="number">0</span>];</span><br><span class="line">image.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = <span class="number">255</span> - bgr[<span class="number">1</span>];</span><br><span class="line">image.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = <span class="number">255</span> - bgr[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由于访问彩色图像素点需要一次性读取三个值，因此我们使用了Vec3b这个结构（可以看成一个数组），可以直接将访问得到的三个值存储在Vec3b这个结构定义的变量中。<br>&emsp;&emsp;如果彩色像素点的值是整型，需要用Vec3i；如果是浮点数类型，需要用vec3f。</p>
<p>③ 示例程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::pixelVisit_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> w = image.cols;</span><br><span class="line">	<span class="keyword">int</span> h = image.rows;</span><br><span class="line">	<span class="keyword">int</span> dims = image.<span class="built_in">channels</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; h; row++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; w; col++) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//灰度图像</span></span><br><span class="line">			<span class="keyword">if</span> (dims == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> pv = image.at&lt;uchar&gt;(row, col);</span><br><span class="line">				image.at&lt;uchar&gt;(row, col) = <span class="number">255</span> - pv;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//彩色图像</span></span><br><span class="line">			<span class="keyword">if</span> (dims == <span class="number">3</span>) &#123;</span><br><span class="line">				Vec3b bgr = image.at&lt;Vec3b&gt;(row, col);</span><br><span class="line">				image.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = <span class="number">255</span> - bgr[<span class="number">0</span>];</span><br><span class="line">				image.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = <span class="number">255</span> - bgr[<span class="number">1</span>];</span><br><span class="line">				image.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = <span class="number">255</span> - bgr[<span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Pixel Visit Demo&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210718091652147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<h4 id="1-2-指针遍历"><a href="#1-2-指针遍历" class="headerlink" title="1.2 指针遍历"></a>1.2 指针遍历</h4><p>&emsp;&emsp;指针遍历的原理与数组遍历类似。定义一个指针指向当前行的首地址，然后利用此指针即可遍历访问本行所有像素点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::pixelVisit_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> w = image.cols;</span><br><span class="line">	<span class="keyword">int</span> h = image.rows;</span><br><span class="line">	<span class="keyword">int</span> dims = image.<span class="built_in">channels</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; h; row++) &#123;</span><br><span class="line">		uchar* current_row = image.ptr&lt;uchar&gt;(row);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; w; col++) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//灰度图像</span></span><br><span class="line">			<span class="keyword">if</span> (dims == <span class="number">1</span>) &#123;</span><br><span class="line">				*current_row++ = <span class="number">255</span> - *current_row;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//彩色图像</span></span><br><span class="line">			<span class="keyword">if</span> (dims == <span class="number">3</span>) &#123;</span><br><span class="line">				*current_row++ = <span class="number">255</span> - *current_row;</span><br><span class="line">				*current_row++ = <span class="number">255</span> - *current_row;</span><br><span class="line">				*current_row++ = <span class="number">255</span> - *current_row;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Pixel Visit Demo&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>current_row</code>随着循环的进行指向每一行的首地址。<br><code>*current_row++ = 255 - *current_row;</code>是指将 current_row 指向的值（灰度图的像素点或彩色图像素点的一个通道）色彩反转，然后令指针+1，使其指向下一个像素或像素的下一个通道。</p>
<h2 id="二、算术操作"><a href="#二、算术操作" class="headerlink" title="二、算术操作"></a>二、算术操作</h2><h4 id="2-1-像素的"><a href="#2-1-像素的" class="headerlink" title="2.1 像素的"></a>2.1 像素的</h4><p>&emsp;&emsp;对一个图像Mat矩阵可以直接进行加减乘除（注意彩色图加法需要Scalar），<strong>加减法处理的结果就是增大/减小图像的亮度，乘除法同理</strong>，但要注意在处理时可能会使像素值<strong>超出(0~255)的范围，可以使用saturate_cast函数进行截断</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//image * m -&gt; dst</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::operators_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	Mat m = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">	m = <span class="built_in">Scalar</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">	Mat dst = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> w = image.cols;</span><br><span class="line">	<span class="keyword">int</span> h = image.rows;</span><br><span class="line">	<span class="keyword">int</span> dims = image.<span class="built_in">channels</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; h; row++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; w; col++) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//灰度图像</span></span><br><span class="line">			<span class="keyword">if</span> (dims == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> pv = image.at&lt;uchar&gt;(row, col);</span><br><span class="line">				image.at&lt;uchar&gt;(row, col) = <span class="number">255</span> - pv;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//彩色图像</span></span><br><span class="line">			<span class="keyword">if</span> (dims == <span class="number">3</span>) &#123;</span><br><span class="line">				Vec3b p1 = image.at&lt;Vec3b&gt;(row, col);</span><br><span class="line">				Vec3b p2 = m.at&lt;Vec3b&gt;(row, col);</span><br><span class="line">				dst.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = saturate_cast&lt;uchar&gt;(p1[<span class="number">0</span>] * p2[<span class="number">0</span>]);</span><br><span class="line">				dst.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = saturate_cast&lt;uchar&gt;(p1[<span class="number">1</span>] * p2[<span class="number">1</span>]);</span><br><span class="line">				dst.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = saturate_cast&lt;uchar&gt;(p1[<span class="number">2</span>] * p2[<span class="number">2</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;operator&quot;</span>,dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210718102155704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<h4 id="2-2-图像算术操作API"><a href="#2-2-图像算术操作API" class="headerlink" title="2.2 图像算术操作API"></a>2.2 图像算术操作API</h4><table>
<thead>
<tr>
<th>功能</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>加法</td>
<td>add(img1, img2, imgout);</td>
</tr>
<tr>
<td>减法</td>
<td>subtract(img1, img2, imgout);</td>
</tr>
<tr>
<td>乘法</td>
<td>multiply(img1, img2, imgout);</td>
</tr>
<tr>
<td>除法</td>
<td>divide(img1, img2, imgout);</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::operators_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	Mat dst = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">	Mat m = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">	m = <span class="built_in">Scalar</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//add(image, m, dst);</span></span><br><span class="line">	<span class="comment">//subtract(image, m, dst);</span></span><br><span class="line">	<span class="built_in">multiply</span>(image, m, dst);</span><br><span class="line">	<span class="comment">//divide(image, m, dst);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;operator&quot;</span>,dst);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、逻辑操作"><a href="#三、逻辑操作" class="headerlink" title="三、逻辑操作"></a>三、逻辑操作</h2><h4 id="3-1-基本知识—真值表"><a href="#3-1-基本知识—真值表" class="headerlink" title="3.1 基本知识—真值表"></a>3.1 基本知识—真值表</h4><table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>与</th>
<th>或</th>
<th>异或</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<h4 id="3-2-画个矩形"><a href="#3-2-画个矩形" class="headerlink" title="3.2 画个矩形"></a>3.2 画个矩形</h4><p>&emsp;&emsp;为了更直观的显示像素逻辑运算的结果，我们可以画两个矩形，让两个矩形的相交区域进行逻辑运算。<br>&emsp;&emsp;画矩形方法很简单，只需要先创建一个空白图像，然后调用rectangle函数就可以。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rectangle</span>(m1, <span class="built_in">Rect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">rectangle</span>(被处理图像, 左上点坐标, 颜色, 线宽, 线型, 坐标点的小数点位数);</span><br></pre></td></tr></table></figure>
<p>示例程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::bitWise_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	Mat m1 = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">256</span>, <span class="number">256</span>), CV_8UC3);</span><br><span class="line">	Mat m2 = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">256</span>, <span class="number">256</span>), CV_8UC3);</span><br><span class="line">	<span class="built_in">rectangle</span>(m1, <span class="built_in">Rect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">rectangle</span>(m2, <span class="built_in">Rect</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;m1&quot;</span>, m1);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;m2&quot;</span>, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-逻辑运算"><a href="#3-3-逻辑运算" class="headerlink" title="3.3 逻辑运算"></a>3.3 逻辑运算</h4><table>
<thead>
<tr>
<th>运算</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>与</td>
<td>bitwise_and(m1, m2, dst);</td>
</tr>
<tr>
<td>或</td>
<td>bitwise_or(m1, m2, dst);</td>
</tr>
<tr>
<td>非</td>
<td>bitwise_not(m1, dst);</td>
</tr>
<tr>
<td>异或</td>
<td>bitwise_xor(m1, m2, dst);</td>
</tr>
</tbody></table>
<p>以“与”操作为例，试验代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::bitWise_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	Mat m1 = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">256</span>, <span class="number">256</span>), CV_8UC3);</span><br><span class="line">	Mat m2 = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">256</span>, <span class="number">256</span>), CV_8UC3);</span><br><span class="line">	<span class="built_in">rectangle</span>(m1, <span class="built_in">Rect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">rectangle</span>(m2, <span class="built_in">Rect</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;m1&quot;</span>, m1);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;m2&quot;</span>, m2);</span><br><span class="line">	Mat dst;</span><br><span class="line">	<span class="built_in">bitwise_and</span>(m1, m2, dst);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;bitWise&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>区域</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td>背景</td>
<td>Scalar(0, 0, 0)</td>
</tr>
<tr>
<td>矩形1</td>
<td>Scalar(255, 255, 0)</td>
</tr>
<tr>
<td>矩形2</td>
<td>Scalar(0, 255, 255)</td>
</tr>
<tr>
<td>相交区域</td>
<td>Scalar(0, 255, 0)</td>
</tr>
<tr>
<td>其他区域</td>
<td>Scalar(0, 0, 0)</td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/20210718110408134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%"></td>
<td></td>
</tr>
<tr>
<td>&emsp;&emsp;</td>
<td></td>
</tr>
<tr>
<td>&emsp;&emsp;其他的“或”、“非”、“异或”操作类似，有兴趣的可以自己尝试。</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】滚动条Trackbar的创建与使用详解</title>
    <url>/2021/07/19/100-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91%E6%BB%9A%E5%8A%A8%E6%9D%A1Trackbar%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="一、Trackbar的创建方法"><a href="#一、Trackbar的创建方法" class="headerlink" title="一、Trackbar的创建方法"></a>一、Trackbar的创建方法</h2><h4 id="1-1-createTrackbar"><a href="#1-1-createTrackbar" class="headerlink" title="1.1 createTrackbar"></a>1.1 createTrackbar</h4><p>&emsp;&emsp;OpenCV中使用<code>createTrackbar()</code>来创建滚动条，函数的使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">createTrackbar</span>(<span class="keyword">const</span> String&amp; trackbarname, <span class="keyword">const</span> String&amp; winname,<span class="keyword">int</span> value, <span class="keyword">int</span> count,TrackbarCallback onChange = <span class="number">0</span>,<span class="keyword">void</span> userdata = <span class="number">0</span>); </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>位置</th>
<th>参数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>trackbar name</td>
<td>滚动条的名字</td>
</tr>
<tr>
<td>2</td>
<td>winname</td>
<td>绑定的窗口名字</td>
</tr>
<tr>
<td>3</td>
<td>value</td>
<td>滑块的初始位置</td>
</tr>
<tr>
<td>4</td>
<td>count</td>
<td>滑块的最大位置</td>
</tr>
<tr>
<td>5</td>
<td>TrackbarCallback</td>
<td>回调函数，拨动Trackbar返回的函数</td>
</tr>
<tr>
<td>6</td>
<td>userdata</td>
<td>用户传给回调函数的数据，不用默认为0</td>
</tr>
</tbody></table>
<h4 id="1-2-回调函数"><a href="#1-2-回调函数" class="headerlink" title="1.2 回调函数"></a>1.2 回调函数</h4><p>&emsp;&emsp;第五个参数回调函数TrackbarCallback，是指拨动Trackbar会产生一个事件，系统会捕捉这个事件，然后发送给相应的处理者，因此需要定义一个函数进行相应的处理。回调函数的定义规范如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callbackfunc</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">void</span>* userdata)</span></span>;</span><br></pre></td></tr></table></figure>
<p>value传入的是滑块位置变量。<br>userdata是打包的其他数据，可以通过如结构体的方法打包数据发送给回调函数。当createTrackbar函数最后一个参数为0时表示不使用userdata，这时可以通过全局变量为回调函数传递数据。</p>
<h2 id="二、使用Trackbar调节图片亮度"><a href="#二、使用Trackbar调节图片亮度" class="headerlink" title="二、使用Trackbar调节图片亮度"></a>二、使用Trackbar调节图片亮度</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onTrack</span><span class="params">(<span class="keyword">int</span> lightness, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">	Mat src = *(Mat*)data;	<span class="comment">//将void类型指针转换为Mat类型指针，然后再取数据</span></span><br><span class="line">	Mat m = Mat::<span class="built_in">zeros</span>(src.<span class="built_in">size</span>(), src.<span class="built_in">type</span>());</span><br><span class="line">	Mat dst = Mat::<span class="built_in">zeros</span>(src.<span class="built_in">size</span>(), src.<span class="built_in">type</span>());</span><br><span class="line">	m = <span class="built_in">Scalar</span>(lightness, lightness, lightness);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">add</span>(src, m, dst);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Change Lightness&quot;</span>, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::checkBar_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">namedWindow</span>(<span class="string">&quot;Change Lightness&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> lightness = <span class="number">50</span>;</span><br><span class="line">	<span class="keyword">int</span> max_value = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">createTrackbar</span>(<span class="string">&quot;Value Bar&quot;</span>, <span class="string">&quot;Change Lightness&quot;</span>, &amp;lightness, max_value, onTrack,(<span class="keyword">void</span> *)&amp;image);<span class="comment">//最后一个参数强制转换为void类型指针</span></span><br><span class="line">	<span class="built_in">onTrack</span>(lightness, &amp;image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210718220023754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】图像通道的分离、合并与混合方法（C++）</title>
    <url>/2021/07/20/101-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91%E5%9B%BE%E5%83%8F%E9%80%9A%E9%81%93%E7%9A%84%E5%88%86%E7%A6%BB%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%8E%E6%B7%B7%E5%90%88%E6%96%B9%E6%B3%95%EF%BC%88C++%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、图像通道的分离"><a href="#一、图像通道的分离" class="headerlink" title="一、图像通道的分离"></a>一、图像通道的分离</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> cv::Mat&amp; image, <span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">	vector&lt;Mat&gt;&amp; mv <span class="comment">// 输出的多通道序列（n个单通道序列）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输出的多通道序列一般使用 <code>std::vector&lt;Mat&gt; mv;</code> 来存储，<code>mv[0]</code> 、<code>mv[1]</code>、<code>mv[2]</code>、分别对应BGR三个通道。<br>&emsp;&emsp;<br>&emsp;&emsp;示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::channels_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	std::vector&lt;Mat&gt; mv;</span><br><span class="line">	<span class="built_in">split</span>(image, mv);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Blue Channel&quot;</span>, mv[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Green Channel&quot;</span>, mv[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Red Channel&quot;</span>, mv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210720121303160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">


<h2 id="二、通道的合并"><a href="#二、通道的合并" class="headerlink" title="二、通道的合并"></a>二、通道的合并</h2><p>&emsp;&emsp;但是现在显示的相当于是三张单通道的图像，也就相当于三张灰度图像。要想让三张图像恢复直观意义上的色彩，就需要使用下面通道合并的方法了。</p>
<p>&emsp;&emsp;通道的合并需要用到 <code>merge()</code> 函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> vector&lt;cv::Mat&gt;&amp; mv, <span class="comment">// 输入的多通道序列(n个单通道序列)</span></span></span></span><br><span class="line"><span class="params"><span class="function">	cv::OutputArray dst <span class="comment">// 输出图像，包含mv</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据 <code>merge()</code> 函数的定义，我们只需要控制输入的多通道数组 <code>mv[]</code> 中的三个值，就可以实现通道的合并。</p>
<p>&emsp;&emsp;示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::channels_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	std::vector&lt;Mat&gt; mv;</span><br><span class="line">	<span class="built_in">split</span>(image, mv);</span><br><span class="line">	</span><br><span class="line">	Mat m1,m2,m3;</span><br><span class="line">	mv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	mv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">merge</span>(mv, m1);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Blue Channel&quot;</span>, m1);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">split</span>(image, mv);</span><br><span class="line">	mv[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	mv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">merge</span>(mv, m2);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Green Channel&quot;</span>, m2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">split</span>(image, mv);</span><br><span class="line">	mv[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	mv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">merge</span>(mv, m3);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Red Channel&quot;</span>, m3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/20210720122023377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<p>&emsp;&emsp;我们已经知道如何将图像的三个通道提取出来了，因此我们可以将三个通道进行任意组合，合并出我们想要的图片。</p>
<h2 id="三、通道的混合"><a href="#三、通道的混合" class="headerlink" title="三、通道的混合"></a>三、通道的混合</h2><p>&emsp;&emsp;通道的混合也是将三个通道进行任意排列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C++: <span class="function"><span class="keyword">void</span> <span class="title">mixChannels</span><span class="params">(<span class="keyword">const</span> Mat*src, <span class="keyword">size_t</span> nsrcs, Mat* dst, <span class="keyword">size_t</span> ndsts, <span class="keyword">const</span> <span class="keyword">int</span>* fromTo, <span class="keyword">size_t</span> npairs)</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>输入矩阵</td>
</tr>
<tr>
<td>nsrcs</td>
<td>输入矩阵的个数</td>
</tr>
<tr>
<td>dst</td>
<td>输出矩阵</td>
</tr>
<tr>
<td>ndsts</td>
<td>输出矩阵的个数</td>
</tr>
<tr>
<td>fromTo</td>
<td>序号对向量</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::channels_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	Mat dst = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">	<span class="keyword">int</span> ft[] = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span> &#125;;<span class="comment">//互换1、3通道</span></span><br><span class="line">	<span class="built_in">mixChannels</span>(&amp;image,<span class="number">1</span>, &amp;dst,<span class="number">1</span>, ft,<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Mix&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210720123205231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】教你替换绿幕背景</title>
    <url>/2021/07/21/102-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91%E6%95%99%E4%BD%A0%E6%9B%BF%E6%8D%A2%E7%BB%BF%E5%B9%95%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<p>绿幕图像的背景替换需要经历①色彩空间转换、②提取绿幕区域、③反转绿幕区域、④复制图像，其中遇到的各种函数和代码也都在本文有详细介绍。</p>
<h2 id="一、色彩空间转换"><a href="#一、色彩空间转换" class="headerlink" title="一、色彩空间转换"></a>一、色彩空间转换</h2><p>&emsp;&emsp;要去除绿幕图像中的绿幕，首先需要<strong>将图像转换到hsv色彩空间</strong>，这样方便后续对图像的处理。使用 <code>cvtcolor()</code> 函数可以完成色彩空间的转换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::cvtColor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	InputArray 	src,		<span class="comment">//输入图像矩阵</span></span></span></span><br><span class="line"><span class="params"><span class="function">	OutputArray dst,		<span class="comment">//输出图像矩阵</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 		code,		<span class="comment">//转换方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 		dstCn = <span class="number">0</span>	<span class="comment">//目标图像通道数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span>	</span></span><br></pre></td></tr></table></figure>


<p>一般的使用方法如下，图像转换至hsv色彩空间的示例程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::inRange_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	Mat hsv;	<span class="comment">//存储转换后的hsv图像</span></span><br><span class="line">	<span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);<span class="comment">//进行色彩空间转换</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;hsv_image&quot;</span>, hsv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、提取绿幕区域"><a href="#二、提取绿幕区域" class="headerlink" title="二、提取绿幕区域"></a>二、提取绿幕区域</h2><p>&emsp;&emsp;图像转换到hsv色彩空间后，就可以进行色彩区域的提取了，这里使用的函数是 <code>inRange()</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inRange</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	InputArray 	src,	<span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">	InputArray	lowerb,	<span class="comment">//下边界数组阈值</span></span></span></span><br><span class="line"><span class="params"><span class="function">	InputArray	upperb,	<span class="comment">//上边界数组阈值</span></span></span></span><br><span class="line"><span class="params"><span class="function">	OutputArray dst		<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，由于HSV的取值范围为H(0-180)、S(0-255)、V(0-255)。因此上下边界数组阈值可以通过如下表格获取<br>| &emsp; | 黑   | 灰   | 白   | 红     | 橙   | 黄   | 绿   | 青   | 蓝   | 紫   |<br>| —— | —- | —- | —- | —— | —- | —- | —- | —- | —- | —- |<br>| hmin   | 0    | 0    | 0    | 0/156  | 11   | 26   | 35   | 78   | 100  | 125  |<br>| hmax   | 180  | 180  | 180  | 10/180 | 25   | 34   | 77   | 99   | 124  | 155  |<br>| smin   | 0    | 0    | 0    | 43     | 43   | 43   | 43   | 43   | 43   | 43   |<br>| smax   | 255  | 43   | 30   | 255    | 255  | 255  | 255  | 255  | 255  | 255  |<br>| vmin   | 0    | 46   | 221  | 46     | 46   | 46   | 46   | 46   | 46   | 46   |<br>| vmax   | 46   | 220  | 255  | 255    | 255  | 255  | 255  | 255  | 255  | 255  |</p>
<p> &emsp;&emsp;由于本文要替换绿幕，所以选择绿色的阈值，分别是：hmin=35、hmax=77、smin=43、smax=255、vmin=46、vmax=255。因此可以得到<strong>下边界数组为 <code>Scalar(35, 43, 46)</code> ，上边界数组为 <code>Scalar(77, 255, 255)</code></strong> 。</p>
<p> &emsp;&emsp;因此提取绿幕的程序如下：<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">MyDemo::inRange_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	Mat hsv;	<span class="comment">//存储转换后的hsv图像</span></span><br><span class="line">	<span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);<span class="comment">//进行色彩空间转换</span></span><br><span class="line">	Mat mask;	<span class="comment">//存储提取绿幕区域后的图像</span></span><br><span class="line">	<span class="built_in">inRange</span>(hsv, <span class="built_in">Scalar</span>(<span class="number">35</span>, <span class="number">43</span>, <span class="number">46</span>), <span class="built_in">Scalar</span>(<span class="number">77</span>, <span class="number">255</span>, <span class="number">255</span>), mask);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;mask&quot;</span>, mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<img src="https://img-blog.csdnimg.cn/img_convert/d53c611cad49825dae3f256ce47108dd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="50%">

<img src="https://img-blog.csdnimg.cn/img_convert/0aabee7fddc302d712e1e45e41840f16.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="100%">


<h2 id="三、替换背景"><a href="#三、替换背景" class="headerlink" title="三、替换背景"></a>三、替换背景</h2><p>&emsp;&emsp;前面已经完成了对绿幕区域的提取，接下来只需要对提取的区域反转，选择人物的区域，进而将人物复制到新背景即可。<br>&emsp;&emsp;反转选择区域使用的是 <code>bitwise_not()</code> 函数。<br>&emsp;&emsp;复制图像使用的是 <code>image.copyTo(newimage，mask)</code> 方法，作用是把mask和image重叠以后把mask中像素值为0（黑色）的点对应的image中的点变为透明，而保留其他点，将保留的点拷贝到newimage中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::inRange_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//转换色彩空间</span></span><br><span class="line">	Mat hsv;</span><br><span class="line">	<span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提取绿幕区域</span></span><br><span class="line">	Mat mask;</span><br><span class="line">	<span class="built_in">inRange</span>(hsv, <span class="built_in">Scalar</span>(<span class="number">35</span>, <span class="number">43</span>, <span class="number">46</span>), <span class="built_in">Scalar</span>(<span class="number">77</span>, <span class="number">255</span>, <span class="number">255</span>), mask);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;mask&quot;</span>, mask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反转提取人物区域	</span></span><br><span class="line">	<span class="built_in">bitwise_not</span>(mask, mask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//人物复制到新背景中</span></span><br><span class="line">	Mat bg = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/plantbg.jpg&quot;</span>);<span class="comment">//背景图片</span></span><br><span class="line">	image.<span class="built_in">copyTo</span>(bg, mask);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Finished&quot;</span>, bg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/img_convert/334066598b20e79263ec0b84df02b0f4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<img src="https://img-blog.csdnimg.cn/img_convert/ad0fda9ead5f0b3cf95e397da4307a2a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="100%">]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】几何图形的绘制方法</title>
    <url>/2021/07/22/103-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2%E7%9A%84%E7%BB%98%E5%88%B6%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>&emsp;&emsp;在正文开始之前，首先要知道屏幕中 <strong>(0, 0) 坐标点</strong>在左上角，最大坐标在右下角。</p>
<h2 id="一、基本图形的绘制"><a href="#一、基本图形的绘制" class="headerlink" title="一、基本图形的绘制"></a>一、基本图形的绘制</h2><h4 id="1-矩形"><a href="#1-矩形" class="headerlink" title="1. 矩形"></a>1. 矩形</h4><p>&emsp;&emsp;OpenCV中绘制矩形的函数为 <code>rectangle()</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rectangle</span><span class="params">(InputOutputArray img, Rect rec, <span class="keyword">const</span> Scalar&amp; color, <span class="keyword">int</span> thickness = <span class="number">1</span>, <span class="keyword">int</span> lineType = LINE_8, <span class="keyword">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>InputOutputArray img</td>
<td>要绘制的目标图像</td>
</tr>
<tr>
<td>Rect rec</td>
<td>rect类对象</td>
</tr>
<tr>
<td>const Scalar&amp; color</td>
<td>线条的颜色</td>
</tr>
<tr>
<td>int thickness = 1</td>
<td>正数表示线条宽度，-1表示填充矩形</td>
</tr>
<tr>
<td>int lineType = LINE_8</td>
<td>线条的类型</td>
</tr>
<tr>
<td>int shift = 0</td>
<td>坐标点的小数点位数</td>
</tr>
</tbody></table>
<p>绘制矩形的示例程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::drawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//绘制矩形</span></span><br><span class="line">	Rect rect;</span><br><span class="line">	rect.x = <span class="number">250</span>;	<span class="comment">//左上端点x坐标</span></span><br><span class="line">	rect.y = <span class="number">170</span>;	<span class="comment">//左上端点x坐标</span></span><br><span class="line">	rect.width = <span class="number">100</span>;	<span class="comment">//宽度</span></span><br><span class="line">	rect.height = <span class="number">100</span>;	<span class="comment">//高度</span></span><br><span class="line">	<span class="built_in">rectangle</span>(image, rect, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Drawing&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/img_convert/af671a2b45e802c3e63209fa87a96666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<h4 id="2-圆形"><a href="#2-圆形" class="headerlink" title="2. 圆形"></a>2. 圆形</h4><p>&emsp;&emsp;OpenCV中绘制圆形的函数为 <code>rectangle()</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::circle</span> <span class="params">(InputOutputArray img, Point center, <span class="keyword">int</span> radius, <span class="keyword">const</span> Scalar &amp;color, <span class="keyword">int</span> thickness=<span class="number">1</span>, <span class="keyword">int</span> lineType=LINE_8, <span class="keyword">int</span> shift=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>InputOutputArray img</td>
<td>要绘制的目标图像</td>
</tr>
<tr>
<td>Point center</td>
<td>圆心坐标</td>
</tr>
<tr>
<td>int radius</td>
<td>圆的半径</td>
</tr>
<tr>
<td>const Scalar &amp;color</td>
<td>圆的颜色</td>
</tr>
<tr>
<td>int thickness=1</td>
<td>正数表示线条宽度，-1表示填充圆</td>
</tr>
<tr>
<td>int lineType = LINE_8</td>
<td>线条的类型</td>
</tr>
<tr>
<td>int shift = 0</td>
<td>坐标点的小数点位数</td>
</tr>
</tbody></table>
<p>绘制圆形的示例程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::drawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//绘制圆</span></span><br><span class="line">	<span class="built_in">circle</span>(image, <span class="built_in">Point</span>(<span class="number">250</span>, <span class="number">170</span>), <span class="number">20</span>, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">-1</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Drawing&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/img_convert/952ed890a5696533968b9ba4c8e2377a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<p>&emsp;&emsp;</p>
<h4 id="3-直线"><a href="#3-直线" class="headerlink" title="3. 直线"></a>3. 直线</h4><p>&emsp;&emsp;OpenCV中绘制直线的函数为 <code>rectangle()</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::line</span><span class="params">(InputOutputArray img, Point pt1, Point pt2, <span class="keyword">const</span> Scalar &amp;color, <span class="keyword">int</span> thickness=<span class="number">1</span>, <span class="keyword">int</span> lineType=LINE_8, <span class="keyword">int</span> shift=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>InputOutputArray img</td>
<td>要绘制的目标图像</td>
</tr>
<tr>
<td>Point pt1r</td>
<td>端点1的坐标</td>
</tr>
<tr>
<td>Point pt2</td>
<td>端点2的坐标</td>
</tr>
<tr>
<td>const Scalar &amp;color</td>
<td>线条的颜色</td>
</tr>
<tr>
<td>int thickness=1</td>
<td>线条宽度</td>
</tr>
<tr>
<td>int lineType = LINE_8</td>
<td>线条的类型</td>
</tr>
<tr>
<td>int shift = 0</td>
<td>坐标点的小数点位数</td>
</tr>
</tbody></table>
<p>绘制圆形的示例程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::drawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//绘制直线</span></span><br><span class="line">	<span class="built_in">line</span>(image, <span class="built_in">Point</span>(<span class="number">250</span>, <span class="number">170</span>), <span class="built_in">Point</span>(<span class="number">350</span>, <span class="number">270</span>), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>, LINE_AA, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Drawing&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/img_convert/dacd9d0f6a5f9d67a50aee48aaed60a6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">
&emsp;&emsp;

<h4 id="4-椭圆"><a href="#4-椭圆" class="headerlink" title="4. 椭圆"></a>4. 椭圆</h4><p>&emsp;&emsp;OpenCV中绘制椭圆的函数为 <code>ellipse()</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ellipse</span><span class="params">(Mat&amp;img, <span class="keyword">const</span> RotatedRect&amp;box, <span class="keyword">const</span> Scalar&amp; color, <span class="keyword">int</span> thickness=<span class="number">1</span>, <span class="keyword">int</span> lineType=<span class="number">8</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Mat&amp;img</td>
<td>要绘制的目标图像</td>
</tr>
<tr>
<td>const RotatedRect&amp;box</td>
<td>椭圆类</td>
</tr>
<tr>
<td>const Scalar &amp;color</td>
<td>椭圆的颜色</td>
</tr>
<tr>
<td>int thickness=1</td>
<td>正数表示线条宽度，-1表示填充圆</td>
</tr>
<tr>
<td>int lineType = LINE_8</td>
<td>线条的类型</td>
</tr>
</tbody></table>
<blockquote>
<p>其中椭圆类RotatedRect的属性如下（示例）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;RotatedRect rrt;	<span class="comment">//创建对象</span></span><br><span class="line">&gt;rrt.center = <span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">200</span>);	<span class="comment">//椭圆中心点</span></span><br><span class="line">&gt;rrt.size = <span class="built_in">Size</span>(<span class="number">100</span>, <span class="number">200</span>);		<span class="comment">//椭圆大小（横轴，纵轴长度）</span></span><br><span class="line">&gt;rrt.angle = <span class="number">0</span>;		<span class="comment">//旋转角度</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>绘制圆形的示例程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::drawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//绘制椭圆</span></span><br><span class="line">	RotatedRect rrt;</span><br><span class="line">	rrt.center = <span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">	rrt.size = <span class="built_in">Size</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">	rrt.angle = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">ellipse</span>(image, rrt, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Drawing&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/img_convert/317de319b10cab926f53fa6a76bb1d00.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<p>&emsp;&emsp;</p>
<h2 id="二、多边形绘制方法"><a href="#二、多边形绘制方法" class="headerlink" title="二、多边形绘制方法"></a>二、多边形绘制方法</h2><p>&emsp;&emsp;多边形绘制的本质是定义一个由多个点组成的点集，以此连接点集中的各个点，从而形成多边形。</p>
<h4 id="2-1-多边形边框"><a href="#2-1-多边形边框" class="headerlink" title="2.1 多边形边框"></a>2.1 多边形边框</h4><p>&emsp;&emsp;绘制多边形的边框使用到的函数是 <code>ploylines()</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::polylines</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		InputOutputArray	img,</span></span></span><br><span class="line"><span class="params"><span class="function">		InputArrayOfArrays	pts,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">bool</span>	isClosed,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> Scalar &amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span>		thickness = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span>		lineType = LINE_8,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span>		shift = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>img</td>
<td>要绘制的目标图像</td>
</tr>
<tr>
<td>pts</td>
<td>提前构造的点集</td>
</tr>
<tr>
<td>isClosed</td>
<td>多边形是否是封闭图形</td>
</tr>
<tr>
<td>color</td>
<td>多边形边框的颜色</td>
</tr>
<tr>
<td>thickness</td>
<td>线条宽度（只能为正数）</td>
</tr>
<tr>
<td>lineType</td>
<td>线条的类型</td>
</tr>
<tr>
<td>shift</td>
<td>坐标点的小数点位数</td>
</tr>
</tbody></table>
<p>示例程序：绘制五边形</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::polyDrawing_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建画布</span></span><br><span class="line">	Mat bg = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建五个点，作为多边形五个顶点</span></span><br><span class="line">	<span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">350</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="function">Point <span class="title">p3</span><span class="params">(<span class="number">450</span>, <span class="number">300</span>)</span></span>;</span><br><span class="line">	<span class="function">Point <span class="title">p4</span><span class="params">(<span class="number">250</span>, <span class="number">450</span>)</span></span>;</span><br><span class="line">	<span class="function">Point <span class="title">p5</span><span class="params">(<span class="number">80</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将五个点依次添加到点集中</span></span><br><span class="line">	std::vector&lt;Point&gt; pts;</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绘制多边形边框</span></span><br><span class="line">	<span class="built_in">polylines</span>(bg, pts, <span class="literal">true</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">3</span>, LINE_AA, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Poly Drawing!&quot;</span>, bg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 <code>pts.push_back</code> 用于将点加入到点集数组中，用于不知道点集数量的情况。本程序已知共五个点，因此也可以使用如下的代码创建点集：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;Point&gt; <span class="title">pts</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">pts[<span class="number">0</span>] = p1;</span><br><span class="line">pts[<span class="number">1</span>] = p2;</span><br><span class="line">pts[<span class="number">2</span>] = p3;</span><br><span class="line">pts[<span class="number">3</span>] = p4;</span><br><span class="line">pts[<span class="number">4</span>] = p5;</span><br></pre></td></tr></table></figure>
</blockquote>
<img src="https://img-blog.csdnimg.cn/img_convert/c94a4045c4b42787be70c97ffb011795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<h4 id="2-2-多边形填充"><a href="#2-2-多边形填充" class="headerlink" title="2.2 多边形填充"></a>2.2 多边形填充</h4><p>&emsp;&emsp;绘制填充的多边形使用到的函数是 <code>fillPoly()</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::fillPoly</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		InputOutputArray	img,</span></span></span><br><span class="line"><span class="params"><span class="function">		InputArrayOfArrays	pts,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> Scalar &amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span>		lineType = LINE_8,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span>		shift = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>img</td>
<td>要绘制的目标图像</td>
</tr>
<tr>
<td>pts</td>
<td>提前构造的点集</td>
</tr>
<tr>
<td>color</td>
<td>多边形边框的颜色</td>
</tr>
<tr>
<td>lineType</td>
<td>线条的类型</td>
</tr>
<tr>
<td>shift</td>
<td>坐标点的小数点位数</td>
</tr>
</tbody></table>
<p>示例程序：绘制填充的五边形</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::polyDrawing_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建画布</span></span><br><span class="line">	Mat bg = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建五个点，作为多边形五个顶点</span></span><br><span class="line">	<span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">350</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="function">Point <span class="title">p3</span><span class="params">(<span class="number">450</span>, <span class="number">300</span>)</span></span>;</span><br><span class="line">	<span class="function">Point <span class="title">p4</span><span class="params">(<span class="number">250</span>, <span class="number">450</span>)</span></span>;</span><br><span class="line">	<span class="function">Point <span class="title">p5</span><span class="params">(<span class="number">80</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将五个点依次添加到点集中</span></span><br><span class="line">	std::vector&lt;Point&gt; pts;</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绘制封闭的五边形</span></span><br><span class="line">	<span class="built_in">fillPoly</span>(bg, pts, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Poly Drawing!&quot;</span>, bg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/img_convert/66c1611508015c694e917fda36d19db9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<h4 id="2-3-绘制多个多边形"><a href="#2-3-绘制多个多边形" class="headerlink" title="2.3 绘制多个多边形"></a>2.3 绘制多个多边形</h4><p>&emsp;&emsp;绘制多个多边形使用到的函数是 <code>drawContours()</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawContours</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	InputOutputArray 	image,</span></span></span><br><span class="line"><span class="params"><span class="function">	InputArrayOfArrays 	contours,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 	contourIdx,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> Scalar&amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 	thickness=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 	lineType=<span class="number">8</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	InputArray 	hierarchy=noArray(),</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 		maxLevel=INT_MAX,</span></span></span><br><span class="line"><span class="params"><span class="function">	Point 		offset=Point() )</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>img</td>
<td>要绘制的目标图像</td>
</tr>
<tr>
<td>contours</td>
<td>输入的轮廓组，每一组轮廓由点vector构成</td>
</tr>
<tr>
<td>contourIdx</td>
<td>画第几个轮廓，如果该参数为负值，则画全部轮廓</td>
</tr>
<tr>
<td>color</td>
<td>线条的颜色</td>
</tr>
<tr>
<td>thickness</td>
<td>线条宽度，负值或CV_FILLED表示填充轮廓内部</td>
</tr>
<tr>
<td>lineType</td>
<td>线条的类型</td>
</tr>
</tbody></table>
<p>示例程序：绘制一个五边形</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::polyDrawing_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建画布</span></span><br><span class="line">	Mat bg = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建五个点，作为多边形五个顶点</span></span><br><span class="line">	<span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">350</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="function">Point <span class="title">p3</span><span class="params">(<span class="number">450</span>, <span class="number">300</span>)</span></span>;</span><br><span class="line">	<span class="function">Point <span class="title">p4</span><span class="params">(<span class="number">250</span>, <span class="number">450</span>)</span></span>;</span><br><span class="line">	<span class="function">Point <span class="title">p5</span><span class="params">(<span class="number">80</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将五个点依次添加到点集中</span></span><br><span class="line">	std::vector&lt;Point&gt; pts;</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	pts.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加点集到contours</span></span><br><span class="line">	<span class="comment">//（相当于contours是点集的集合）</span></span><br><span class="line">	std::vector&lt;std::vector&lt;Point&gt;&gt; contours;</span><br><span class="line">	contours.<span class="built_in">push_back</span>(pts);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绘制多边形</span></span><br><span class="line">	<span class="built_in">drawContours</span>(bg, contours, <span class="number">-1</span>, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Poly Drawing!&quot;</span>, bg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/img_convert/141a149f6cc64488d35f2a2cf4f7316b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】随机数的使用与随机线条的生成</title>
    <url>/2021/07/23/104-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9A%8F%E6%9C%BA%E7%BA%BF%E6%9D%A1%E7%9A%84%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h2 id="一、随机数的使用方法"><a href="#一、随机数的使用方法" class="headerlink" title="一、随机数的使用方法"></a>一、随机数的使用方法</h2><p>&emsp;&emsp;C和C++中提供了 <code>rand()</code> 和 <code>srand()</code> 函数用于产生随机数，使用C++编写OpenCV代码时也可以使用。同时OpenCV自身也提供了生成随机数的类RNG，使用起来也十分方便，以下主要介绍RNG类的使用方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RNG类对象的创建</span></span><br><span class="line"> <span class="function">RNG <span class="title">rng</span><span class="params">(<span class="keyword">int</span> seed)</span></span>;	<span class="comment">//使用种子seed产生一个RNG类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//产生一个在区间[a,b)的均匀分布的整数随机数</span></span><br><span class="line"><span class="keyword">int</span> x = rng.<span class="built_in">uniform</span>(a, b);</span><br><span class="line"><span class="comment">//产生一个在区间[0,1)的均匀分布的浮点随机数</span></span><br><span class="line"><span class="keyword">int</span> x = rng.<span class="built_in">uniform</span>(<span class="number">0.f</span>,<span class="number">1.f</span>);</span><br><span class="line"><span class="comment">//产生一个均值为0，标准差为2的高斯分布的随机数</span></span><br><span class="line"><span class="keyword">int</span> x = rng.<span class="built_in">gaussian</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="二、生成随机线条示例程序"><a href="#二、生成随机线条示例程序" class="headerlink" title="二、生成随机线条示例程序"></a>二、生成随机线条示例程序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::random_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Mat bg = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);	<span class="comment">//创建背景</span></span><br><span class="line">	<span class="keyword">int</span> width = bg.cols;</span><br><span class="line">	<span class="keyword">int</span> height = bg.rows;</span><br><span class="line">	<span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">666</span>)</span></span>;	<span class="comment">//种子随意设置</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">//等待按键按下，同时限制两线条生成间隔实现</span></span><br><span class="line">		<span class="keyword">char</span> k = <span class="built_in">waitKey</span>(<span class="number">100</span>);</span><br><span class="line">		<span class="keyword">if</span>(k == <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> x1 = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, width);</span><br><span class="line">		<span class="keyword">int</span> y1 = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, height);</span><br><span class="line">		<span class="keyword">int</span> x2 = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, width);</span><br><span class="line">		<span class="keyword">int</span> y2 = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, height);</span><br><span class="line">		<span class="keyword">int</span> b = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">		<span class="keyword">int</span> g = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">		<span class="keyword">int</span> r = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">line</span>(bg, <span class="built_in">Point</span>(x1, y1), <span class="built_in">Point</span>(x2, y2), <span class="built_in">Scalar</span>(b, g, r), <span class="number">1</span>, LINE_AA, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Randow image&quot;</span>, bg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/img_convert/805c15894954a39e81d5e8e019646617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="50%">]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】在OpenCV中响应键盘与鼠标操作</title>
    <url>/2021/07/24/105-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91%E5%9C%A8OpenCV%E4%B8%AD%E5%93%8D%E5%BA%94%E9%94%AE%E7%9B%98%E4%B8%8E%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="一、键盘的响应"><a href="#一、键盘的响应" class="headerlink" title="一、键盘的响应"></a>一、键盘的响应</h2><h4 id="1-1-基本知识"><a href="#1-1-基本知识" class="headerlink" title="1.1 基本知识"></a>1.1 基本知识</h4><p>&emsp;&emsp;按键的读取只需要使用waitKey()函数就可以实现，十分简单。<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> waitKey（<span class="keyword">int</span> delay=<span class="number">0</span>）</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;**函数参数为延时时间(ms)**。<br>&emsp;&emsp;delay&lt;=0时，等待时间无限长，按下按键时函数结束，**返回按键的键值**。·<br>&emsp;&emsp;delay&gt;0时，等待delay毫秒按键响应，等待时间结束仍未按下按键则返回-1。</p>
<blockquote>
<p> 本人opencv4+vs2019实操时，没有按键时不返回值，有按键按下时返回对应键值。</p>
</blockquote>
<h4 id="1-2-确定按键响应值"><a href="#1-2-确定按键响应值" class="headerlink" title="1.2 确定按键响应值"></a>1.2 确定按键响应值</h4><p>&emsp;&emsp;使用如下代码，可以测试自己的键盘对应的键值是多少。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::key_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">char</span> k = <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">		std::cout &lt;&lt; k &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210719114312504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="30%">

<h4 id="1-3-按键调节亮度"><a href="#1-3-按键调节亮度" class="headerlink" title="1.3 按键调节亮度"></a>1.3 按键调节亮度</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*按下1时：图片亮度增大</span></span><br><span class="line"><span class="comment">按下2时，图片亮度减小</span></span><br><span class="line"><span class="comment">按下q时，程序退出*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::key_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	Mat m = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(),image.<span class="built_in">type</span>());</span><br><span class="line">	m = <span class="built_in">Scalar</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);	<span class="comment">//增大或减小图片亮度的变化量</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">char</span> k = <span class="built_in">waitKey</span>(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;	<span class="comment">// Quit</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="string">&#x27;1&#x27;</span>) &#123;	<span class="comment">//Key 1</span></span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;You enter key 1 - Lightness Up.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			<span class="built_in">add</span>(image, m, image);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="string">&#x27;2&#x27;</span>) &#123;	<span class="comment">//Key 2</span></span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;You enter key 2 - Lightness Down.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			<span class="built_in">subtract</span>(image, m, image);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Key&quot;</span>, image);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、鼠标的响应"><a href="#二、鼠标的响应" class="headerlink" title="二、鼠标的响应"></a>二、鼠标的响应</h2><h4 id="1-1-基本知识-1"><a href="#1-1-基本知识-1" class="headerlink" title="1.1 基本知识"></a>1.1 基本知识</h4><p>&emsp;&emsp;鼠标响应所使用的函数主要是 <code>setMouseCallback()</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMousecallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> string&amp; 	winname,	<span class="comment">//窗口的名字</span></span></span></span><br><span class="line"><span class="params"><span class="function"> MouseCallback 	onMouse,	<span class="comment">//鼠标响应回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">void</span>* 			userdata=<span class="number">0</span>	<span class="comment">//传给回调函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>


<p>&emsp;&emsp;其中onMouse响应回调函数函数，作用为指定窗口里每次鼠标时间发生的时候，被调用的函数指针。 这个函数的原型应该为的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_Mouse</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 	event,		<span class="comment">//事件回传代号</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 	x,			<span class="comment">//鼠标指针在图像坐标系的坐标x</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span>		y,			<span class="comment">//鼠标指针在图像坐标系的坐标y</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 	flags,		<span class="comment">//CV_EVENT_FLAG的组合</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">void</span>* 	userdata	<span class="comment">//传递的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>Event</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>EVENT_MOUSEMOVE</td>
<td>滑动</td>
</tr>
<tr>
<td>EVENT_LBUTTONDOWN</td>
<td>左键点击</td>
</tr>
<tr>
<td>EVENT_RBUTTONDOWN</td>
<td>右键点击</td>
</tr>
<tr>
<td>EVENT_MBUTTONDOWN</td>
<td>中键点击</td>
</tr>
<tr>
<td>EVENT_LBUTTONUP</td>
<td>左键放开</td>
</tr>
<tr>
<td>EVENT_RBUTTONUP</td>
<td>右键放开</td>
</tr>
<tr>
<td>EVENT_MBUTTONUP</td>
<td>中键放开</td>
</tr>
<tr>
<td>EVENT_LBUTTONDBLCLK</td>
<td>左键双击</td>
</tr>
<tr>
<td>EVENT_RBUTTONDBLCLK</td>
<td>右键双击</td>
</tr>
<tr>
<td>EVENT_MBUTTONDBLCLK</td>
<td>中键双击</td>
</tr>
</tbody></table>
<h4 id="1-2-示例程序"><a href="#1-2-示例程序" class="headerlink" title="1.2 示例程序"></a>1.2 示例程序</h4><p>&emsp;&emsp;在图像上实现拖动绘制矩形的画板功能。<br><img src="https://img-blog.csdnimg.cn/2ffd5983a84e4e63be6282943a5184b6.png" alt="请添加图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">sp</span><span class="params">(<span class="number">-1</span>, <span class="number">-1</span>)</span></span>;	<span class="comment">//起始点（初始值-1，-1）</span></span><br><span class="line"><span class="function">Point <span class="title">ep</span><span class="params">(<span class="number">-1</span>, <span class="number">-1</span>)</span></span>;	<span class="comment">//结束点（初始值-1，-1）</span></span><br><span class="line">Mat temp;			<span class="comment">//原图的克隆，用于实时刷新图片</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">on_draw</span><span class="params">(<span class="keyword">int</span> event, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> flags, <span class="keyword">void</span>* userdata)</span> </span>&#123;</span><br><span class="line">	Mat bg = *(Mat*)userdata;	<span class="comment">//回调函数传过来的图像数据</span></span><br><span class="line">	<span class="keyword">if</span> (event == EVENT_LBUTTONDOWN) &#123;	<span class="comment">//如果左键被按下</span></span><br><span class="line">		sp.x = x;	<span class="comment">//保存左键按下时的xy值</span></span><br><span class="line">		sp.y = y;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Start point: &quot;</span> &lt;&lt; sp &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (event == EVENT_LBUTTONUP) &#123;<span class="comment">//如果左键被抬起</span></span><br><span class="line">		ep.x = x;	<span class="comment">//保存左键抬起时的xy值</span></span><br><span class="line">		ep.y = y;</span><br><span class="line">		<span class="keyword">int</span> dx = ep.x - sp.x;	<span class="comment">//计算矩形长宽</span></span><br><span class="line">		<span class="keyword">int</span> dy = ep.y - sp.y;</span><br><span class="line">		<span class="keyword">if</span> (dx &gt; <span class="number">0</span> &amp;&amp; dy &gt; <span class="number">0</span>) &#123;	<span class="comment">//当矩形长宽都为正数时</span></span><br><span class="line">			<span class="function">Rect <span class="title">box</span><span class="params">(sp.x, sp.y, dx, dy)</span></span>;</span><br><span class="line">			<span class="built_in">rectangle</span>(bg, box, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);	<span class="comment">//绘制矩形</span></span><br><span class="line">			<span class="built_in">imshow</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, bg);</span><br><span class="line">			<span class="built_in">imshow</span>(<span class="string">&quot;ROI&quot;</span>, <span class="built_in">temp</span>(box));	<span class="comment">//显示ROI区域（被框选的区域）</span></span><br><span class="line">			sp.x = <span class="number">-1</span>;	<span class="comment">//起始点坐标复位</span></span><br><span class="line">			sp.y = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (event == EVENT_MOUSEMOVE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp.x &gt; <span class="number">0</span> &amp;&amp; sp.y &gt; <span class="number">0</span>) &#123;		<span class="comment">//当起始点坐标不是初始值，且鼠标移动时</span></span><br><span class="line">			ep.x = x;</span><br><span class="line">			ep.y = y;</span><br><span class="line">			<span class="keyword">int</span> dx = ep.x - sp.x;</span><br><span class="line">			<span class="keyword">int</span> dy = ep.y - sp.y;</span><br><span class="line">			<span class="keyword">if</span> (dx &gt; <span class="number">0</span> &amp;&amp; dy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="function">Rect <span class="title">box</span><span class="params">(sp.x, sp.y, dx, dy)</span></span>;</span><br><span class="line">				temp.<span class="built_in">copyTo</span>(bg);	<span class="comment">//刷新屏幕，清除上一循环绘制的矩形</span></span><br><span class="line">				<span class="built_in">rectangle</span>(bg, box, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);	<span class="comment">//绘制新矩形</span></span><br><span class="line">				<span class="built_in">imshow</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, bg);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::mouseDrawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">namedWindow</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, WINDOW_AUTOSIZE);	<span class="comment">//创建一个窗口</span></span><br><span class="line">	<span class="built_in">setMouseCallback</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, on_draw,(<span class="keyword">void</span>*)(&amp;image));	<span class="comment">//调用鼠标回调函数</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, image);</span><br><span class="line">	temp = image.<span class="built_in">clone</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】图像像素数据类型的转换与归一</title>
    <url>/2021/07/25/106-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91%E5%9B%BE%E5%83%8F%E5%83%8F%E7%B4%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%BD%92%E4%B8%80/</url>
    <content><![CDATA[<h2 id="一、什么是归一化"><a href="#一、什么是归一化" class="headerlink" title="一、什么是归一化"></a>一、什么是归一化</h2><p>&emsp;&emsp;归一化就是要把需要处理的数据经过处理后（通过某种算法）限制在一定范围的之内。为了后面数据处理的方便，其次是保证程序运行时收敛加快。<br>&emsp;&emsp;归一化的目的，是使得没有可比性的数据变得具有可比性，同时又保持相比较的两个数据之间的相对关系，如大小关系；或是为了作图，原来很难在一张图上作出来，归一化后就可以很方便的给出图上的相对位置等。</p>
<h2 id="二、归一化的方式"><a href="#二、归一化的方式" class="headerlink" title="二、归一化的方式"></a>二、归一化的方式</h2><h4 id="2-1-基本API"><a href="#2-1-基本API" class="headerlink" title="2.1 基本API"></a>2.1 基本API</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalize</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	InputArray 			src,</span></span></span><br><span class="line"><span class="params"><span class="function">	InputOutputArray 	dst, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">double</span> 		alpha = <span class="number">1</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">double</span> 		beta = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 		norm_type = NORM_L2, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 		dtype = <span class="number">-1</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">	InputArray 			mask = noArray()</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>输入数组</td>
</tr>
<tr>
<td>dst</td>
<td>输出数组</td>
</tr>
<tr>
<td>alpha</td>
<td>归一化最小值</td>
</tr>
<tr>
<td>beta</td>
<td>归一化最大值</td>
</tr>
<tr>
<td>norm_type</td>
<td>归一化的类型</td>
</tr>
<tr>
<td>dtype</td>
<td>负数时输出数组的type与输入数组的type相同</td>
</tr>
<tr>
<td>mask</td>
<td>指示函数是否仅仅对指定的元素进行操作</td>
</tr>
</tbody></table>
<p>其中norm_type有以下几种类型：</p>
<ul>
<li>NORM_MINMAX:数组的数值被平移或缩放到一个指定的范围，线性归一化，一般较常用。</li>
<li>NORM_INF:此类型的定义没有查到，根据OpenCV 1的对应项，可能是归一化数组的C-范数(绝对值的最大值)</li>
<li>NORM_L1 :  归一化数组的L1-范数(绝对值的和)</li>
<li>NORM_L2: 归一化数组的(欧几里德)L2-范数</li>
</ul>
<h4 id="2-2-示例程序"><a href="#2-2-示例程序" class="headerlink" title="2.2 示例程序"></a>2.2 示例程序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::normalize_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	Mat dst;</span><br><span class="line">	std::cout &lt;&lt; image.<span class="built_in">type</span>() &lt;&lt; std::endl;	<span class="comment">//CV_8UC3</span></span><br><span class="line">	image.<span class="built_in">convertTo</span>(image, CV_32F);			<span class="comment">//像素数据转换为浮点数数据</span></span><br><span class="line">	std::cout &lt;&lt; image.<span class="built_in">type</span>() &lt;&lt; std::endl;	<span class="comment">//CV_32FC3</span></span><br><span class="line">	<span class="built_in">normalize</span>(image, dst, <span class="number">0</span>, <span class="number">1.0</span>, NORM_MINMAX);	<span class="comment">//归一化</span></span><br><span class="line">	std::cout &lt;&lt; dst.<span class="built_in">type</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Normalize&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】图像变换方法总结（放缩、翻转、旋转）</title>
    <url>/2021/07/26/107-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88%E6%94%BE%E7%BC%A9%E3%80%81%E7%BF%BB%E8%BD%AC%E3%80%81%E6%97%8B%E8%BD%AC%EF%BC%89/</url>
    <content><![CDATA[<p>@<a href="%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2%E6%96%B9%E6%B3%95">TOC</a></p>
<h3 id="一、图像放缩Resize"><a href="#一、图像放缩Resize" class="headerlink" title="一、图像放缩Resize"></a>一、图像放缩Resize</h3><p><strong>1.1 基本知识</strong><br>&emsp;&emsp;图像放缩用到了许多插值方法，常见的差值算法有线性插值、立方差值、双立方差值、采样放缩算法等等。<br>&emsp;&emsp;所使用的API为 <code>resize()</code>，函数的定义如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,	<span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray dst,<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">Size dsize,		<span class="comment">//输出尺寸</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">double</span> fx=<span class="number">0</span>,	<span class="comment">//水平缩放比例</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">double</span> fy=<span class="number">0</span>,	<span class="comment">//垂直缩放比例</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> interpolation=INTER_LINEAR	<span class="comment">//插值方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>其中dsize为0时，fx和fy均不可为零；fx和fy为0时，输出图像按dsize输出</li>
<li>interpolation内插方式有以下四种：<ul>
<li>CV_INTER_NEAREST&emsp;&emsp;最邻近插值点法</li>
<li>CV_INTER_LINEAR&emsp;&emsp;&emsp;双线性插值法</li>
<li>CV_INTER_AREA&emsp;&emsp;&emsp;&emsp;邻域像素再取样插补</li>
<li>CV_INTER_CUBIC &emsp;&emsp;&emsp; 双立方插补，4*4大小的补点</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>1.2 示例程序</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::resize_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	Mat zoomin, zoomout;	<span class="comment">//定义输出图像</span></span><br><span class="line">	<span class="keyword">int</span> h = image.rows;		<span class="comment">//获取原图像的宽高</span></span><br><span class="line">	<span class="keyword">int</span> w = image.cols;</span><br><span class="line">	<span class="built_in">resize</span>(image, zoomin, <span class="built_in">Size</span>(w * <span class="number">1.5</span>, h * <span class="number">1.5</span>), <span class="number">0</span>, <span class="number">0</span>, INTER_LINEAR);	<span class="comment">//图像放大1.5倍</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;zoomin&quot;</span>, zoomin);</span><br><span class="line">	<span class="built_in">resize</span>(image, zoomout, <span class="built_in">Size</span>(w / <span class="number">2</span>, h / <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, INTER_LINEAR);		<span class="comment">//图像缩小2倍</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;zoomout&quot;</span>, zoomout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/987f0cfaee9847d4bf0412faea421bd4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<h3 id="二、图像翻转flip"><a href="#二、图像翻转flip" class="headerlink" title="二、图像翻转flip"></a>二、图像翻转flip</h3><p>&emsp;&emsp;图像反转就是将图像左右或上下反转镜像。所用到的函数是 <code>flip()</code>，函数的定义如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::flip</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	cv::InputArray 	src, 			<span class="comment">// 输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">	cv::OutputArray dst, 			<span class="comment">// 输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 			flipCode = <span class="number">0</span>	<span class="comment">// &gt;0: 沿y轴翻转, 0: 沿x轴翻转, &lt;0: x、y轴同时翻转</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>测试程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::flip_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	Mat dst;</span><br><span class="line">	<span class="built_in">flip</span>(image, dst, <span class="number">0</span>);	<span class="comment">//上下翻转</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;上下翻转&quot;</span>, dst);</span><br><span class="line">	<span class="built_in">flip</span>(image, dst, <span class="number">1</span>);	<span class="comment">//左右翻转</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;左右翻转&quot;</span>, dst);</span><br><span class="line">	<span class="built_in">flip</span>(image, dst, <span class="number">-1</span>);	<span class="comment">//对角线翻转（180°旋转）</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;对角线翻转（180°旋转）&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<img src="https://img-blog.csdnimg.cn/e2029c4ad3e244ff9e66bb31c5754475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<h3 id="三、图像旋转warpAffine"><a href="#三、图像旋转warpAffine" class="headerlink" title="三、图像旋转warpAffine"></a>三、图像旋转warpAffine</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::warpAffine</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	InputArray 		src,	<span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">	OutputArray 	dst,	<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">	InputArray 		M,		<span class="comment">//变换矩阵</span></span></span></span><br><span class="line"><span class="params"><span class="function">	Size			dsize,	<span class="comment">//输出图像大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span>				flags = INTER_LINEAR,			<span class="comment">//插值方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 			borderMode = BORDER_CONSTANT,	<span class="comment">//图像边缘像素模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> Scalar&amp;	borderValue = Scalar()			<span class="comment">//边界填充值</span></span></span></span><br></pre></td></tr></table></figure>

<p>其中M变换矩阵可以通过如下函数获得，旋转矩阵的形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">M=cv2.<span class="built_in">getRotationMatrix2D</span>(center, angle, scale)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/ba9cdfa1a2fa47bc8b00d41066f6a368.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/89c181d9f82540a2825e2d83307fd13e.png" alt="在这里插入图片描述"></p>
<p>由于旋转之后，图像的大小会发生变化，因此需要重新计算图像的长宽，计算方法可以参考下图：</p>
<img src="https://img-blog.csdnimg.cn/8f4af030a0e84267b032af302d0f8f5b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<p>图像旋转的示例程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::rotate_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	Mat dst, M;</span><br><span class="line">	<span class="keyword">int</span> h = image.rows;</span><br><span class="line">	<span class="keyword">int</span> w = image.cols;</span><br><span class="line">	M = <span class="built_in">getRotationMatrix2D</span>(<span class="built_in">Point2f</span>(w / <span class="number">2</span>, h / <span class="number">2</span>), <span class="number">45</span>, <span class="number">1.0</span>);	<span class="comment">//定义变换矩阵M</span></span><br><span class="line">	<span class="keyword">double</span> cos = <span class="built_in">abs</span>(M.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>));	<span class="comment">//求cos值</span></span><br><span class="line">	<span class="keyword">double</span> sin = <span class="built_in">abs</span>(M.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>));	<span class="comment">//求sin值</span></span><br><span class="line">	<span class="keyword">int</span> nw = cos * w + sin * h;		<span class="comment">//计算新的长、宽</span></span><br><span class="line">	<span class="keyword">int</span> nh = sin * w + cos * h;</span><br><span class="line">	M.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>) += (nw / <span class="number">2</span> - w / <span class="number">2</span>);		<span class="comment">//计算新的中心</span></span><br><span class="line">	M.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>) += (nh / <span class="number">2</span> - h / <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">warpAffine</span>(image, dst, M, <span class="built_in">Size</span>(nw,nh), INTER_LINEAR,<span class="number">0</span>,<span class="built_in">Scalar</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Rotation&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/e5971bef2056432e84b36bc93d34cb08.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】摄像头视频的读取与存储</title>
    <url>/2021/07/27/108-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91%E6%91%84%E5%83%8F%E5%A4%B4%E8%A7%86%E9%A2%91%E7%9A%84%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h3 id="1-如何读取摄像头"><a href="#1-如何读取摄像头" class="headerlink" title="1. 如何读取摄像头"></a>1. 如何读取摄像头</h3><p>&emsp;&emsp;在图像处理中，读取视频并进行处理是必不可少的操作，在OpenCV中，读取摄像头的视频所用到的主要函数为 <code>capture()</code>。<br>&emsp;&emsp;①VideoCapture类的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">VideoCapture::<span class="built_in">VideoCapture</span>()</span><br><span class="line">VideoCapture::<span class="built_in">VideoCapture</span>(<span class="keyword">const</span> string&amp; filename)</span><br><span class="line">VideoCapture::<span class="built_in">VideoCapture</span>(<span class="keyword">int</span> device)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;②读取摄像头视频的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">VideoCapture&amp; capture.<span class="built_in">read</span>(Mat&amp; image)</span><br></pre></td></tr></table></figure>
<p>此函数用于捕获视频的每一帧，并返回刚刚捕获的帧如果没有视频帧被捕获，返回false。<br>&emsp;&emsp;<br>&emsp;&emsp;读取摄像头视频的示例程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::video_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	<span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;	<span class="comment">//创建VideoCapture类</span></span><br><span class="line">	Mat frame;					<span class="comment">//定义Mat对象用于存储每一帧数据</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		capture.<span class="built_in">read</span>(frame);	<span class="comment">//逐帧读取视频</span></span><br><span class="line">		<span class="built_in">flip</span>(frame, frame, <span class="number">1</span>);	<span class="comment">//将读取的视频左右反转</span></span><br><span class="line">		<span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;	<span class="comment">//如果视频结束或未检测到摄像头则跳出循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Video&quot;</span>, frame);	<span class="comment">//每次循环显示一帧图像</span></span><br><span class="line">		<span class="keyword">char</span> k = <span class="built_in">waitKey</span>(<span class="number">10</span>);	<span class="comment">//两帧读取的间隔时间</span></span><br><span class="line">		<span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;			<span class="comment">//按下q键退出循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	capture.<span class="built_in">release</span>();			<span class="comment">//释放视频</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-视频的存储"><a href="#2-视频的存储" class="headerlink" title="2. 视频的存储"></a>2. 视频的存储</h3><p>&emsp;&emsp;视频的存储所用到的是 <code>VideoWriter </code> 类。所使用到的类属性和方法如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> string&amp; 	filename,		<span class="comment">//文件路径</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 			fourcc,			<span class="comment">//四个字符用来表示压缩帧的codec</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">double</span> 			fps,			<span class="comment">//被创建视频流的帧率</span></span></span></span><br><span class="line"><span class="params"><span class="function">	Size 			frameSize,		<span class="comment">//视频流的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">bool</span> 			isColor=<span class="literal">true</span>	<span class="comment">//True则每一帧为彩色图，否则为灰度图</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中fourcc编码格式可选参数如下：<br>| 参数                          | 编码格式             |<br>| —————————– | ——————– |<br>| CV_FOURCC(‘P’,’I’,’M’,’1’)    | MPEG-1               |<br>| CV_FOURCC(‘M’,’J’,’P’,’G’)    | motion-jpeg          |<br>| CV_FOURCC(‘M’, ‘P’, ‘4’, ‘2’) | MPEG-4.2             |<br>| CV_FOURCC(‘D’, ‘I’, ‘V’, ‘3’) | MPEG-4.3             |<br>| CV_FOURCC(‘D’, ‘I’, ‘V’, ‘X’) | MPEG-4               |<br>| CV_FOURCC(‘U’, ‘2’, ‘6’, ‘3’) | H263                 |<br>| CV_FOURCC(‘I’, ‘2’, ‘6’, ‘3’) | H263I                |<br>| CV_FOURCC(‘F’, ‘L’, ‘V’, ‘1’) | FLV1                 |<br>| -1                            | 弹出一个编码器选择框 |</p>
<p>保存摄像头视频的程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::video_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	<span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;	<span class="comment">//创建VideoCapture类</span></span><br><span class="line">	<span class="keyword">int</span> frame_width = capture.<span class="built_in">get</span>(CAP_PROP_FRAME_WIDTH);	<span class="comment">//获取摄像头的宽、高</span></span><br><span class="line">	<span class="keyword">int</span> frame_height = capture.<span class="built_in">get</span>(CAP_PROP_FRAME_HEIGHT);</span><br><span class="line"></span><br><span class="line">	VideoWriter writer;		<span class="comment">//创建VideoWriter类</span></span><br><span class="line">	<span class="keyword">int</span> fourcc = writer.<span class="built_in">fourcc</span>(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;X&#x27;</span>);	<span class="comment">//定义编码格式</span></span><br><span class="line">	writer.<span class="built_in">open</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/test.mp4&quot;</span>, fourcc, <span class="number">30</span>, <span class="built_in">Size</span>(frame_width, frame_height), <span class="literal">true</span>);	<span class="comment">//保存视频</span></span><br><span class="line"></span><br><span class="line">	Mat frame;					<span class="comment">//定义Mat对象用于存储每一帧数据</span></span><br><span class="line">	<span class="keyword">while</span> (capture.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">		capture.<span class="built_in">read</span>(frame);	<span class="comment">//逐帧读取视频</span></span><br><span class="line">		<span class="built_in">flip</span>(frame, frame, <span class="number">1</span>);	<span class="comment">//将读取的视频左右反转</span></span><br><span class="line">		<span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;	<span class="comment">//如果视频结束或未检测到摄像头则跳出循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		writer.<span class="built_in">write</span>(frame);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Video&quot;</span>, frame);	<span class="comment">//每次循环显示一帧图像</span></span><br><span class="line">		<span class="keyword">char</span> k = <span class="built_in">waitKey</span>(<span class="number">33</span>);	<span class="comment">//两帧读取的间隔时间 1s/30fps=33ms</span></span><br><span class="line">		<span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;			<span class="comment">//按下q键退出循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	capture.<span class="built_in">release</span>();			<span class="comment">//释放视频</span></span><br><span class="line">	writer.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/a3349cf9127b4d868dd88fb5aa30cc56.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】什么是图像的直方图？如何获取直方图？</title>
    <url>/2021/08/12/109-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE%E5%83%8F%E7%9A%84%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%9F%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="一、什么是图像直方图"><a href="#一、什么是图像直方图" class="headerlink" title="一、什么是图像直方图"></a>一、什么是图像直方图</h2><p>&emsp;&emsp;图像直方图是图像像素值的统计学特征、计算代价较小，具有图像平移、旋转、缩放不变性等众多优点，广泛地应用于图像处理的各个领域，特别是灰度图像的阈值分割、基于颜色的图像检索以及图像分类、反向投影跟踪。常见的分为灰度直方图和颜色直方图。</p>
<p>&emsp;&emsp;简单来说，图像对计算机来说就是一个一个像素点的数值，像素值又有一定的取值范围，所以我们可以统计出来这些像素值出现的频率，统计结果就是一个直方图。</p>
<p>&emsp;&emsp;对图像进行平移、旋转等操作后，图像的直方图信息不会变化。因此即使两张图像的直方图完全一样，图像有可能不是同一个图像。</p>
<h2 id="二、如何计算图像直方图"><a href="#二、如何计算图像直方图" class="headerlink" title="二、如何计算图像直方图"></a>二、如何计算图像直方图</h2><p>OpenCV中提供了如下的函数用于计算图像的直方图：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcHist</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> Mat* 		images,			<span class="comment">//源图像组</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span> 			nimages,		<span class="comment">//源图像组图像个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> <span class="keyword">int</span>* 		channels,		<span class="comment">//图像信道</span></span></span></span><br><span class="line"><span class="params"><span class="function">		InputArray 		mask,			<span class="comment">//可选的掩码，如果不为空，则必须是8-bit数组，而且大小和原图像相同</span></span></span></span><br><span class="line"><span class="params"><span class="function">		OutputArray 	hist,			<span class="comment">//输出直方图数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span> 			dims,			<span class="comment">//处理直方图的维数正数</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> <span class="keyword">int</span>* 		histSize,		<span class="comment">//每一维的直方图的尺寸大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> <span class="keyword">float</span>** 	ranges,			<span class="comment">//直方图每一维的数据大小范围</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">bool</span> 			uniform=<span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">bool</span>		 	accumulate=<span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>示例程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::histShow_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 三通道分离，用于分别绘制三个通道的直方图</span></span><br><span class="line">	std::vector&lt;Mat&gt; bgr_plane;</span><br><span class="line">	<span class="built_in">split</span>(image, bgr_plane);</span><br><span class="line">	<span class="comment">// 定义参数变量</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> channels[<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> bins[<span class="number">1</span>] = &#123; <span class="number">256</span> &#125;;</span><br><span class="line">	<span class="keyword">float</span> hranges[<span class="number">2</span>] = &#123; <span class="number">0</span>,<span class="number">255</span> &#125;;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span>* ranges[<span class="number">1</span>] = &#123; hranges &#125;;</span><br><span class="line">	Mat b_hist;</span><br><span class="line">	Mat g_hist;</span><br><span class="line">	Mat r_hist;</span><br><span class="line">	<span class="comment">// 计算Blue, Green, Red通道的直方图</span></span><br><span class="line">	<span class="built_in">calcHist</span>(&amp;bgr_plane[<span class="number">0</span>], <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Mat</span>(), b_hist, <span class="number">1</span>, bins, ranges);</span><br><span class="line">	<span class="built_in">calcHist</span>(&amp;bgr_plane[<span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Mat</span>(), g_hist, <span class="number">1</span>, bins, ranges);</span><br><span class="line">	<span class="built_in">calcHist</span>(&amp;bgr_plane[<span class="number">2</span>], <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Mat</span>(), r_hist, <span class="number">1</span>, bins, ranges);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示直方图</span></span><br><span class="line">	<span class="keyword">int</span> hist_w = <span class="number">512</span>;</span><br><span class="line">	<span class="keyword">int</span> hist_h = <span class="number">400</span>;</span><br><span class="line">	<span class="keyword">int</span> bin_w = <span class="built_in">cvRound</span>((<span class="keyword">double</span>)hist_w / bins[<span class="number">0</span>]);</span><br><span class="line">	Mat histImage = Mat::<span class="built_in">zeros</span>(hist_h, hist_w, CV_8UC3);</span><br><span class="line">	<span class="comment">// 归一化直方图数据</span></span><br><span class="line">	<span class="built_in">normalize</span>(b_hist, b_hist, <span class="number">0</span>, histImage.rows, NORM_MINMAX, <span class="number">-1</span>, <span class="built_in">Mat</span>());</span><br><span class="line">	<span class="built_in">normalize</span>(g_hist, g_hist, <span class="number">0</span>, histImage.rows, NORM_MINMAX, <span class="number">-1</span>, <span class="built_in">Mat</span>());</span><br><span class="line">	<span class="built_in">normalize</span>(r_hist, r_hist, <span class="number">0</span>, histImage.rows, NORM_MINMAX, <span class="number">-1</span>, <span class="built_in">Mat</span>());</span><br><span class="line">	<span class="comment">// 绘制直方图曲线</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bins[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">		<span class="built_in">line</span>(histImage, <span class="built_in">Point</span>(bin_w * (i - <span class="number">1</span>), hist_h - <span class="built_in">cvRound</span>(b_hist.at&lt;<span class="keyword">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line">			<span class="built_in">Point</span>(bin_w * (i), hist_h - <span class="built_in">cvRound</span>(b_hist.at&lt;<span class="keyword">float</span>&gt;(i))), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">line</span>(histImage, <span class="built_in">Point</span>(bin_w * (i - <span class="number">1</span>), hist_h - <span class="built_in">cvRound</span>(g_hist.at&lt;<span class="keyword">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line">			<span class="built_in">Point</span>(bin_w * (i), hist_h - <span class="built_in">cvRound</span>(g_hist.at&lt;<span class="keyword">float</span>&gt;(i))), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">line</span>(histImage, <span class="built_in">Point</span>(bin_w * (i - <span class="number">1</span>), hist_h - <span class="built_in">cvRound</span>(r_hist.at&lt;<span class="keyword">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line">			<span class="built_in">Point</span>(bin_w * (i), hist_h - <span class="built_in">cvRound</span>(r_hist.at&lt;<span class="keyword">float</span>&gt;(i))), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 显示直方图</span></span><br><span class="line">	<span class="built_in">namedWindow</span>(<span class="string">&quot;Histogram Demo&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Histogram Demo&quot;</span>, histImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<img src="https://img-blog.csdnimg.cn/2b0c19ca59964014b66511e95e51f2a8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">

<h2 id="三、二维直方图"><a href="#三、二维直方图" class="headerlink" title="三、二维直方图"></a>三、二维直方图</h2><p>&emsp;&emsp;我们知道RGB虽然有三个通道，但转到HSV色彩空间中只有H和S表示颜色，而V表示亮度。因此要表示一个图像的颜色只有两个维度H和S，因此可以组成一个平面的直方图形式。</p>
<p>&emsp;&emsp;二维直方图的计算调用函数与一维直方图相同，使用的方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::histShow2_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 2D 直方图</span></span><br><span class="line">	Mat hsv, hs_hist;</span><br><span class="line">	<span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);	<span class="comment">//RGB转HSV</span></span><br><span class="line">	<span class="keyword">int</span> hbins = <span class="number">30</span>, sbins = <span class="number">32</span>;				<span class="comment">//设置二维直方图的直方个数</span></span><br><span class="line">	<span class="keyword">int</span> hist_bins[] = &#123; hbins, sbins &#125;;</span><br><span class="line">	<span class="keyword">float</span> h_range[] = &#123; <span class="number">0</span>, <span class="number">180</span> &#125;;			<span class="comment">//H：0-180</span></span><br><span class="line">	<span class="keyword">float</span> s_range[] = &#123; <span class="number">0</span>, <span class="number">256</span> &#125;;			<span class="comment">//S：0-256</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span>* hs_ranges[] = &#123; h_range, s_range &#125;;</span><br><span class="line">	<span class="keyword">int</span> hs_channels[] = &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;			<span class="comment">//选择通道0和通道1</span></span><br><span class="line">	<span class="built_in">calcHist</span>(&amp;hsv, <span class="number">1</span>, hs_channels, <span class="built_in">Mat</span>(), hs_hist, <span class="number">2</span>, hist_bins, hs_ranges, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//进行归一化</span></span><br><span class="line">	<span class="keyword">double</span> maxVal = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">minMaxLoc</span>(hs_hist, <span class="number">0</span>, &amp;maxVal, <span class="number">0</span>, <span class="number">0</span>);	<span class="comment">//找到最大值</span></span><br><span class="line">	<span class="keyword">int</span> scale = <span class="number">10</span>;</span><br><span class="line">	Mat hist2d_image = Mat::<span class="built_in">zeros</span>(sbins * scale, hbins * scale, CV_8UC3);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; hbins; h++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; sbins; s++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">float</span> binVal = hs_hist.at&lt;<span class="keyword">float</span>&gt;(h, s);</span><br><span class="line">			<span class="keyword">int</span> intensity = <span class="built_in">cvRound</span>(binVal * <span class="number">255</span> / maxVal);</span><br><span class="line">			<span class="built_in">rectangle</span>(hist2d_image, <span class="built_in">Point</span>(h * scale, s * scale),</span><br><span class="line">				<span class="built_in">Point</span>((h + <span class="number">1</span>) * scale - <span class="number">1</span>, (s + <span class="number">1</span>) * scale - <span class="number">1</span>),</span><br><span class="line">				Scalar::<span class="built_in">all</span>(intensity),</span><br><span class="line">				<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">applyColorMap</span>(hist2d_image, hist2d_image, COLORMAP_JET);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;H-S Histogram&quot;</span>, hist2d_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/00e1e28596a4421aa33a6854cdc473bc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】图像的模糊处理方法（均值滤波与高斯模糊）</title>
    <url>/2021/08/13/110-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91%E5%9B%BE%E5%83%8F%E7%9A%84%E6%A8%A1%E7%B3%8A%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%88%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、均值滤波"><a href="#一、均值滤波" class="headerlink" title="一、均值滤波"></a>一、均值滤波</h2><h4 id="1-1-均值滤波的原理"><a href="#1-1-均值滤波的原理" class="headerlink" title="1.1 均值滤波的原理"></a>1.1 均值滤波的原理</h4><p>&emsp;&emsp;均值滤波用到的是图像卷积原理。由下图所示，卷积核为三阶单位矩阵时，进行均值滤波，原图像的每个三阶子矩阵都会求其均值，并将均值赋给中间的元素。</p>
<p>&emsp;&emsp;以左上角为例：<br>（$A_{11}$·1+$A_{12}$·1+$A_{13}$·1+<br> &emsp;$A_{21}$·1+$A_{22}$·1+$A_{23}$·1+<br>&emsp;$A_{31}$·1+$A_{32}$·1+$A_{33}$·1 ）/  9 -&gt;$A_{22}$<br><img src="https://img-blog.csdnimg.cn/5f9cf63ca53d4181b79dbe1946972549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%"></p>
<h4 id="1-2-OpenCV中的均值滤波"><a href="#1-2-OpenCV中的均值滤波" class="headerlink" title="1.2 OpenCV中的均值滤波"></a>1.2 OpenCV中的均值滤波</h4><p>&emsp;&emsp;在OpenCV/C++中，提供了blur函数用于实现上述的均值滤波操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blur</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	InputArray 	src,						<span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">	OutputArray dst,						<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">	Size 		ksize,						<span class="comment">//卷积核Size类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">	Point 		anchor=Point(<span class="number">-1</span>,<span class="number">-1</span>),		<span class="comment">//Point类型的锚点（-1表示锚点在核中心）</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 		borderType=BORDER_DEFAULT	<span class="comment">//边界模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中 <code>Size(w, h)</code>来表示内核的大小，w 为像素宽度，h为像素高度。</p>
<p>&emsp;&emsp;根据上面的 <code>blur()</code> 函数的定义，可以写出均值滤波的测试代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::blur_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	Mat dst;</span><br><span class="line">	<span class="built_in">blur</span>(image, dst, <span class="built_in">Size</span>(<span class="number">10</span>, <span class="number">10</span>), <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Blur&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下图是卷积核为 <code>Size(10,10)</code> 的效果。<br><img src="https://img-blog.csdnimg.cn/c54b4602aa2c4801b2c545697fe7df69.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;下图为卷积核为 <code>Size(1,15)</code> 的效果。<br><img src="https://img-blog.csdnimg.cn/432e023fa7e344679195a7f1ae930ce0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="二、高斯模糊"><a href="#二、高斯模糊" class="headerlink" title="二、高斯模糊"></a>二、高斯模糊</h2><p>&emsp;&emsp;有时候我们并不希望模糊处理时卷积核的系数都一样。而高斯模糊就是用于解决这类问题的一个方法。高斯模糊产生的系数在中心最大，离中心越远系数越小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::GaussianBlur</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	InputArray 	src,		<span class="comment">//输入图片，可以使是任意通道数，该函数对通道是独立处理的</span></span></span></span><br><span class="line"><span class="params"><span class="function">	OutputArray dst,		<span class="comment">//输出图片</span></span></span></span><br><span class="line"><span class="params"><span class="function">	Size 		ksize,		<span class="comment">//高斯内核大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">double</span> 		sigmaX,		<span class="comment">//高斯内核在X方向的标准偏差</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">double</span> 		sigmaY,		<span class="comment">//高斯内核在Y方向的标准偏差</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> 		borderType	<span class="comment">//判断图像边界的模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>
<p>其中<code>ksize</code>的行数和列数允许不相同，但必须是正奇数。<br>如果sigmaY为0，他将和sigmaX的值相同，如果他们都为0，那么他们由ksize的行数列数计算得出。</p>
<p>示例程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::gaussianBlur_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	Mat dst;</span><br><span class="line">	<span class="built_in">GaussianBlur</span>(image, dst, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">15</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;GaussianBlur&quot;</span>, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/4622448ccb724304aeafec9b839d2060.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习OpenCV4】人脸检测的实现方法</title>
    <url>/2021/08/14/111-%E3%80%90%E5%AD%A6%E4%B9%A0OpenCV4%E3%80%91%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>&emsp;&emsp;<strong>本文的目标是实现对于摄像头内的人脸进行实时检测。</strong></p>
<h2 id="一、文件准备"><a href="#一、文件准备" class="headerlink" title="一、文件准备"></a>一、文件准备</h2><p>&emsp;&emsp;首先需要到opencv的<a href="https://github.com/opencv/opencv/tree/master/samples/dnn/face_detector">github网站</a>上下载<code>opencv/samples/dnn/face_detector/</code>中所有的文件，并覆盖到本地的<code>...\opencv\sources\samples\dnn\face_detector</code>这个目录中。然后用记事本打开weights.meta4文件，下载其中两个url对应的文件。</p>
<p>&emsp;&emsp;由于下载过程可能需要<strong>科学上网</strong>，因此我将所需要的文件打包 <a href="https://download.csdn.net/download/weixin_44543463/21068345">face_detector.zip</a>，大家将压缩包解压后将里面所有文件复制到本地目录<code>...\opencv\sources\samples\dnn\face_detector</code>中即可。</p>
<img src="https://img-blog.csdnimg.cn/1edd93872e47466d9056cb3371a7d6bb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="60%">

<h2 id="二、程序设计"><a href="#二、程序设计" class="headerlink" title="二、程序设计"></a>二、程序设计</h2><h4 id="2-1-主要函数"><a href="#2-1-主要函数" class="headerlink" title="2.1 主要函数"></a>2.1 主要函数</h4><p><strong>1. blobFromImage()</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">blobFromImage</span>(InputArray image, 					<span class="comment">//输入神经网络进行处理的图片</span></span><br><span class="line">			  <span class="keyword">double</span> 	 scalefactor=<span class="number">1.0</span>, 			<span class="comment">//对像素值进行一定的尺度缩放</span></span><br><span class="line">		      <span class="keyword">const</span> 	 Size&amp; size = <span class="built_in">Size</span>(),		<span class="comment">//神经网络在训练的时候要求输入的图片尺寸</span></span><br><span class="line">			  <span class="keyword">const</span> 	 Scalar&amp; mean = <span class="built_in">Scalar</span>(), 	<span class="comment">//需要将图片整体减去的平均值</span></span><br><span class="line">			  <span class="keyword">bool</span>		 swapRB = <span class="literal">false</span>, 			<span class="comment">//BGR的顺序是否要交换，如果为true则为RGB</span></span><br><span class="line">			  <span class="keyword">bool</span> 		 crop = <span class="literal">false</span>,				<span class="comment">//是否需要裁剪</span></span><br><span class="line">			  <span class="keyword">int</span> 		 ddepth = CV_32F</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>2. net.forward()</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat probs = net.forward(); </span><br></pre></td></tr></table></figure>
<p>其输出有四个维度</p>
<ul>
<li>第一个维度：所有图像中每个图像的index</li>
<li>第二个维度：当前图像是第几个批次batchid，第几张图imageid</li>
<li>第三个维度：框的个数；</li>
<li>第四个维度：每个框有七个值，前两个是类型和dst，第三个是置信度，最后四个是矩形的左上角和右下角</li>
</ul>
<h4 id="2-2-示例程序"><a href="#2-2-示例程序" class="headerlink" title="2.2 示例程序"></a>2.2 示例程序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDemo::faceDetector_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建VideoCapture类</span></span><br><span class="line">	<span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	Mat frame;</span><br><span class="line"></span><br><span class="line">	<span class="comment">////读取模型和配置参数</span></span><br><span class="line">	std::string root_dir = <span class="string">&quot;E:/Program/OpenCV/opencv/sources/samples/dnn/face_detector/&quot;</span>;</span><br><span class="line">	dnn::Net net = dnn::<span class="built_in">readNetFromTensorflow</span>(root_dir+<span class="string">&quot;opencv_face_detector_uint8.pb&quot;</span>, root_dir+<span class="string">&quot;opencv_face_detector.pbtxt&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//实时检测</span></span><br><span class="line">	<span class="keyword">while</span> (capture.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">		capture.<span class="built_in">read</span>(frame);	<span class="comment">//逐帧读取视频</span></span><br><span class="line">		<span class="built_in">flip</span>(frame, frame, <span class="number">1</span>);	<span class="comment">//将读取的视频左右反转</span></span><br><span class="line">		<span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;	<span class="comment">//如果视频结束或未检测到摄像头则跳出循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//准备数据</span></span><br><span class="line">		Mat blob = dnn::<span class="built_in">blobFromImage</span>(frame, <span class="number">1.0</span>, <span class="built_in">Size</span>(<span class="number">300</span>, <span class="number">300</span>), <span class="built_in">Scalar</span>(<span class="number">104</span>, <span class="number">177</span>, <span class="number">123</span>), <span class="literal">false</span>, <span class="literal">false</span>);	</span><br><span class="line">		<span class="comment">//scalefactor=1.0表示图像的色彩保存在0到255之间；size和mean参数保存在models.yml中。两个false表示不需要rgb的转换也不需要剪切</span></span><br><span class="line">		net.<span class="built_in">setInput</span>(blob);<span class="comment">//将数据读入模型中。（blob结果是NCHW。N是个数，C通道数，H高度，W宽度）</span></span><br><span class="line">		Mat probs = net.forward(); </span><br><span class="line">		<span class="comment">//输出的第一个纬度所有图像中，每个图像的index；</span></span><br><span class="line">		<span class="comment">//第二纬度，当前图像是第几个批次batchid，第几张图imageid；</span></span><br><span class="line">		<span class="comment">//第三个纬度表示有多少个框；</span></span><br><span class="line">		<span class="comment">//第四个纬度，每个框有七个值，前两个是类型和dst，第三个是置信度，最后四个是矩形的左上角和右上角</span></span><br><span class="line">		<span class="function">Mat <span class="title">detectionMat</span><span class="params">(probs.size[<span class="number">2</span>], probs.size[<span class="number">3</span>], CV_32F, probs.ptr())</span></span>;</span><br><span class="line">		<span class="comment">//框的个数为行数，每个框的七个值为每行的元素</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//解析结果</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; detectionMat.rows; i++) &#123;</span><br><span class="line">			<span class="keyword">float</span> confidence = detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">2</span>);<span class="comment">//取出第三个值：置信度</span></span><br><span class="line">			<span class="keyword">if</span> (confidence &gt; <span class="number">0.6</span>) &#123;</span><br><span class="line">				<span class="comment">//再乘以图像的宽度或高度才能变为真实的</span></span><br><span class="line">				<span class="keyword">int</span> x1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">3</span>) * frame.cols);</span><br><span class="line">				<span class="keyword">int</span> y1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">4</span>) * frame.rows);</span><br><span class="line">				<span class="keyword">int</span> x2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">5</span>) * frame.cols);</span><br><span class="line">				<span class="keyword">int</span> y2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">6</span>) * frame.rows);</span><br><span class="line">				<span class="function">Rect <span class="title">box</span><span class="params">(x1, y1, x2 - x1, y2 - y1)</span></span>;</span><br><span class="line">				<span class="built_in">rectangle</span>(frame, box, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Face Dector&quot;</span>, frame);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span> k = <span class="built_in">waitKey</span>(<span class="number">33</span>);	<span class="comment">//两帧读取的间隔时间</span></span><br><span class="line">		<span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;			<span class="comment">//按下q键退出循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/e6b3bcf42aa44aa6a6172c7ad60c4ff6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70#pic_center" width="80%">]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo为文章设置目录与标签的方法</title>
    <url>/2021/08/16/113-Hexo%E4%B8%BA%E6%96%87%E7%AB%A0%E8%AE%BE%E7%BD%AE%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%A0%87%E7%AD%BE%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1-创建目录页"><a href="#1-创建目录页" class="headerlink" title="1. 创建目录页"></a>1. 创建目录页</h3><p>&emsp;&emsp;在网站根目录下执行以下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<font color='red'> Hexo\source</font> 目录中会生成一个<font color='red'> categories </font>文件夹，文件夹内有一个<font color='red'> index.md </font>文件，打开此文件，将其中的<font color='red'> type</font> 修改为<font color='red'> categories</font> 即可。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2021-08-16 10:27:28</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>
<h3 id="2-创建标签页"><a href="#2-创建标签页" class="headerlink" title="2. 创建标签页"></a>2. 创建标签页</h3><p>&emsp;&emsp;创建标签页与创建目录页方法相同。在网站根目录下执行以下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<font color='red'> Hexo\source</font> 目录中会生成一个<font color='red'> tags</font>文件夹，文件夹内也有一个<font color='red'> index.md </font>文件，打开此文件，将其中的<font color='red'> type</font> 修改为<font color='red'> tags</font> 即可。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2021-08-16 10:27:28</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>
<h3 id="3-为文章设置目录与标签"><a href="#3-为文章设置目录与标签" class="headerlink" title="3. 为文章设置目录与标签**"></a>3. 为文章设置目录与标签**</h3><p>&emsp;&emsp;在<font color='red'> Hexo\source_posts</font> 目录中创建.md文件即新建了一篇博客，在文章的开头部分添加如下代码</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 这里是文章的标题</span><br><span class="line">date: 这里是发表时间，如：2021-08-15 08:15:16</span><br><span class="line">description: 这里填写摘要。也可以把摘要这一段删去，在文章中想要截断的地方加入&lt;!--more--&gt;，这样在首页就只显示开头到截断的内容，而不会显示全文</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> 分类</span><br><span class="line"><span class="bullet">-</span> 子分类</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> 标签1</span><br><span class="line"><span class="section">- 标签2</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程序设计</category>
        <category>网站</category>
      </categories>
      <tags>
        <tag>网站搭建</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo中next主题的个性化配置</title>
    <url>/2021/08/16/112-Hexo%E4%B8%ADnext%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>&emsp;&emsp;Hexo与next主题的安装方法，网上有很多教程，这里不再赘述，直接开始next主题的配置方法。<br>&emsp;&emsp;在Hexo中一般有两个_config.yml文件，一个在根目录下，我称之为网站配置文件，一个在主题目录中，我称之为主题配置文件。</p>
<h2 id="一、主题常用配置"><a href="#一、主题常用配置" class="headerlink" title="一、主题常用配置"></a>一、主题常用配置</h2><p>next 主题的配置一般是指修改主题配置文件 <font color='red'> Hexo\themes\hexo-theme-next_config.yml </font> 文件。<br>在_config.yml 中可以修改许多常见的设置。</p>
<h4 id="1-更换主题（Scheme-Setting）"><a href="#1-更换主题（Scheme-Setting）" class="headerlink" title="1. 更换主题（Scheme Setting）"></a>1. 更换主题（Scheme Setting）</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主题</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 黑暗模式</span></span><br><span class="line"><span class="attr">darkmode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="2-菜单设置（Menu-Settings）"><a href="#2-菜单设置（Menu-Settings）" class="headerlink" title="2. 菜单设置（Menu Settings）"></a>2. 菜单设置（Menu Settings）</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用/禁用：菜单图标和项目徽章</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="3-侧边栏设置（Sidebar-Settings）"><a href="#3-侧边栏设置（Sidebar-Settings）" class="headerlink" title="3. 侧边栏设置（Sidebar Settings）"></a>3. 侧边栏设置（Sidebar Settings）</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 侧边栏位置</span></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position.</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 手动定义侧边栏宽度。如果注释，将默认为</span></span><br><span class="line">  <span class="comment"># Muse | Mist: 320</span></span><br><span class="line">  <span class="comment"># Pisces | Gemini: 240</span></span><br><span class="line">  <span class="attr">width:</span> <span class="number">240</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 侧边栏显示 (只对 Muse | Mist 主题生效), 可用的变量有:</span></span><br><span class="line">  <span class="comment">#  - post    自动展开（默认值）</span></span><br><span class="line">  <span class="comment">#  - always  在所有页面显示侧边栏</span></span><br><span class="line">  <span class="comment">#  - hide    仅在单击侧边栏切换图标时展开</span></span><br><span class="line">  <span class="comment">#  - remove  完全删除侧边栏，包括侧边栏切换</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 侧边栏填充像素</span></span><br><span class="line">  <span class="attr">padding:</span> <span class="number">18</span></span><br><span class="line">  <span class="comment"># 侧边栏与顶部菜单栏的偏移量(像素) (只对 Pisces | Gemini 主题生效).</span></span><br><span class="line">  <span class="attr">offset:</span> <span class="number">12</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">b2t:</span> <span class="literal">true</span> <span class="comment">#是否提供一键置顶</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span> <span class="comment">#是否显示当前阅读进度</span></span><br></pre></td></tr></table></figure>

<h4 id="4-侧边栏头像（Sidebar-Avatar）"><a href="#4-侧边栏头像（Sidebar-Avatar）" class="headerlink" title="4. 侧边栏头像（Sidebar Avatar）"></a>4. 侧边栏头像（Sidebar Avatar）</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 侧边栏头像</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># 替换默认图像并在这里设置头像的url</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span></span><br><span class="line">  <span class="comment"># 如果为true，头像将以圆圈显示</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 如果为true，鼠标悬停在头像上时，头像将会旋转</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="5-社交链接（Social-Links）"><a href="#5-社交链接（Social-Links）" class="headerlink" title="5. 社交链接（Social Links）"></a>5. 社交链接（Social Links）</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">CSDN:</span> <span class="string">https://blog.csdn.net/weixin_44543463</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-cuttlefish</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/HuffieMa</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:haofei_ma@163.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line">  <span class="attr">Twitter:</span> <span class="string">https://twitter.com/huffie65380272</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || fab fa-facebook</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || fab fa-youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || fab fa-instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || fab fa-skype</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里可能会需要自定义图标，可以在<a href="https://fontawesome.com/v5.15/icons">fontawesome</a>网站中搜索想要的图标，然后在这里使用 <code>fa fa-图标名称</code> 或  <code>fab fa-图标名称</code> 来调取所需要的图标。（如 <code>fab fa-cuttlefish</code> 、 <code>fa fa-grip-lines-vertical</code>）</p>
</blockquote>
<h2 id="二、网站配置"><a href="#二、网站配置" class="headerlink" title="二、网站配置"></a>二、网站配置</h2><p>网站配置一般是指修改配置文件 <font color='red'> Hexo_config.yml </font> 文件。<br>在_config.yml 中可以修改许多常见的设置。</p>
<h4 id="1-网站基本配置（网站名称、作者名字、中英文切换）"><a href="#1-网站基本配置（网站名称、作者名字、中英文切换）" class="headerlink" title="1. 网站基本配置（网站名称、作者名字、中英文切换）"></a>1. 网站基本配置（网站名称、作者名字、中英文切换）</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Half_A</span> <span class="string">Studio</span>  <span class="comment">#浏览器顶部标签栏的显示</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Huffie</span>	<span class="comment">#侧边栏中的作者名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>	 <span class="comment">#讲此处修改为zh-CN即可切换中文</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-主页显示文章数"><a href="#2-主页显示文章数" class="headerlink" title="2. 主页显示文章数"></a>2. 主页显示文章数</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br></pre></td></tr></table></figure>
<h2 id="三、翻译设置"><a href="#三、翻译设置" class="headerlink" title="三、翻译设置"></a>三、翻译设置</h2><p>网站切换为中文后，我们发现一些翻译不太符合我的要求，比如它把每一篇博客叫做日志，如果想修改，可以打开翻译配置文件 <font color='red'> Hexo\themes\hexo-theme-next\languages\zh-CN.yml</font> 进行修改</p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>网站</category>
      </categories>
      <tags>
        <tag>网站搭建</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+next的侧边栏背景与字体颜色设置方法</title>
    <url>/2021/08/17/114-Hexo+next%E7%9A%84%E4%BE%A7%E8%BE%B9%E6%A0%8F%E8%83%8C%E6%99%AF%E4%B8%8E%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>&emsp;&emsp;由于next主题经过了几次更新，查阅了许多资料都说要修改<font color="red"> custom.styl </font>这个配置文件，但是我的主题内没有此文件，经过翻阅大量的资料，终于找到了侧边栏的配置文件位置。</p>
<p>&emsp;&emsp;对于<font color="red"> Muse </font>和<font color="red"> Mist</font>主题，其侧边栏的配置文件为<code>Hexo\themes\hexo-theme-next\source\css\_schemes\Muse\_sidebar.styl</code>。</p>
<p>&emsp;&emsp;对于<font color="red"> Pisces</font>和<font color="red"> Gemini</font>主题，其侧边栏的配置文件为<code>Hexo\themes\hexo-theme-next\source\css\_schemes\Pisces\_sidebar.styl</code>。</p>
<p>&emsp;&emsp;在此配置文件中，可以找到<font color="red"> .sidebar</font>，修改其内部的属性参数即可实现<strong>设置侧边栏背景图片和字体颜色</strong>的功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.sidebar &#123;</span><br><span class="line">  <span class="comment">//设置背景图片，图片放在Hexo\themes\hexo-theme-next\source\images目录下</span></span><br><span class="line">  <span class="attr">background</span>:url(<span class="regexp">/images/</span>sidebar-bg.jpg);	</span><br><span class="line">  background-size: cover;</span><br><span class="line">  background-position:center;</span><br><span class="line">  background-repeat:no-repeat;</span><br><span class="line">  bottom: <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (not hexo-config(<span class="string">&#x27;back2top.sidebar&#x27;</span>)) &#123;</span><br><span class="line">    box-shadow: inset <span class="number">0</span> 2px 6px black;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">position</span>: fixed;</span><br><span class="line">  top: <span class="number">0</span>;</span><br><span class="line">  transition: all $transition-ease-out;</span><br><span class="line">  width: $sidebar-desktop;</span><br><span class="line">  z-index: $zindex-<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  a &#123;</span><br><span class="line">    <span class="comment">//设置文字颜色</span></span><br><span class="line">	border-bottom-color: #FFFFFF;</span><br><span class="line">	color: #FFFFFF;</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">	  border-bottom-color: $FFFFFF;</span><br><span class="line">	  color: #FFFFFF;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/1c864ad02c3e49c7871f0c9b87975cbd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>&emsp;&emsp;另外，侧边栏中头像下方的作者姓名和描述的字体颜色，可以在根目录下的站点配置文件中<code>_config.yml</code>中修改。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Half_A</span> <span class="string">Studio</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">Huffie&#x27;s</span> <span class="string">Blog</span></span><br><span class="line"><span class="comment"># 例如设置白色字体的description</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&lt;font</span> <span class="string">color=&quot;#FFFFFF&quot;&gt;Done</span> <span class="string">is</span> <span class="string">better</span> <span class="string">than</span> <span class="string">perfect.&lt;/font&gt;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">Control</span> <span class="string">Robot</span> <span class="string">Programming</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Huffie</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>设置完成后效果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/0c27da782ed34faa8ad80cc72eeeb4d7.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br><a href="http://huffie.cn/">http://huffie.cn/</a>这是我的博客，可以在此查看效果。</p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>网站</category>
      </categories>
      <tags>
        <tag>网站搭建</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo添加Follow me on CSDN效果</title>
    <url>/2021/08/17/115-Hexo%E6%B7%BB%E5%8A%A0Follow%20me%20on%20CSDN%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>&emsp;&emsp;<a href="http://huffie.cn/">http://huffie.cn/</a>这是我的博客，可以在此查看效果。</p>
<h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>&emsp;&emsp;效果图如下（右上角）：<br><img src="https://img-blog.csdnimg.cn/315cdc0169d54692a386d2dac503db50.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p>
<p>&emsp;&emsp;网络上比较多的是Fork me on Github效果，其实要实现Follow me on CSDN原理是一样的。</p>
<p>&emsp;&emsp;只需要将想要的效果图片下载下来ps一下，然后再上传到某个图床（或者说上传到CSDN），就可以得到此图片的url，替换到代码中即可。如下是我制作的两张图片，需要的小伙伴直接拿。（源代码见文末）</p>
<p><img src="https://img-blog.csdnimg.cn/abe3797b7d77419b81ecc02dd1bf8c34.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1f8e1ef9be9f4f7db01fe3a2d57829de.png" alt="请添加图片描述"><br>&emsp;&emsp;更多的效果图片可以在<a href="https://github.blog/2008-12-19-github-ribbons/">项目地址</a>下载，想要其他效果的自己p一下就可以了。</p>
<h3 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h3><p>粘贴复制如下的代码到<code>themes\hexo-theme-next\layout\_layout.njk</code>文件中(放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面 如图)，并把href改为你的csdn主页</p>
<p>黑色版本：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Follow me on CSDN--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://blog.csdn.net/weixin_44543463&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">width</span>=<span class="string">&quot;149&quot;</span> <span class="attr">height</span>=<span class="string">&quot;149&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; top: 0; right: 0; border: 0;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://img-blog.csdnimg.cn/abe3797b7d77419b81ecc02dd1bf8c34.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;attachment-full size-full&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Fork me on GitHub&quot;</span> <span class="attr">data-recalc-dims</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>白色版本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Follow me on CSDN--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://blog.csdn.net/weixin_44543463&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">width</span>=<span class="string">&quot;149&quot;</span> <span class="attr">height</span>=<span class="string">&quot;149&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; top: 0; right: 0; border: 0;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://img-blog.csdnimg.cn/1f8e1ef9be9f4f7db01fe3a2d57829de.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;attachment-full size-full&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Fork me on GitHub&quot;</span> <span class="attr">data-recalc-dims</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/fadabe4afa5a4bad8a23c95089247c25.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>网站</category>
      </categories>
      <tags>
        <tag>网站搭建</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【OpenCV/C++】KNN算法识别数字的实现原理与代码详解</title>
    <url>/2021/09/12/117-%E3%80%90OpenCV-C++%E3%80%91KNN%E7%AE%97%E6%B3%95%E8%AF%86%E5%88%AB%E6%95%B0%E5%AD%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="一、KNN原理"><a href="#一、KNN原理" class="headerlink" title="一、KNN原理"></a>一、KNN原理</h2><h4 id="1-1-KNN原理介绍"><a href="#1-1-KNN原理介绍" class="headerlink" title="1.1 KNN原理介绍"></a>1.1 KNN原理介绍</h4><p>&emsp;&emsp;KNN算法，即K最近邻算法，顾名思义其<strong>原理是当要预测一个新的值x的时候，根据离他最近的K个点大多属于什么类别来判断x属于哪个类别</strong>。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/listenfwind/p/10311496.html">zzzzMing -大数据技术-深入浅出KNN算法</a><img src="https://img-blog.csdnimg.cn/11d3fc70f20b4c67a2c7123c774d56cd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">&emsp;&emsp;K=3时，x最近的三个图形包括两个三角形、一个圆形，因为2&gt;1，所以x更有可能是三角形。<br><img src="https://img-blog.csdnimg.cn/9c438796648b4a6f9837ff752177fde0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>&emsp;&emsp;K=5时，x最近的五个图形包括两个三角形、三个圆形，因为3&gt;2，所以x更有可能是圆形。</p>
</blockquote>
<p>&emsp;&emsp;同理类比到图像识别方面，<strong>使用KNN算法前我们需要有大量的训练样本，并且知道每个样本所属的类别。</strong>（例如大量的数字图片，并且知道每个图片代表数字几）。当我们要识别数字时，本质上就是在训练样本中找与要识别的图像最接近的K个样本，然后统计出K个样本中出现最多的数字是哪个，那就是要识别的数字。</p>
<h4 id="1-2-KNN的关键参数"><a href="#1-2-KNN的关键参数" class="headerlink" title="1.2 KNN的关键参数"></a>1.2 KNN的关键参数</h4><p><strong>① 寻找多少最近邻样本 - K的选择</strong></p>
<p>&emsp;&emsp;K值决定着图像识别过程中，寻找的最近邻的图像个数，由上面的例子可以看出，选择不同的K，识别结果可能完全不同，因此K值是KNN算法中最关键的参数之一，它直接影响着模型的性能。</p>
<p>&emsp;&emsp;K值如果过小，那么此时识别结果就会很受样本质量的影响。如果训练样本存在某些错误或噪音，而寻找最近邻样本时正好找到了这些项，那么识别结果一定是错的，而增大K值，多寻找样本，会有效降低样本噪音的影响。</p>
<p>&emsp;&emsp;K值如果过大，假设K值等于训练样本数，那么无论要识别的图片是什么，识别结果都是样本中最多的那个类别。</p>
<p>&emsp;&emsp;那么K值应该如何选择呢？理论上来说K值与识别准确率的关系是存在一个极值的，可以通过多次实验，根据结果选择一个最好的K值。（例如K=3时准确率72；K=5时准确率91；K=8时准确率81，那么选择K=5会是一个相对较好的选择）</p>
<p><strong>② 如何判断“接近”程度 - 距离的计算</strong><br>&emsp;&emsp;距离计算函数一般使用曼哈顿距离或欧氏距离。</p>
<p>&emsp;&emsp;曼哈顿距离就是样本特征每一个维度的差值之合。（对应于图像，就是两图像每个像素做差）<br><img src="https://img-blog.csdnimg.cn/5aa2e07220794cb899c4d56fc3fdd079.png" alt="在这里插入图片描述"></p>
<p>&emsp;&emsp;欧式距离是样本特征在每一个维度上差值的平方和的根。<br><img src="https://img-blog.csdnimg.cn/c0bff7bfcf844b63a9cd496a74a8788c.png" alt="在这里插入图片描述"></p>
<h2 id="二、KNN算法识别手写数字"><a href="#二、KNN算法识别手写数字" class="headerlink" title="二、KNN算法识别手写数字"></a>二、KNN算法识别手写数字</h2><blockquote>
<p>KNN算法识别手写数字的源程序 - <a href="https://huffie.lanzoui.com/iQaVetwgsoj">点此下载</a></p>
</blockquote>
<h4 id="2-1-训练过程代码详解"><a href="#2-1-训练过程代码详解" class="headerlink" title="2.1 训练过程代码详解"></a>2.1 训练过程代码详解</h4><p>&emsp;&emsp;首先，我们要获得训练样本。OpenCV安装目录中给我们提供了手写数字的样本图片<code>opencv\sources\samples\data\digits.png</code>。这个图片中每个数字有5x100个样本，并且每个数字所占的像素均为20x20，因此可以从这个图片中提取我们需要的训练样本。</p>
<p>&emsp;&emsp;我们按列裁剪样本图片，<strong>每裁剪一个样本，就将其添加到data中，并同时将对应的数字添加到lable中</strong>。这样一来，我们就获得了图片和数字一一对应的data和lable数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat img = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/knn_test/images/data/digits.png&quot;</span>);</span><br><span class="line">Mat gray;</span><br><span class="line"><span class="built_in">cvtColor</span>(img, gray, COLOR_BGR2GRAY);</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> m = gray.rows / b;   <span class="comment">//原图为1000*2000</span></span><br><span class="line"><span class="keyword">int</span> n = gray.cols / b;   <span class="comment">//裁剪为5000个20*20的小图块</span></span><br><span class="line">Mat data, labels;   <span class="comment">//特征矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> offsetCol = i * b; <span class="comment">//列上的偏移量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> offsetRow = j * b;  <span class="comment">//行上的偏移量</span></span><br><span class="line">                              <span class="comment">//截取20*20的小块</span></span><br><span class="line">        Mat tmp;</span><br><span class="line">        <span class="built_in">gray</span>(<span class="built_in">Range</span>(offsetRow, offsetRow + b), <span class="built_in">Range</span>(offsetCol, offsetCol + b)).<span class="built_in">copyTo</span>(tmp);</span><br><span class="line">        <span class="comment">//reshape  0：通道不变  其他数字，表示要设置的通道数</span></span><br><span class="line">        <span class="comment">//reshape  表示矩阵行数，如果设置为0，则表示保持原有行数不变，如果设置为其他数字，表示要设置的行数</span></span><br><span class="line">        data.<span class="built_in">push_back</span>(tmp.<span class="built_in">reshape</span>(<span class="number">0</span>, <span class="number">1</span>));  <span class="comment">//序列化后放入特征矩阵</span></span><br><span class="line">        labels.<span class="built_in">push_back</span>((<span class="keyword">int</span>)j / <span class="number">5</span>);  <span class="comment">//对应的标注</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;利用这个训练样本就可以创建KNN模型了。</p>
<p>&emsp;&emsp;如果需要测试模型的识别准确度，可以从刚才获得的5000个样本中，选择前3000个样本作为训练数据，后2000个作为测试数据。用KNN模型计算测试数据的在样本中的识别正确情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">data.<span class="built_in">convertTo</span>(data, CV_32F); <span class="comment">//uchar型转换为cv_32f</span></span><br><span class="line"><span class="keyword">int</span> samplesNum = data.rows;</span><br><span class="line"><span class="keyword">int</span> trainNum = <span class="number">500</span>;</span><br><span class="line">Mat trainData, trainLabels;</span><br><span class="line">trainData = <span class="built_in">data</span>(<span class="built_in">Range</span>(<span class="number">0</span>, trainNum), Range::<span class="built_in">all</span>());   <span class="comment">//前3000个样本为训练数据</span></span><br><span class="line">trainLabels = <span class="built_in">labels</span>(<span class="built_in">Range</span>(<span class="number">0</span>, trainNum), Range::<span class="built_in">all</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用KNN算法</span></span><br><span class="line"><span class="keyword">int</span> K = <span class="number">5</span>;</span><br><span class="line">Ptr&lt;TrainData&gt; tData = TrainData::<span class="built_in">create</span>(trainData, ROW_SAMPLE, trainLabels);</span><br><span class="line">model = KNearest::<span class="built_in">create</span>();</span><br><span class="line">model-&gt;<span class="built_in">setDefaultK</span>(K);</span><br><span class="line">model-&gt;<span class="built_in">setIsClassifier</span>(<span class="literal">true</span>);</span><br><span class="line">model-&gt;<span class="built_in">train</span>(tData);</span><br><span class="line"><span class="comment">//预测分类</span></span><br><span class="line"><span class="keyword">double</span> train_hr = <span class="number">0</span>, test_hr = <span class="number">0</span>;</span><br><span class="line">Mat response;</span><br><span class="line"><span class="comment">// compute prediction error on train and test data</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; samplesNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Mat sample = data.<span class="built_in">row</span>(i);</span><br><span class="line">    <span class="keyword">float</span> r = model-&gt;<span class="built_in">predict</span>(sample);   <span class="comment">//对所有行进行预测</span></span><br><span class="line">                                        <span class="comment">//预测结果与原结果相比，相等为1，不等为0</span></span><br><span class="line">    r = std::<span class="built_in">abs</span>(r - labels.at&lt;<span class="keyword">int</span>&gt;(i)) &lt;= FLT_EPSILON ? <span class="number">1.f</span> : <span class="number">0.f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; trainNum)</span><br><span class="line">        train_hr += r;  <span class="comment">//累积正确数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        test_hr += r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_hr /= samplesNum - trainNum;</span><br><span class="line">train_hr = trainNum &gt; <span class="number">0</span> ? train_hr / trainNum : <span class="number">1.</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;accuracy: train = %.1f%%, test = %.1f%%\n&quot;</span>,</span><br><span class="line">    train_hr * <span class="number">100.</span>, test_hr * <span class="number">100.</span>);</span><br></pre></td></tr></table></figure>


<h4 id="2-2-预测分类的实现过程"><a href="#2-2-预测分类的实现过程" class="headerlink" title="2.2 预测分类的实现过程"></a>2.2 预测分类的实现过程</h4><p>&emsp;&emsp;训练样本制作完毕后，预测分类就非常简单了，将要识别的图像读取进来，进行二值化处理，然后调整大小到与样本图片一样大（20x20）。将处理好的图片push到test中，就可以直接使用刚才创建的KNN模型进行预测了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//预测分类</span></span><br><span class="line">Mat img = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/knn_test/images/test/4.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">cvtColor</span>(img, img, COLOR_BGR2GRAY);</span><br><span class="line"><span class="comment">//threshold(src, src, 0, 255, CV_THRESH_OTSU);</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">resize</span>(img, img, <span class="built_in">Size</span>(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">Mat test;</span><br><span class="line">test.<span class="built_in">push_back</span>(img.<span class="built_in">reshape</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">test.<span class="built_in">convertTo</span>(test, CV_32F);</span><br><span class="line"><span class="keyword">int</span> result = model-&gt;<span class="built_in">predict</span>(test);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;识别数字：&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="三、KNN算法识别印刷数字"><a href="#三、KNN算法识别印刷数字" class="headerlink" title="三、KNN算法识别印刷数字"></a>三、KNN算法识别印刷数字</h2><blockquote>
<p>KNN算法识别印刷数字的源程序 -<a href="https://huffie.lanzoui.com/iXh7Ktwgsvg">点此下载</a></p>
</blockquote>
<h4 id="2-1-训练过程"><a href="#2-1-训练过程" class="headerlink" title="2.1 训练过程"></a>2.1 训练过程</h4><p>&emsp;&emsp;识别印刷体数字与识别手写数字的原理相同，只是训练样本有区别。这里我制作了1000张不同字体的训练样本，加载方式例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//训练结果不存在，重新训练</span></span><br><span class="line"><span class="keyword">int</span> add_image_num = <span class="number">1000</span>;   <span class="comment">//扩充训练数据的文件夹个数</span></span><br><span class="line"><span class="keyword">int</span> filenum = <span class="number">0</span>;</span><br><span class="line">Mat data, labels;   <span class="comment">//特征矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; add_image_num; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Mat addimg = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/knn_test/images/data/&quot;</span> + <span class="built_in">to_string</span>(filenum) + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">cvtColor</span>(addimg, addimg, COLOR_BGR2GRAY);</span><br><span class="line">    <span class="comment">//threshold(src, src, 0, 255, CV_THRESH_OTSU);</span></span><br><span class="line">    <span class="built_in">resize</span>(addimg, addimg, <span class="built_in">Size</span>(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    data.<span class="built_in">push_back</span>(addimg.<span class="built_in">reshape</span>(<span class="number">0</span>, <span class="number">1</span>));  <span class="comment">//序列化后放入特征矩阵</span></span><br><span class="line">    labels.<span class="built_in">push_back</span>((<span class="keyword">int</span>)((filenum++) % <span class="number">10</span>));  <span class="comment">//对应的标注</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;训练样本加载完毕后，使用与上面相同的方式创建KNN模型，然后进行预测识别即可。</p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>《cmake practice》总结  cmake的构建过程与基本指令</title>
    <url>/2021/09/14/118-%E3%80%8Acmake%20practice%E3%80%8B%E6%80%BB%E7%BB%93%20-%20cmake%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="〇、基本语法规则"><a href="#〇、基本语法规则" class="headerlink" title="〇、基本语法规则"></a>〇、基本语法规则</h2><h4 id="0-1-变量"><a href="#0-1-变量" class="headerlink" title="0.1 变量"></a>0.1 变量</h4><p>&emsp;&emsp;变量使用 ${VALUENAME} 方式取值，但是在IF控制语句中直接使用变量名。</p>
<ol>
<li><code>CMAKE_BINARY_DIR</code> 或 <code>PROJECT_BINARY_DIR</code> 或 <code>&lt;ProjectName&gt;_BINARY_DIR</code>：均代表编译目录。如果是内部构建，就是指工程顶层目录；如果是外部构建，就是指工程编译发生的目录。</li>
<li><code>CMAKE_SOURCE_DIR</code> 或 <code>PROJECT_SOURCE_DIR</code> 或 <code>&lt;ProjectName&gt;_SOURCE_DIR</code>：均代表工程顶层目录。</li>
<li><code>CMAKE_CURRENT_SOURCE_DIR</code>：代表当前处理的 CMakeLists.txt 所在的路径。</li>
<li><code>CMAKE_CURRENT_BINARY_DIR</code>：如果是内部构建，与<code>CMAKE_CURRENT_SOURCE_DIR</code>相同；如果是外部构建，则代表目标编译目录。</li>
<li><code>CMAKE_CURRENT_LIST_FILE</code>：这个变量所在的CMakeLists.txt的完整路径。</li>
<li><code>CMAKE_CURRENT_LIST_LINE</code>：这个变量所在的行。</li>
<li><code>CMAKE_MODULE_PATH</code>：定义cmake模块所在的路径</li>
<li><code>EXECUTABLE_OUTPUT_PATH</code> 和 <code>LIBRARY_OUTPUT_PATH</code>：分别重新定义最终结果的存放目录。</li>
<li><code>PROJECT_NAME</code>：项目名称<h4 id="0-2-指令规则"><a href="#0-2-指令规则" class="headerlink" title="0.2 指令规则"></a>0.2 指令规则</h4>&emsp;&emsp;1. 基本语法为：指令(参数1 参数2 …)<br>&emsp;&emsp;2. 参数之间使用空格或分号隔开，例如<code>ADD_EXECUTABLE(hello main.c;func.c)</code><br>&emsp;&emsp;3. 指令不区分大小写，参数和变量区分大小写，但推荐全部使用大写指令<br>&emsp;&emsp;4. 当文件名中含有空格时，必须使用双引号，例如<code>SET(SRC_LIST &quot;fu nc.c&quot;)</code></li>
</ol>
<h4 id="0-3-基本构建过程"><a href="#0-3-基本构建过程" class="headerlink" title="0.3 基本构建过程"></a>0.3 基本构建过程</h4><p>&emsp;&emsp;1. 编写程序与CMakeLists.txt文件<br>&emsp;&emsp;2. 建立外部编译目录：<code>mkdir build</code><br>&emsp;&emsp;3. 进入外部编译目录：<code>cd build</code><br>&emsp;&emsp;4. 构建工程：<code>cmake ..</code><br>&emsp;&emsp;5. 实际构建：<code>make</code><br>&emsp;&emsp;6. 运行程序：<code>./&lt;Executable Filename&gt;</code><br>&emsp;&emsp;7. 清理工程：<code>make clean</code></p>
<h2 id="一、基本指令"><a href="#一、基本指令" class="headerlink" title="一、基本指令"></a>一、基本指令</h2><h4 id="1-PROJECT指令"><a href="#1-PROJECT指令" class="headerlink" title="1. PROJECT指令"></a>1. PROJECT指令</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PROJECT(projectname [CXX] [C] [Java])</span><br><span class="line"># 例：PROJECT(HELLO)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;定义工程名称，并可制订工程支持的语言，默认支持所有语言。此指令隐式的定义了两个变量 <code>PROJECT_BINARY_DIR</code> 和 <code>PROJECT_SOURCE_DIR</code>。</p>
<h4 id="2-SET指令"><a href="#2-SET指令" class="headerlink" title="2. SET指令"></a>2. SET指令</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br><span class="line"># 例<span class="number">1</span>：SET(SRC_LIST main.c)</span><br><span class="line"># 例<span class="number">2</span>：SET(EXECUTABLE_OUPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用来显式的定义变量。<br>&emsp;&emsp;在<code>ADD_EXECUTABL</code>所在的CMakeLists.txt文件中，添加如例2的语句，可以修改最终目标二进制文件输出的路径为<code>build/bin</code></p>
<h4 id="3-MESSAGE指令"><a href="#3-MESSAGE指令" class="headerlink" title="3. MESSAGE指令"></a>3. MESSAGE指令</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] <span class="string">&quot;message to display&quot;</span>)</span><br><span class="line"># 例：MESSAGE(STATUS <span class="string">&quot;This is BINARY dir $&#123;HELLO_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用于向终端输出用户定义的信息，包括三种类型</p>
<ul>
<li>SEND_ERROR：产生错误，生成过程被跳过</li>
<li>STATUS：输出前缀为-的信息</li>
<li>FATAL_ERROR：立即终止所有cmake过程</li>
</ul>
<h4 id="4-ADD-EXECUTABLE指令"><a href="#4-ADD-EXECUTABLE指令" class="headerlink" title="4. ADD_EXECUTABLE指令"></a>4. ADD_EXECUTABLE指令</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD_EXECUTABLE(&lt;Executable Filename&gt; $&#123;SRC_LIST&#125;)</span><br><span class="line"># 例：ADD_EXECUTABLE(hello $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;定义工程会生成文件名为<code>&lt;Executable Filename&gt;</code>的可执行文件，相关的源文件是SRC_LIST中定义的源文件列表。</p>
<h4 id="5-ADD-SUBDIRECTORY指令"><a href="#5-ADD-SUBDIRECTORY指令" class="headerlink" title="5. ADD_SUBDIRECTORY指令"></a>5. ADD_SUBDIRECTORY指令</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br><span class="line"># 例：ADD_SUBDIRECTORY(src bin)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用于将子目录加入当前工程，并可以指定其二进制文件存放的位置。<code>EXCLUDE_FROM_ALL</code>含义是将此目录从编译过程中排除。（例：将src子目录加入工程，并制订编译输出路径为bin，那么编译结果都将放在<code>build/bin</code>中）</p>
<h4 id="6-INSTALL指令"><a href="#6-INSTALL指令" class="headerlink" title="6. INSTALL指令"></a>6. INSTALL指令</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">INSTALL</span>(TARGETS targets... [EXPORT &lt;<span class="keyword">export</span>-name&gt;]</span><br><span class="line">        [[ARCHIVE|LIBRARY|RUNTIME|OBJECTS|FRAMEWORK|BUNDLE|</span><br><span class="line">          PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]</span><br><span class="line">         [DESTINATION &lt;dir&gt;]</span><br><span class="line">         [PERMISSIONS permissions...]</span><br><span class="line">         [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">         [COMPONENT &lt;component&gt;]</span><br><span class="line">         [NAMELINK_COMPONENT &lt;component&gt;]</span><br><span class="line">         [OPTIONAL] [EXCLUDE_FROM_ALL]</span><br><span class="line">         [NAMELINK_ONLY|NAMELINK_SKIP]</span><br><span class="line">        ] [...]</span><br><span class="line">        [INCLUDES DESTINATION [&lt;dir&gt; ...]]</span><br><span class="line">        )</span><br><span class="line"># 例：<span class="built_in">INSTALL</span>(FILES COPYRIGHT README DESTINATION share/doc/cmake/test)</span><br><span class="line"># 例：<span class="built_in">INSTALL</span>(PROGRAMS runprog.sh DESTINATION bin)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;INSTALL指令用于安装各种类型的文件，参数中的TARGETS就是要安装的文件，可以是二进制文件、动态库、静态库。在各个CMakeLists.txt中编写好INSTALL指令后就可以开始安装了。<br>&emsp;&emsp;安装的过程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=&lt;Install Path&gt;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="7-ADD-DEPENDENCIES指令"><a href="#7-ADD-DEPENDENCIES指令" class="headerlink" title="7. ADD_DEPENDENCIES指令"></a>7. ADD_DEPENDENCIES指令</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD_DEPENDENCIES(target-name depend-target1 depend-target2 ...)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;定义target以来的其他target，确保在本项目编译前，其他target已经被构建</p>
<h4 id="8-ADD-TEST与ENABLE-TESTING指令"><a href="#8-ADD-TEST与ENABLE-TESTING指令" class="headerlink" title="8. ADD_TEST与ENABLE_TESTING指令"></a>8. ADD_TEST与ENABLE_TESTING指令</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD_TEST(testname Exename arg1 arg2 ...)</span><br><span class="line">ENABLE_TEST()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用于创建test目标，生成makefile后就可以通过make test进行测试了。</p>
<h4 id="9-EXEC-PROGRAM"><a href="#9-EXEC-PROGRAM" class="headerlink" title="9. EXEC_PROGRAM"></a>9. EXEC_PROGRAM</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">EXEC_PROGRAM</span>(Executable</span><br><span class="line">			[directory in which to run]</span><br><span class="line">			[ARGS &lt;arguments to executable&gt;]</span><br><span class="line">			[OUTPUT_VARIABLE &lt;var&gt;]</span><br><span class="line">			[RETURN_VALUE &lt;var&gt;])</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用于指定在特定的目录运行某个程序。</p>
<h2 id="三、静态库与动态库的构建与使用"><a href="#三、静态库与动态库的构建与使用" class="headerlink" title="三、静态库与动态库的构建与使用"></a>三、静态库与动态库的构建与使用</h2><h4 id="3-1-静态库和动态库的构建方法"><a href="#3-1-静态库和动态库的构建方法" class="headerlink" title="3.1 静态库和动态库的构建方法"></a>3.1 静态库和动态库的构建方法</h4><p>&emsp;&emsp;1. 在工程目录下新建一个<code>lib</code>文件夹，并将其添加进工程目录中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 工程目录下的CMakeLists.<span class="function">txt</span></span><br><span class="line"><span class="function"><span class="title">PROJECT</span><span class="params">(HELLOLIB)</span></span></span><br><span class="line"><span class="function"><span class="title">ADD_SUBDIRECTORY</span><span class="params">(lib)</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 在<code>lib</code>文件夹下创建源文件。<br>&emsp;&emsp;3. 在<code>lib</code>目录下创建<code>CMakeLists.txt</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SET(LIBHELLO_SRC hello.c)</span><br><span class="line">#创建动态库</span><br><span class="line">ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line">#创建静态库</span><br><span class="line">ADD_LIBRARY(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line">SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">#实现动态库版本号</span><br><span class="line">SET_TARGET_PROPERTIES(hello PROPERTIES VERSION <span class="number">1.2</span> SOVERSION <span class="number">1</span>)</span><br><span class="line">#安装共享库和头文件</span><br><span class="line">INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br><span class="line">INSTALL(FILES hello.h DESTINATION include/hello)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4. 安装共享库和头文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/usr ..</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="3-2-外部共享库和头文件的使用"><a href="#3-2-外部共享库和头文件的使用" class="headerlink" title="3.2 外部共享库和头文件的使用"></a>3.2 外部共享库和头文件的使用</h4><p>&emsp;&emsp;1. 在新工程目录下创建<code>src</code>目录，并在其中编写源文件main.c<br>&emsp;&emsp;2. 编写工程目录下<code>CMakeLists.txt</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PROJECT(NEWHELLO)</span><br><span class="line">ADD_SUBDIRECTORY(src)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3. 编写<code>src</code>目录下的<code>CMakeLists.txt</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD_EXECUTABLE(main main.c)</span><br><span class="line"># 添加头文件搜索路径</span><br><span class="line">INCLUDE_DIRECTORIES(/usr/include/hello)</span><br><span class="line"># 将目标文件链接到共享库</span><br><span class="line">TARGET_LINK_LIBRARIES(main libhello.so)</span><br><span class="line"># 或：TARGET_LINK_LIBRARIES(main hello)</span><br><span class="line"># 或链接到静态库：TARGET_LINK_LIBRARIES(main libhello.a)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4. 构建运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考自<a href="https://huffie.lanzoui.com/i2kKdu0fu9e">《cmake practice》</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>数字化方法基础（四）_矩阵操作</title>
    <url>/2019/10/29/005-%E6%95%B0%E5%AD%97%E5%8C%96%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89_%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>全部教程链接：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/102650117#_490">https://blog.csdn.net/weixin_44543463/article/details/102650117#_490</a><br>此为其中的第四部分</p>
<h1 id="Chapter-7-矩阵操作"><a href="#Chapter-7-矩阵操作" class="headerlink" title="Chapter 7 矩阵操作"></a>Chapter 7 矩阵操作</h1><h2 id="利用矩阵实现向量平移"><a href="#利用矩阵实现向量平移" class="headerlink" title="利用矩阵实现向量平移"></a>利用矩阵实现向量平移</h2><p>1、基本原理:如图，任意给定一个点的坐标（列向量）x,y,z。设置一个矩阵，利用矩阵的乘法运算即可将三个坐标进行平移<br>注意：过程中所设置的矩阵为单位阵的最后一列加上偏移量Tx，Ty，Tz。如下图，大家自己试一下矩阵乘法即可验证。<br><img src="https://img-blog.csdnimg.cn/20191024160119165.png" alt="Huffie"><br>2、在了解了如何将一个列向量进行平移之后，我们就可以编写程序进行向量的平移操作了，我们打开生成螺旋线的程序，注意到螺旋线是由许许多多点组成的，下面这个for循环就是每次生成一个点，我们只需要吧每个点的坐标向量进行平移即可使整个螺旋线平移。<br><img src="https://img-blog.csdnimg.cn/20191024160915725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70" alt="Huffie"><br>3、现在就开始写程序了，首先明确一下程序执行过程</p>
<p> <strong>1. 获得一个点的坐标存入P0数组内<br> 2. 设置一个矩阵Translation用来将坐标平移<br> 3. 将上述两个矩阵相乘得到的结果存入P1数组内，此即为平移后的点的坐标</strong></p>
<p>4、第一步，获得一个点的坐标存入P0数组内，这一步十分简单（注：除函数定义外，其余代码均在for循环内）<code>float P0[3] = &#123;x,y,z&#125;;</code><br>5、第二步，设置一个矩阵Translation用来将坐标平移，我们需要一个下面这样的矩阵<br><img src="https://img-blog.csdnimg.cn/2019102416270440.png" alt="Huffie"><br>如何操作呢，首先先初始化一个单位矩阵，然后将单位矩阵的最后一列赋值为需要偏移的量（我的代码十分简单粗暴，当然也可单独另写一个函数用于初始化一个单位矩阵）<br>注意：在OpenGL中，矩阵是按列数的，就是说我定义的I[16]中的前四个元素I[1]、I[2]、I[3]、I[4]实际上是矩阵的第一列，最后的I[12]、I[13]、I[14]、I[15]是矩阵的最后一列，而非上学期C语言中理解的最后一行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Translate</span><span class="params">(<span class="keyword">float</span> fx,<span class="keyword">float</span> fy,<span class="keyword">float</span> fz,<span class="keyword">float</span> Translation[<span class="number">16</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> I[<span class="number">16</span>] = &#123;<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>&#125;;<span class="comment">//定义一个四阶单位阵</span></span><br><span class="line">	I[<span class="number">12</span>] = fx;<span class="comment">//将第四列第一行的元素赋fx</span></span><br><span class="line">	I[<span class="number">13</span>] = fy;<span class="comment">//第四列第二行赋fy</span></span><br><span class="line">	I[<span class="number">14</span>] = fz;<span class="comment">//第四列第三行赋fz</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">16</span>;i++)</span><br><span class="line">		Translation[i] = I[i];<span class="comment">//将I数组的值循环赋给Translation数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样操作之后就获得了如上面图片中的数组了。<br>6、第三步，将上述两个矩阵相乘得到的结果存入P1数组内，此即为平移后的点的坐标，So我们要做的就是定义一个P1数组<code>float P1[3];</code>这十分简单，然后就是写一个矩阵乘法的运算，用Translation*P0，结果存入P1中。<br>实现代码如下，注意translation为4*4矩阵，P0为3*1矩阵，P1为4*1矩阵，<br>（为什么要四阶矩阵是因为我们需要矩阵运算平移，只有多加一行一列才能实现，而P0和P1我们实际只用前3个元素，）<br>故我们让P0的“第四个”元素默认为1，即下面代码中最后一项为1*translation[i+12]。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ApplyMatrix</span><span class="params">(<span class="keyword">float</span> *P0,<span class="keyword">float</span> *translation,<span class="keyword">float</span> *P1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;++i)</span><br><span class="line">		P1[i] = P0[<span class="number">0</span>]*translation[i]+P0[<span class="number">1</span>]*translation[i+<span class="number">4</span>]+P0[<span class="number">2</span>]*translation[i+<span class="number">8</span>]+translation[i+<span class="number">12</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、有了设置操作矩阵的函数Translate，和矩阵相乘的函数ApplyMatrix，我们就可以平移点了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">		y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// Specify the point and move the Z value up a little	</span></span><br><span class="line">		glVertex3f(x, y, z);</span><br><span class="line">		<span class="keyword">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;	<span class="comment">//定义P0存放平移之前的点</span></span><br><span class="line">		<span class="keyword">float</span> P1[<span class="number">3</span>];			<span class="comment">//定义P1存放平移之后的点</span></span><br><span class="line">		<span class="keyword">float</span> Translation[<span class="number">16</span>];	<span class="comment">//存放一个4*4的操作矩阵</span></span><br><span class="line"></span><br><span class="line">		Translate(<span class="number">0.0f</span>,<span class="number">30.0f</span>,<span class="number">0.0f</span>,Translation);	</span><br><span class="line">		<span class="comment">//设置操作矩阵为我们想要的格式（单位阵-&gt;最后一列赋值）</span></span><br><span class="line">		ApplyMatrix(P0,Translation,P1);</span><br><span class="line">		<span class="comment">//操作矩阵和P0点相乘，结果放在P1内</span></span><br><span class="line">		glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line">		<span class="comment">//显示平移之后的点</span></span><br><span class="line">		z += <span class="number">0.5f</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>以上为螺旋线平移步骤</p>
<h2 id="使用矩阵实现向量旋转"><a href="#使用矩阵实现向量旋转" class="headerlink" title="使用矩阵实现向量旋转"></a>使用矩阵实现向量旋转</h2><p>1、如何进行向量旋转<br>首先了解一下二维坐标的旋转，设一个向量a的坐标是（x,y），长度为r，与x轴正向夹角为α，则：<br>            xa = r cos α,<br>            ya = r sin α.<br>如果把向量旋转一个角度φ，则新的向量b的坐标是<br>xb = r cos(α + φ) = r cos α cos φ - r sin α sin φ,<br>yb = r sin(α + φ) = r sin α cos φ + r cos α sin φ.<br><img src="https://img-blog.csdnimg.cn/20191027172646860.png" alt="Huffie"><br>又因为xa = r cos α，ya = r sin α.所以容易看出来<br>xb = xa cos φ - ya sin φ,<br>yb = ya cos φ + xa sin φ.<br>而等式右边，又可写成两个矩阵的乘积<br><img src="https://img-blog.csdnimg.cn/20191027172755173.png" alt="Huffie"><br>由此可知，等式中<strong>由sin和cos组成的二阶方阵</strong>，就<strong>可以实现将向量(xa ya,)旋转为(xb,yb,)<strong>，暂且叫做二阶的旋转操作矩阵<br>由此推导至三阶，</strong>三阶的旋转操作矩阵为以下三种</strong>（分别为绕x，y，z轴旋转），大家带入检验一下即可知道，<br><img src="https://img-blog.csdnimg.cn/20191027172919386.png" alt="Huffie"><br>而为了与之前的平移操作统一，因此我们也把这个三阶旋转操作矩阵扩展为四阶的，如下<br><img src="https://img-blog.csdnimg.cn/20191027172943354.png" alt="Huffie"><br>2、如何编写函数实现向量旋转呢<br>由刚才的推导我们知道，用旋转操作矩阵左乘一个列向量即可实现向量的旋转操作<br>现在我们来编写函数，以绕x轴为例，我们先来看一下“主函数”，这是生成螺旋线的那个循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">		y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// Specify the point and move the Z value up a little	</span></span><br><span class="line">		glVertex3f(x, y, z);</span><br><span class="line">		<span class="keyword">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line">		<span class="keyword">float</span> P1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//定义一个数组（用于存放旋转操作矩阵）</span></span><br><span class="line"><span class="comment">//这里也可生成一个单位阵，那样就不用初始化为0了</span></span><br><span class="line">		Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line"><span class="comment">//给定一个角度（-90°），生成旋转操作矩阵</span></span><br><span class="line">		ApplyMatrix(P0,multi,P1);</span><br><span class="line"><span class="comment">//用旋转操作矩阵左乘P0，得到的结果P1即为旋转完成的向量坐标</span></span><br><span class="line">		glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//显示旋转后的坐标对应的点</span></span><br><span class="line">		z += <span class="number">0.5f</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们需要做的就是<strong>写一个函数</strong>，<strong>由参数（角度）生成一个旋转操作矩阵</strong>，这里需要注意的是，math.h头文件中有sin和cos的函数，直接sin（angle）即可调用，其中angle为弧度值，代码如下<br>（注意，函数里用到的PI是在开头宏定义的<code>#define PI 3.14159</code>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rotate_x</span><span class="params">(<span class="keyword">float</span> angle,<span class="keyword">float</span> *rotation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	angle = angle/<span class="number">180.0</span>*PI;</span><br><span class="line"><span class="comment">//将角度值转换为弧度值</span></span><br><span class="line">	rotation[<span class="number">5</span>] = <span class="built_in">cos</span>(angle);</span><br><span class="line">	rotation[<span class="number">6</span>] = <span class="built_in">sin</span>(angle);</span><br><span class="line">	rotation[<span class="number">9</span>] = -<span class="built_in">sin</span>(angle);</span><br><span class="line">	rotation[<span class="number">10</span>] = <span class="built_in">cos</span>(angle);</span><br><span class="line">	rotation[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	rotation[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//配置各个位置的数值，注意矩阵下标是竖着数的，第一行位置为0、4、8、12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们得到了旋转操作矩阵，经“主函数”调用即可实现向量的旋转</p>
<h2 id="如何让图形既平移又旋转"><a href="#如何让图形既平移又旋转" class="headerlink" title="如何让图形既平移又旋转"></a>如何让图形既平移又旋转</h2><p>一个很简单的思路就是<strong>先后调用平移和旋转操作的函数</strong>，像下面这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">		y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// Specify the point and move the Z value up a little	</span></span><br><span class="line">		glVertex3f(x, y, z);</span><br><span class="line">		<span class="keyword">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line">		<span class="keyword">float</span> P1[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">float</span> P2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">		Translate(<span class="number">0.0f</span>,<span class="number">60.0f</span>,<span class="number">0.0f</span>,Translation);</span><br><span class="line">ApplyMatrix(P0,Translation,P1);</span><br><span class="line"><span class="comment">//进行平移操作，P0平移后为P1</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line">ApplyMatrix(P1,Rotation,P2);</span><br><span class="line"><span class="comment">//进行旋转操作，P1旋转后为P2</span></span><br><span class="line"></span><br><span class="line">		glVertex3f(P2[<span class="number">0</span>], P2[<span class="number">1</span>], P2[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//最后输出P2的点即可</span></span><br><span class="line">		z += <span class="number">0.5f</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>但是这显然不是我们想要的，我们想一步就完成平移操作，不需要中间P1的出现，那么就需要<strong>将平移操作矩阵和旋转操作矩阵相乘，得到的仍为一个四阶矩阵，再拿这个新的四阶矩阵左乘列向量xy，即可将列向量既平移又旋转</strong>。<br><strong>如何理解？</strong><br>我们知道平移操作矩阵和旋转操作矩阵都是可逆矩阵（det Rx ≠ 0，det T ≠ 0）<br><img src="https://img-blog.csdnimg.cn/20191027173422645.png" alt="Huffie"><br>那么这两个矩阵都可以写成许多个初等矩阵的乘积，即<br>Rx = R1*R2*R3<em>……Rn * I<br>T = R1’*R2’*R3’……Rn’ * I<br>（其中R1，R1’……Rn，Rn’都为初等矩阵，初等矩阵还记得吧，刚学过的线代，只进行一次初等变换的矩阵；初等矩阵左乘一个矩阵即对他行变换）<br>那么我们知道平移操作为<br><img src="https://img-blog.csdnimg.cn/20191027173638419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>同理旋转操作也可以写成<br><img src="https://img-blog.csdnimg.cn/20191027173739886.png" alt="Huffie"><br>那么先平移，然后把平移得到的矩阵旋转就可以写成如下的形式<br><img src="https://img-blog.csdnimg.cn/20191027173802375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>又因为Rx = R1</em>R2<em>R3</em>……Rn，T = R1’<em>R2’</em>R3’……Rn’<br>所以 Rx<em>T</em>列向量 就代表把列向量平移又旋转<br>那么我们现在要做的就是写一个四阶矩阵的乘法函数，以获取Rx*T的结果，拿这结果左乘列向量即一步实现平移旋转。<br>四阶矩阵的乘法代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">float</span> *rotation,<span class="keyword">float</span> *translation,<span class="keyword">float</span> *tran)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)</span><br><span class="line">				tran[<span class="number">4</span>*i+j] += rotation[<span class="number">4</span>*k+j]*translation[<span class="number">4</span>*i+k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个是用16个元素的变量代表一个矩阵，下标表示比较麻烦，大家可以在纸上写一下<br>代码写法不唯一，也可以把它拆成四个循环单独写，当然也可以直接把每个元素赋值，赋值16次就完了<br>然后按照刚才的逻辑在“主函数”里调用一下就可以了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">		y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// Specify the point and move the Z value up a little	</span></span><br><span class="line">		glVertex3f(x, y, z);</span><br><span class="line">		<span class="keyword">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line">		<span class="keyword">float</span> P1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">		Translate(<span class="number">0.0f</span>,<span class="number">60.0f</span>,<span class="number">0.0f</span>,Translation);</span><br><span class="line"><span class="comment">//获得平移操作矩阵</span></span><br><span class="line">		<span class="keyword">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line"><span class="comment">//获得旋转操作矩阵</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> multi[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		mul(Rotation,Translation,multi);</span><br><span class="line"><span class="comment">//两矩阵相乘获得平移+旋转操作矩阵</span></span><br><span class="line">		ApplyMatrix(P0,multi,P1);</span><br><span class="line"><span class="comment">//用平移+旋转操作矩阵左乘P0即可得到被平移且旋转之后的矩阵P1</span></span><br><span class="line">		glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line">		z += <span class="number">0.5f</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>以上即利用矩阵实现向量的平移与旋转操作</p>
<h2 id="坐标系的旋转"><a href="#坐标系的旋转" class="headerlink" title="坐标系的旋转"></a>坐标系的旋转</h2><p><strong>1、目标</strong>：<br>给定一个向量（如(1,1,1)），将原坐标系旋转为以此向量为Z轴的坐标系。<br><strong>2、基本概念</strong>：<br>如图，左面的三阶方阵内每一列为新坐标轴的三个单位向量，用这个<strong>三阶方阵左乘一个原坐标系的点</strong>，即可<strong>将这个点坐标旋转为新坐标系的对应坐标</strong><br>由此，我们只需要生成一个左面的旋转坐标系的矩阵即可。<br><img src="https://img-blog.csdnimg.cn/20191029203029723.png" alt="Huffie"><br><strong>3、如何生成Ruvw矩阵</strong><br>法一：<br>（1）先单位化已知矢量z<br>（2）然后把已知矢量z中的其中一个坐标变为1，这样就获得了两个在同一平面的向量<br>（3）然后用这两个向量叉乘，得到的结果就是和已知矢量z垂直的矢量y<br>（4）然后再用已知矢量z叉乘刚获得的向量y，得到与这两个向量都垂直的向量x。<br>（5）如此，将得到的三个坐标轴矢量组合成的形式（u为新x轴，v为新y轴，w为新z轴）<br><img src="https://img-blog.csdnimg.cn/20191029203154309.png" alt="Huffie"><br>法二：知道给定矢量的三个坐标(Zx,Zy,Zz),则和这个矢量垂直的向量之一的坐标是(Zy,-Zx,0)，这样同样可以获得两个相互垂直的矢量，然后这俩矢量叉乘得到第三个矢量，即为三坐标轴。将得到的三个坐标轴矢量组合成的形式（u为新x轴，v为新y轴，w为新z轴）<br>（注：代表新坐标轴的三个矢量均需要单位化）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此为法二的代码，其中Rotation+4等地方用到了指针的技巧</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RotateCoor</span><span class="params">(<span class="keyword">float</span> *z,<span class="keyword">float</span> *Rotation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Rotation[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">	Rotation[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line">	Normalize(z);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">		Rotation[<span class="number">8</span>+i] = z[i];</span><br><span class="line">	Rotation[<span class="number">4</span>] = -z[<span class="number">1</span>];</span><br><span class="line">	Rotation[<span class="number">5</span>] = z[<span class="number">0</span>];</span><br><span class="line">	Normalize(Rotation+<span class="number">4</span>);</span><br><span class="line">	crossproject(z,Rotation+<span class="number">4</span>,Rotation);</span><br><span class="line">	Normalize(Rotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191029203612608.png" alt="在这里插入图片描述"><br>上图矩阵即为坐标系旋转操作矩阵，<strong>和之前平移与旋转一样</strong>，用<strong>这个矩阵×P0点</strong>，即可得到<strong>坐标轴旋转后的点P1</strong></p>
<h2 id="让图形显示在屏幕中心且绕中心转动"><a href="#让图形显示在屏幕中心且绕中心转动" class="headerlink" title="让图形显示在屏幕中心且绕中心转动"></a>让图形显示在屏幕中心且绕中心转动</h2><p>1.首先我们要知道，OpenGL生成的对话框的长和宽是可以设置的，我们需要让对话框的宽高比与我们要生成的图像的宽高比相同，并且对话框要比图像稍大一些。<br>2、具体如下思路：<br>设模型的高为ModelHeight，宽为ModelWidth，生成的空间高为h，宽为w<br><strong>如果ModelHeight/h &gt; ModelWidth/w，说明对话框比较高（模型比较宽），因此要尽可能满足模型的宽</strong>，比如让<strong>对话框的宽为模型宽的2.5倍</strong>（让对话框稍大一些），则<strong>对话框的高就为 对话框的高/模型的高 * 模型的宽</strong>。<br>同理对话框比较扁也可以得到对称的结论，因此，用计算得到的对话框的宽和高就可生成一个合适的对话框。<br>3、如何编程更改对话框大小：<br>打开之前加载泵体的那个文件(chapt05\shinyjet)更改ChangeSize函数为以下形式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangeSize</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    GLfloat fAspect;</span><br><span class="line">    GLfloat lightPos[] = &#123; <span class="number">-50.f</span>, <span class="number">50.0f</span>, <span class="number">100.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent a divide by zero</span></span><br><span class="line">    <span class="keyword">if</span>(h == <span class="number">0</span>)</span><br><span class="line">        h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set Viewport to window dimensions</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset coordinate system</span></span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fAspect = (GLfloat) w / (GLfloat) h;</span><br><span class="line">	<span class="comment">// Establish clipping volume (left, right, bottom, top, near, far)</span></span><br><span class="line">	<span class="comment">//aspectRatio = (GLfloat)w / (GLfloat)h;</span></span><br><span class="line"><span class="comment">//这之上都不用动</span></span><br><span class="line">	<span class="keyword">float</span> scale = <span class="number">2.5</span>;</span><br><span class="line"><span class="comment">//对话框与模型大小比例为2.5倍</span></span><br><span class="line">	<span class="keyword">float</span> ScaleHeight,ScaleWidth,ModelWidth,ModelHeight;</span><br><span class="line"><span class="comment">//定义对话框的宽高，模型的宽高</span></span><br><span class="line">	ModelWidth = PointMax[<span class="number">0</span>]-PointMin[<span class="number">0</span>];</span><br><span class="line">	ModelHeight = PointMax[<span class="number">1</span>]-PointMin[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//模型宽的计算可由模型上最右的点坐标减最左点的坐标</span></span><br><span class="line">	<span class="keyword">if</span>(w*ModelHeight &gt; h*ModelWidth)</span><br><span class="line">	&#123;<span class="comment">//当ModelHeight/h &gt; ModelWidth/w时，模型比较宽，对话框比较高</span></span><br><span class="line">		ScaleHeight = scale * ModelHeight;</span><br><span class="line"><span class="comment">//设置对话框的宽为模型宽的2.5倍</span></span><br><span class="line">		ScaleWidth =  scale * ModelHeight * w / h;</span><br><span class="line"><span class="comment">//对话框的高为 对话框的高/模型的高 * 模型的宽</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ScaleWidth =  scale * ModelWidth;</span><br><span class="line">		ScaleHeight = scale * ModelWidth * h / w;</span><br><span class="line">	&#125;</span><br><span class="line">	glOrtho(<span class="number">0.5</span> * (PointMax[<span class="number">0</span>] - PointMin[<span class="number">0</span>]) - <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">0</span>] - PointMin[<span class="number">0</span>]) + <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">1</span>] - PointMin[<span class="number">1</span>]) - <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">1</span>] - PointMin[<span class="number">1</span>]) + <span class="number">0.5</span> * ScaleWidth,<span class="number">-2.0</span>,<span class="number">2.0</span>);</span><br><span class="line"><span class="comment">//定出模型的中心坐标，下面代码就根据中心坐标生成一个与模型中心位置相同的对话框</span></span><br><span class="line"><span class="comment">//这之下都不用动</span></span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    </span><br><span class="line">    glLightfv(GL_LIGHT0,GL_POSITION,lightPos);</span><br><span class="line">    <span class="comment">//glTranslatef(0.0f, 0.0f, -150.0f);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>4、如何编程找出模型上对角线的两个点<br>将之前写过的读取文件里点的坐标的那个while循环中添加一部分内容，改成如下形式，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">		<span class="keyword">while</span>(<span class="built_in">strcmp</span>(String0,<span class="string">&quot;endsolid&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			in &gt;&gt; String0;</span><br><span class="line">			in &gt;&gt; n[<span class="number">0</span>] &gt;&gt; n[<span class="number">1</span>] &gt;&gt; n[<span class="number">2</span>];</span><br><span class="line">			in &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; Points[<span class="number">0</span>] &gt;&gt; Points[<span class="number">1</span>] &gt;&gt; Points[<span class="number">2</span>];</span><br><span class="line">			in &gt;&gt; String0 &gt;&gt; Points[<span class="number">3</span>] &gt;&gt; Points[<span class="number">4</span>] &gt;&gt; Points[<span class="number">5</span>];</span><br><span class="line">			in &gt;&gt; String0 &gt;&gt; Points[<span class="number">6</span>] &gt;&gt; Points[<span class="number">7</span>] &gt;&gt; Points[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//以下为新加内容，作用为找到对角线上的两个点，存到PointMin和PointMax里</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">float</span> * point = Points + <span class="number">3</span>;point &lt; Points + <span class="number">11</span>;point += <span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(Points[j]&lt;PointMin[j])</span><br><span class="line">					&#123;</span><br><span class="line">						PointMin[j] = Points[j];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(Points[j]&gt;PointMax[j])</span><br><span class="line">					&#123;</span><br><span class="line">						PointMax[j] = Points[j];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//以上为新加内容</span></span><br><span class="line">			glColor3ub(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line">			glBegin(GL_TRIANGLES);</span><br><span class="line">			DrawTriangle(Points,Points+<span class="number">3</span>,Points+<span class="number">6</span>,n);</span><br><span class="line">			glEnd();</span><br><span class="line">			in &gt;&gt; String0 &gt;&gt; String0&gt;&gt; String0;</span><br><span class="line">		&#125;</span><br><span class="line">（注意，因为PointMin和PointMax既在SetupRC函数里使用又在Changesize函数里使用，故需要定义为全局变量，如下<span class="keyword">float</span> PointMin[<span class="number">3</span>] = &#123;<span class="number">1.0e38</span>f,<span class="number">1.0e38</span>f,<span class="number">1.0e38</span>f&#125;;<span class="keyword">float</span> PointMax[<span class="number">3</span>] = &#123;<span class="number">1.0e-38</span>f,<span class="number">1.0e-38</span>f,<span class="number">1.0e-38</span>f&#125;;）</span><br></pre></td></tr></table></figure>
<p>5、现在看起来可以了，我们把对话框设置成了和模型等比例，对称中心重合，但还需要更改一个地方就是，我们生成的<strong>模型中心和我们旋转轴的中心不是重合的</strong>，我们如何实现按下键盘时，让模型绕原点转动，而不是绕其他轴运动。<br>具体思路就是，我们<strong>要让模型绕自己中心旋转，可以先把模型平移到坐标轴原点处（原点与模型中心重合），进行旋转，然后在平移回原来位置，这样看上去就是模型绕自己中心旋转了</strong>，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderScene</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	<span class="comment">// Clear the window with current clearing color</span></span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save the matrix state and do the rotations</span></span><br><span class="line">	glPushMatrix();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">	Translate(<span class="number">0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">	glRotatef(xRot,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">	glRotatef(yRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">	Translate(<span class="number">-0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">	glCallList(DrawList);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Restore the matrix state</span></span><br><span class="line">	glPopMatrix();</span><br><span class="line">	<span class="comment">// Display the results</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>经过修改这三个地方就实现了让模型能够正常的显示在屏幕中心且绕模型自己的中心转动<br><em><strong>Continue……</strong></em></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>前端笔记 | HTML基础</title>
    <url>/2021/03/12/079-%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%20%20HTML%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="一、HTML的介绍"><a href="#一、HTML的介绍" class="headerlink" title="一、HTML的介绍"></a>一、HTML的介绍</h3><h4 id="1-1-什么是HTML"><a href="#1-1-什么是HTML" class="headerlink" title="1.1 什么是HTML"></a>1.1 什么是HTML</h4><p>HTML是用来描述网页的一种语言</p>
<p>HTML指超文本标记语言</p>
<p>HTML不是编程语言，是一种标记语言</p>
<h4 id="1-2-HTML5的新特性"><a href="#1-2-HTML5的新特性" class="headerlink" title="1.2 HTML5的新特性"></a>1.2 HTML5的新特性</h4><p>用于绘画的canvas标签</p>
<p>用于媒介回放的video和audio元素</p>
<p>对本地离线存储的更好支持</p>
<p>新的特殊内容：article、footer、header、nav、section</p>
<p>新的表单控件：calendar、date、time、email、url、search</p>
<p>浏览器的支持：Safari、Chrome、Firefox以及Opera包括IE9以上</p>
<h3 id="二、HTML基础"><a href="#二、HTML基础" class="headerlink" title="二、HTML基础"></a>二、HTML基础</h3><h4 id="2-1-声明"><a href="#2-1-声明" class="headerlink" title="2.1 声明"></a>2.1 声明</h4><p><strong>声明：</strong><code>&lt;!DOCTYPE html&gt;</code></p>
<p>HTML有多个不同的版本，只有明白页面使用的确切的HTML版本，浏览器才能完全正确的显示出HTML页面。</p>
<blockquote>
<p>HTML5：<code>&lt;!DOCTYPE html&gt;</code></p>
<p>HTML4.01:<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;  &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</code></p>
</blockquote>
<h4 id="2-2-基础标签"><a href="#2-2-基础标签" class="headerlink" title="2.2 基础标签"></a>2.2 基础标签</h4><p><strong>基础标签：</strong><code>&lt;head&gt; &amp; &lt;body&gt;</code></p>
<ol>
<li>head：定义头部。如编码格式(UTF-8)、标题(title)、文字的显示形式，</li>
<li>body：页面的内容，其他的标签等</li>
</ol>
<h4 id="2-3-HTML标题"><a href="#2-3-HTML标题" class="headerlink" title="2.3 HTML标题"></a>2.3 HTML标题</h4><p><strong>标题：</strong><code>&lt;h1&gt; &lt;h2&gt;……&lt;h6&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题h2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>标题h3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>标题h4<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>标题h5<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h6</span>&gt;</span>标题h6<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210311114800432.png" alt="在这里插入图片描述"></p>
<h4 id="2-4-HTML段落"><a href="#2-4-HTML段落" class="headerlink" title="2.4 HTML段落"></a>2.4 HTML段落</h4><p><strong>段落：</strong><code>&lt;p&gt;</code></p>
<p>定义一个段落</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello World</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210311114811371.png" alt="在这里插入图片描述"></p>
<h4 id="2-5-HTML链接"><a href="#2-5-HTML链接" class="headerlink" title="2.5 HTML链接"></a>2.5 HTML链接</h4><p><strong>链接：</strong><code>&lt;a&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://blog.csdn.net/weixin_44543463&quot;</span>&gt;</span>Half_A的CSDN主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/2021031111481932.png" alt="在这里插入图片描述"></p>
<h4 id="2-6-HTML图像"><a href="#2-6-HTML图像" class="headerlink" title="2.6 HTML图像"></a>2.6 HTML图像</h4><p><strong>图像：</strong><code>&lt;img&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/Huffie.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210311114825458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="三、HTML元素、属性和格式化"><a href="#三、HTML元素、属性和格式化" class="headerlink" title="三、HTML元素、属性和格式化"></a>三、HTML元素、属性和格式化</h3><h4 id="3-1-元素"><a href="#3-1-元素" class="headerlink" title="3.1 元素"></a>3.1 元素</h4><p>元素是指从开始标签到结束标签的所有内容</p>
<table>
<thead>
<tr>
<th>开始标签</th>
<th>元素内容</th>
<th>结束标签</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;p&gt;</code></td>
<td>this is my page</td>
<td><code>&lt;/p&gt;</code></td>
</tr>
</tbody></table>
<blockquote>
<p><code>&lt;p&gt;&lt;/p&gt;</code>是段落标记，<code>&lt;br/&gt;</code>是换行符</p>
<p>二者虽然都可以实现换行，但其行间距不一样</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is my webpage<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> Hello,world<span class="tag">&lt;<span class="name">br</span>/&gt;</span>Huffie</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210311200457291.png#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>元素内容是指从开始标签到结束标签之间的内容</li>
<li>空元素在开始标签中进行关闭（如<code>&lt;br/&gt;</code>）</li>
<li>大多数HTML元素可拥有属性</li>
<li>大多数HTML元素都是可以嵌套的</li>
</ul>
<h4 id="3-2-HTML属性"><a href="#3-2-HTML属性" class="headerlink" title="3.2 HTML属性"></a>3.2 HTML属性</h4><ol>
<li><p>标签可以拥有属性为元素提供更多的信息</p>
</li>
<li><p>属性以键/值对的形式出现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">href=&quot;www.huffie.top&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>常用标签属性</p>
<p><code>&lt;h1&gt;:align</code> ：对齐方式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<body>:bgcolor`  背景颜色 

 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;#ebebeb&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：bgcolor设置背景颜色，background设置背景图片</p>
<p><code>&lt;a&gt;:target</code>  规定在何处打开链接  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;test.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>通用属性</p>
<table>
<thead>
<tr>
<th>通用属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>规定元素的类名</td>
</tr>
<tr>
<td>id</td>
<td>规定元素唯一ID</td>
</tr>
<tr>
<td>style</td>
<td>规定元素样式</td>
</tr>
<tr>
<td>title</td>
<td>规定元素的额外信息</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="3-3-格式化"><a href="#3-3-格式化" class="headerlink" title="3.3 格式化"></a>3.3 格式化</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;b&gt;</code></td>
<td>定义粗体文本</td>
</tr>
<tr>
<td><code>&lt;big&gt;</code></td>
<td>定义大号字</td>
</tr>
<tr>
<td><code>&lt;em&gt;</code></td>
<td>定义着重文字</td>
</tr>
<tr>
<td><code>&lt;i&gt;</code></td>
<td>定义斜体字</td>
</tr>
<tr>
<td><code>&lt;small&gt;</code></td>
<td>定义小号字</td>
</tr>
<tr>
<td><code>&lt;strong&gt;</code></td>
<td>定义加重语气</td>
</tr>
<tr>
<td><code>&lt;sub&gt;</code></td>
<td>定义下标字</td>
</tr>
<tr>
<td><code>&lt;sup&gt;</code></td>
<td>定义上标字</td>
</tr>
<tr>
<td><code>&lt;ins&gt;</code></td>
<td>定义插入字</td>
</tr>
<tr>
<td><code>&lt;del&gt;</code></td>
<td>定义删除字</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello, I&#x27;m huffie!<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>标签 b：欢迎来到我的博客<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">big</span>&gt;</span>标签 big: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">big</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">em</span>&gt;</span>标签 em: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span>标签 i: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">small</span>&gt;</span>标签 small: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>标签 strong: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 标签 sub: 欢迎来到<span class="tag">&lt;<span class="name">sub</span>&gt;</span>这是上标<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>我的博客</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 标签 sup: 欢迎来到<span class="tag">&lt;<span class="name">sup</span>&gt;</span>这是下标<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>我的博客</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ins</span>&gt;</span>标签 ins: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">del</span>&gt;</span>标签 del: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210311200601710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="四、样式、链接和表格"><a href="#四、样式、链接和表格" class="headerlink" title="四、样式、链接和表格"></a>四、样式、链接和表格</h3><h4 id="4-1-样式"><a href="#4-1-样式" class="headerlink" title="4.1 样式"></a>4.1 样式</h4><ol>
<li><p>标签：</p>
<ul>
<li><code>&lt;style&gt;</code>：样式定义</li>
<li><code>&lt;link&gt;</code>：资源引用</li>
</ul>
</li>
<li><p>属性：</p>
<ul>
<li>rel=”stylesheet”：外部样式表</li>
<li>type=”text/css”：引入文档的类型</li>
<li>margin-left：边距</li>
</ul>
</li>
<li><p>样式的插入方式</p>
<ul>
<li><p>外部样式表</p>
<p><strong>语法：</strong><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</code></p>
<p>即指定外部引用资源，文档类型为css，具体位置为mystyle.css</p>
<p><strong>例：</strong>index.html：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>样式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>mystyle.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210311200618171.png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>内部样式表</p>
<p><strong>语法：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: aquamarine;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>例：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>样式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: aquamarine;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>欢迎来到我的博客<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210311200629686.png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>内联样式表</p>
<p><strong>语法：</strong><code>    &lt;p style=&quot;color: blueviolet;&quot;&gt;点击我跳转到CSDN&lt;/a&gt;</code></p>
<p><strong>例：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>样式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: blueviolet;&quot;</span>&gt;</span>点击我跳转到CSDN<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h4><ol>
<li><p>链接数据包括 文本链接、图片链接</p>
</li>
<li><p>属性：</p>
<ul>
<li>href属性：指向另一个文档的链接</li>
<li>name属性：创建文档内的链接</li>
</ul>
</li>
<li><p>img标签属性：</p>
<ul>
<li>alt：替换文本属性</li>
<li>width：宽</li>
<li>height：高</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.huffie.top&quot;</span>&gt;</span>点击我跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.huffie.top&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/Huffie.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;huffie.jpg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;tips&quot;</span>&gt;</span>页内锚点<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#tip&quot;</span>&gt;</span>跳转到页内锚点<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210311200746306.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="4-3-表格"><a href="#4-3-表格" class="headerlink" title="4.3 表格"></a>4.3 表格</h4><p><strong>（1）表格标签：</strong></p>
<table>
<thead>
<tr>
<th>表格</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;table&gt;</code></td>
<td>定义表格</td>
</tr>
<tr>
<td><code>&lt;caption&gt;</code></td>
<td>定义表格标题</td>
</tr>
<tr>
<td><code>&lt;th&gt;</code></td>
<td>定义表格的表头</td>
</tr>
<tr>
<td><code>&lt;tr&gt;</code></td>
<td>定义表格的行</td>
</tr>
<tr>
<td><code>&lt;td&gt;</code></td>
<td>定义表格单元</td>
</tr>
<tr>
<td><code>&lt;thead&gt;</code></td>
<td>定义表格的页眉</td>
</tr>
<tr>
<td><code>&lt;tbody&gt;</code></td>
<td>定义表格的主体</td>
</tr>
<tr>
<td><code>&lt;tfoot&gt;</code></td>
<td>定义表格的页脚</td>
</tr>
<tr>
<td><code>&lt;col&gt;</code></td>
<td>定义表格的列属性</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">caption</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210311200947290.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>（2）表格属性</strong></p>
<ol>
<li><p>边框属性：border    例：<code>&lt;table border=&quot;1&quot;&gt;</code></p>
</li>
<li><p>表格中的列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>单元格大小：cellpadding    例：<code>&lt;table border=&quot;1&quot; cellpadding=&quot;10&quot;&gt;</code></p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210311200823341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol start="4">
<li>单元格间距：cellspacing    例：<code>&lt;table border=&quot;1&quot; cellspacing=&quot;10&quot;&gt;</code></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210311200843792.png#pic_center" alt="在这里插入图片描述"></p>
<ol start="5">
<li>单元格背景颜色：bgcolor    例：<code>&lt;table border=&quot;1&quot; bgcolor=&quot;#cccccc&quot;&gt;</code></li>
<li>单元格背景图片：background    例：<code>&lt;table border=&quot;1&quot; background=&quot;huffie.jpg&quot;&gt;</code></li>
</ol>
<h3 id="五、HTML列表、块和布局"><a href="#五、HTML列表、块和布局" class="headerlink" title="五、HTML列表、块和布局"></a>五、HTML列表、块和布局</h3><h4 id="5-1-列表"><a href="#5-1-列表" class="headerlink" title="5.1 列表"></a>5.1 列表</h4><p><strong>（1）标签</strong></p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;ol&gt;</code></td>
<td>有序列表</td>
</tr>
<tr>
<td><code>&lt;ul&gt;</code></td>
<td>无序列表</td>
</tr>
<tr>
<td><code>&lt;li&gt;</code></td>
<td>列表项</td>
</tr>
<tr>
<td><code>&lt;dl&gt;</code></td>
<td>列表</td>
</tr>
<tr>
<td><code>&lt;dt&gt;</code></td>
<td>列表项</td>
</tr>
<tr>
<td><code>&lt;dd&gt;</code></td>
<td>描述</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210311201007413.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>（2）属性</strong></p>
<ol>
<li><p>无序列表</p>
<ul>
<li><p>标签：<code>&lt;ul&gt;</code>、<code>&lt;li&gt;</code></p>
</li>
<li><p>属性：实心圆disc、空心圆circle、方块square（默认是实心圆）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">&quot;square&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2021031120102870.png#pic_center" alt="在这里插入图片描述"></p>
<ol start="2">
<li><p>有序列表</p>
<ul>
<li><p>标签：<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code></p>
</li>
<li><p>属性：A、a、l、i（序号：默认是数字），start（开始位置：默认从1开始）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2021031120104485.png#pic_center" alt="在这里插入图片描述"></p>
<ol start="3">
<li><p>嵌套列表</p>
<ul>
<li>标签：<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code></li>
</ul>
</li>
<li><p>自定义列表</p>
<ul>
<li><p>标签：<code>&lt;dl&gt;</code>、<code>&lt;dt&gt;</code>、<code>&lt;dd&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Huffie<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Huffie<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Huffie<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210311201102444.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="5-2-块"><a href="#5-2-块" class="headerlink" title="5.2 块"></a>5.2 块</h4><ol>
<li><p>块元素</p>
<p>块元素在显示时，通常会以新行开始。如<code>&lt;h1&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;ul&gt;</code></p>
</li>
<li><p>内联元素</p>
<p>内联元素通常不会以新行开始。如<code>&lt;b&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code></p>
</li>
<li><p><code>&lt;div&gt;</code>元素</p>
<p><code>&lt;div&gt;</code>元素也被称为块元素，其主要是组合HTML元素的容器</p>
</li>
<li><p><code>&lt;span&gt;</code>元素</p>
<p><code>&lt;spac&gt;</code>元素是内联元素，可作为文本的容器</p>
</li>
</ol>
<h4 id="5-3-布局"><a href="#5-3-布局" class="headerlink" title="5.3 布局"></a>5.3 布局</h4><ol>
<li>使用<code>&lt;div&gt;</code>布局</li>
<li>使用<code>&lt;table&gt;</code>布局</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        </span></span><br><span class="line"><span class="css">        <span class="selector-id">#container</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: cornsilk;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        </span></span><br><span class="line"><span class="css">        <span class="selector-id">#heading</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: cyan;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        </span></span><br><span class="line"><span class="css">        <span class="selector-id">#content_menu</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">30%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: gold;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        </span></span><br><span class="line"><span class="css">        <span class="selector-id">#content_body</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">70%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: darkgray;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        </span></span><br><span class="line"><span class="css">        <span class="selector-id">#footing</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: darkslateblue;</span></span><br><span class="line"><span class="css">            <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;heading&quot;</span>&gt;</span>头部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content_menu&quot;</span>&gt;</span>内容菜单<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content_body&quot;</span>&gt;</span>内容主体<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footing&quot;</span>&gt;</span>内容底部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210311201119142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="六、HTML表单"><a href="#六、HTML表单" class="headerlink" title="六、HTML表单"></a>六、HTML表单</h3><ol>
<li><p>表单用于获取不同类型的用户输入</p>
</li>
<li><p>常用表单标签</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;form&gt;</code></td>
<td>表单</td>
</tr>
<tr>
<td><code>&lt;input&gt;</code></td>
<td>输入域</td>
</tr>
<tr>
<td><code>&lt;textarea&gt;</code></td>
<td>文本域</td>
</tr>
<tr>
<td><code>&lt;label&gt;</code></td>
<td>控制标签</td>
</tr>
<tr>
<td><code>&lt;fieldset&gt;</code></td>
<td>定义域</td>
</tr>
<tr>
<td><code>&lt;legend&gt;</code></td>
<td>域的标题</td>
</tr>
<tr>
<td><code>&lt;select&gt;</code></td>
<td>选择列表</td>
</tr>
<tr>
<td><code>&lt;optgroup&gt;</code></td>
<td>选项组</td>
</tr>
<tr>
<td><code>&lt;option&gt;</code></td>
<td>下拉列表中的选项</td>
</tr>
<tr>
<td><code>&lt;button&gt;</code></td>
<td>按钮</td>
</tr>
</tbody></table>
</li>
<li><p>常见表单</p>
<ul>
<li><p>复选框：<code>&lt;input type=&quot;checkbox&quot;&gt;</code></p>
</li>
<li><p>单选框：</p>
<p><code>&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;</code></p>
<p>单选框的几个选项需要有相同的name</p>
<p>默认勾选要添加属性<code>checked=&quot;checked&quot;</code></p>
</li>
<li><p>下拉列表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>文本域：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span>文本内容<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建按钮：<code>&lt;input type=&quot;button&quot; value=&quot;按钮内容&quot;&gt;</code></p>
</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 输入框 --&gt;</span></span><br><span class="line">        账号:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 密码:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 复选框 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>已阅读并同意《用户使用须知》</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 单选框 --&gt;</span></span><br><span class="line">        请选择您的性别： 男 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span> 女 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 下拉列表 --&gt;</span></span><br><span class="line">        请选择居住地区</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 按钮 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;人机验证&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文本域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span>请填写个人简介<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    &lt;b/r&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2021031209433669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>ps.如果利用表格搭配表单，可以写出更规范的注册页面</p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>一文详解opencv摄像头数字识别</title>
    <url>/2021/09/09/116-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3opencv%E6%91%84%E5%83%8F%E5%A4%B4%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>&emsp;&emsp;本文的目标是实现<strong>识别摄像头图像中的数字</strong>。实际应用场景包括<strong>车牌号识别</strong>，部分竞赛的<strong>A4纸打印数字识别</strong>。项目实现结果如下，完整工程文件<a href="https://download.csdn.net/download/weixin_44543463/22349857">点此下载</a>：</p>
<p><img src="https://img-blog.csdnimg.cn/ecbade1b7bf44059a01ab11463b0f0e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>&emsp;&emsp;<strong>摄像头数字识别分为两个步骤：</strong></p>
<ol>
<li>提取图像中的ROI区域，如截取车牌的矩形区域，或截取A4纸的图像。</li>
<li>对ROI区域进行数字识别。</li>
</ol>
</blockquote>
<p>&emsp;&emsp;数字识别相对来说较为简单，先介绍数字识别的方法和原理。</p>
<h2 id="一、数字识别的两种方式"><a href="#一、数字识别的两种方式" class="headerlink" title="一、数字识别的两种方式"></a>一、数字识别的两种方式</h2><h4 id="1-1-轮廓提取法"><a href="#1-1-轮廓提取法" class="headerlink" title="1.1 轮廓提取法"></a>1.1 轮廓提取法</h4><p>&emsp;&emsp;实现思路为对ROI区域进行轮廓提取，然后将所有找到的轮廓与模板逐一匹配识别，相似度大于所设阈值，可视为识别成功。</p>
<p>&emsp;&emsp;寻找轮廓所使用的函数为findContours()，利用此函数将所有寻找到的轮廓保存在contours中，然后使用循环画出包围每一个轮廓的最小矩形。</p>
<p>&emsp;&emsp;利用每一个小矩形，提取图像中的每一个轮廓图像，将其与模板做差，如果差值越小，说明像素越接近，相似程度越高，以此来实现数字匹配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//轮廓提取主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//读取一张图像，转换为灰度图并进行二值化处理</span></span><br><span class="line">    Mat srcImage = <span class="built_in">imread</span>(<span class="string">&quot;E://Program//OpenCV//vcworkspaces//ogr_test//images//txt.jpg&quot;</span>);  <span class="comment">//读取图片</span></span><br><span class="line">    Mat dstImage, grayImage, binImage;</span><br><span class="line">    srcImage.<span class="built_in">copyTo</span>(dstImage);  <span class="comment">//将读取到的图片，深拷贝为dstImage</span></span><br><span class="line">    <span class="built_in">cvtColor</span>(srcImage, grayImage, COLOR_BGR2GRAY);                  <span class="comment">//转换灰度图</span></span><br><span class="line">    <span class="built_in">threshold</span>(grayImage, binImage, <span class="number">100</span>, <span class="number">255</span>, cv::THRESH_BINARY_INV);     <span class="comment">//转换二值图，设置阈值，高于100认为255</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//寻找轮廓</span></span><br><span class="line">    vector&lt;vector&lt;Point&gt;&gt; contours;  <span class="comment">//定义轮廓和层次结构</span></span><br><span class="line">    vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line">    <span class="built_in">findContours</span>(binImage, contours, hierarchy, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_NONE); <span class="comment">//寻找轮廓</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;Point&gt;&gt;::iterator It;</span><br><span class="line">    Rect a4rect[<span class="number">15</span>];	<span class="comment">//假设最多不会超过15个轮廓</span></span><br><span class="line">	<span class="keyword">for</span> (It = contours_rec.<span class="built_in">begin</span>(); It &lt; contours_rec.<span class="built_in">end</span>(); It++) &#123;                        <span class="comment">//画出包围数字的最小矩形</span></span><br><span class="line">		a4rect[i].x = (<span class="keyword">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">tl</span>().x;</span><br><span class="line">		a4rect[i].y = (<span class="keyword">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">tl</span>().y;</span><br><span class="line">		a4rect[i].width = (<span class="keyword">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">br</span>().x - (<span class="keyword">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">tl</span>().x;</span><br><span class="line">		a4rect[i].height = (<span class="keyword">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">br</span>().y - (<span class="keyword">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">tl</span>().y;</span><br><span class="line">		<span class="keyword">if</span> ((a4rect[i].height &gt; <span class="number">80</span>) &amp;&amp; (a4rect[i].width &gt; <span class="number">50</span>) &amp;&amp; (a4rect[i].height &lt; <span class="number">300</span>) &amp;&amp; (a4rect[i].width &lt; <span class="number">300</span>)) &#123;</span><br><span class="line">			<span class="built_in">rectangle</span>(dstImage, a4rect[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);	<span class="comment">//在原图像中用红框画出识别到的各轮廓</span></span><br><span class="line">			<span class="built_in">rectangle</span>(binImage, a4rect[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;dstImage&quot;</span>, dstImage);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将图像轮廓逐一与模板匹配</span></span><br><span class="line">	Mat num[<span class="number">15</span>];</span><br><span class="line">	<span class="keyword">int</span> matchingNum = <span class="number">0</span>;	<span class="comment">//匹配到的数字</span></span><br><span class="line">	<span class="keyword">int</span> matchingRate = <span class="number">0</span>;	<span class="comment">//相似率</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    	<span class="built_in">a4binImg</span>(a4rect[j]).<span class="built_in">copyTo</span>(num[j]);		<span class="comment">//提取包围数字的矩形区域至num[j]</span></span><br><span class="line">        <span class="built_in">imgMatch</span>(num[j], matchingRate, matchingNum);	<span class="comment">//数字匹配</span></span><br><span class="line">        <span class="keyword">if</span> (matchingRate &lt; <span class="number">400000</span>) &#123;</span><br><span class="line">        	cout &lt;&lt; <span class="string">&quot;识别数字：&quot;</span> &lt;&lt; matchingNum &lt;&lt; <span class="string">&quot;\t匹配率：&quot;</span> &lt;&lt;  matchingRate &lt;&lt; endl;</span><br><span class="line">			<span class="comment">//imwrite(to_string(matchingNum) + &quot;.jpg&quot;, num[j]);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;两图像相减之前，需要先制作一张模板，你可以自己在记事本里敲0-9的数字，截图，使用上面的函数imwrite出来一份模板。也可以到我的<a href="https://github.com/HuffieMa/digital_recongize/tree/master/images">github中下载</a>，其中0.jpg-9.jpg就是模板文件。</p>
<img src="https://img-blog.csdnimg.cn/589bc4c8da53485e9355ee656f6182a8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" width="60%">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有像素点和，用于求两图像相减后所得图像的所有像素之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPixelSum</span><span class="params">(Mat&amp; image)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; image.rows; row++) &#123;</span><br><span class="line">		uchar* current_pixel = image.ptr&lt;uchar&gt;(row);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; image.cols; col++) &#123;</span><br><span class="line">			a += *current_pixel++;	<span class="comment">//指针遍历像素点反转颜色</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板匹配函数，两图像做差</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">imgMatch</span><span class="params">(Mat&amp; image, <span class="keyword">int</span>&amp; rate, <span class="keyword">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">	Mat imgSub;</span><br><span class="line">	<span class="keyword">double</span> min = <span class="number">10e6</span>;</span><br><span class="line">	num = <span class="number">0</span>;</span><br><span class="line">	rate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		Mat templatimg = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/OGR/images/&quot;</span> + std::<span class="built_in">to_string</span>(i) + <span class="string">&quot;.jpg&quot;</span>, IMREAD_GRAYSCALE);</span><br><span class="line">		<span class="built_in">resize</span>(image, image, <span class="built_in">Size</span>(<span class="number">32</span>, <span class="number">48</span>), <span class="number">0</span>, <span class="number">0</span>, cv::INTER_LINEAR);	<span class="comment">//将两图像大小调至相同</span></span><br><span class="line">		<span class="built_in">resize</span>(templatimg, templatimg, <span class="built_in">Size</span>(<span class="number">32</span>, <span class="number">48</span>), <span class="number">0</span>, <span class="number">0</span>, cv::INTER_LINEAR);</span><br><span class="line">		<span class="built_in">absdiff</span>(templatimg, image, imgSub);</span><br><span class="line">		rate = <span class="built_in">getPixelSum</span>(imgSub);</span><br><span class="line">		<span class="keyword">if</span> (rate &lt; min) &#123;</span><br><span class="line">			min = rate;</span><br><span class="line">			num = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-行列扫描法"><a href="#1-2-行列扫描法" class="headerlink" title="1.2 行列扫描法"></a>1.2 行列扫描法</h4><p>&emsp;&emsp;此方法主要参考<a href="https://blog.csdn.net/LTG01/article/details/50492556">opencv 数字识别详细教程</a>这篇文章，在此感谢LTG01大佬的无私分享。</p>
<p>&emsp;&emsp;<br>&emsp;&emsp;<strong>基本过程为：</strong></p>
<ol>
<li>将图像二值化处理，使数字部分为白色，其余部分为黑色。</li>
<li>对一个图像先<strong>逐行扫描求和</strong>，如果第一行像素和为0，则继续向下扫描，直到碰到像素和不为0的行，将行数记下来，此为数字的顶部。</li>
<li>继续向下扫描，此时会从上到下逐渐扫描数字所在的每一行，当行像素和再次为0时，再将行数记录下来，代表已经到了数字的底部，将顶部与底部之间的区域截取出来。</li>
<li>，对截取出来的图像进行<strong>逐列扫描求和</strong>，过程同上，记录出数字的左右列号，根据左右列号即可从刚才截取出的图像中，取出包含数字的最小图像。</li>
<li>利用此最小图像与模板匹配。</li>
</ol>
<img src="https://img-blog.csdnimg.cn/811b7cbf4bf54a9ba146530119edd226.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" width="60%">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//读取图像并进行二值化处理</span></span><br><span class="line">	Mat src = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/ogr_test/images/txt.jpg&quot;</span>,IMREAD_GRAYSCALE);</span><br><span class="line">    Mat grayImage;					<span class="comment">//定义Mat对象用于存储每一帧数据</span></span><br><span class="line">    <span class="built_in">threshold</span>(src, grayImage, <span class="number">100</span>, <span class="number">255</span>, THRESH_BINARY_INV);     <span class="comment">//转换二值图，设置阈值，高于50认为255</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;grayimg&quot;</span>, grayImage);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//进行行列扫描</span></span><br><span class="line">    Mat leftImg, rightImg, topImg, bottomImg;</span><br><span class="line">    <span class="keyword">int</span> topRes = <span class="built_in">cutTop</span>(grayImage, topImg, bottomImg);	<span class="comment">//对二值图像逐行扫描，获得行像素之和&gt;0的部分topImg，以及剩余部分bottomImg</span></span><br><span class="line">    <span class="keyword">int</span> matchNum = <span class="number">-1</span>, matchRate = <span class="number">10e6</span>;</span><br><span class="line">	<span class="keyword">while</span> (topRes == <span class="number">0</span>)		<span class="comment">//当仍存在行像素和&gt;0的部分时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> leftRes = <span class="built_in">cutLeft</span>(topImg, leftImg, rightImg);	<span class="comment">//对行像素之和&gt;0的部分topImg逐列扫描，获得列像素之和&gt;0的部分leftImg，以及剩余部分rightImg</span></span><br><span class="line">        <span class="keyword">while</span> (leftRes == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">imgMatch</span>(leftImg, matchNum, matchRate);	<span class="comment">//数字识别</span></span><br><span class="line">			<span class="comment">//getSubtract(topImg);</span></span><br><span class="line">            <span class="built_in">imshow</span>(<span class="string">&quot;num&quot;</span>, leftImg);</span><br><span class="line">            <span class="keyword">if</span> (matchRate &lt; <span class="number">300000</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;识别数字：&quot;</span> &lt;&lt; matchNum &lt;&lt; <span class="string">&quot;\t\t匹配度：&quot;</span> &lt;&lt; matchRate &lt;&lt; endl;</span><br><span class="line">                <span class="comment">//imwrite(to_string(matchingNum) + &quot;.jpg&quot;, num[j]);</span></span><br><span class="line">            &#125;</span><br><span class="line">			Mat srcTmp = rightImg.<span class="built_in">clone</span>();</span><br><span class="line">            leftRes = <span class="built_in">cutLeft</span>(srcTmp, leftImg, rightImg);	<span class="comment">//对剩余部分rightImg继续逐列扫描</span></span><br><span class="line">        &#125;</span><br><span class="line">        Mat srcTmp = bottomImg.<span class="built_in">clone</span>();</span><br><span class="line">        topRes = <span class="built_in">cutTop</span>(srcTmp, topImg, bottomImg);			<span class="comment">//对剩余部分bottomImg继续逐行扫描</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">destroyAllWindows</span>();;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;有关扫描法识别数字的完整代码见我的<a href="https://github.com/HuffieMa/digital_recongize/tree/scan">Github的scan分支</a>。</p>
<h2 id="二、提取图像中的ROI区域"><a href="#二、提取图像中的ROI区域" class="headerlink" title="二、提取图像中的ROI区域"></a>二、提取图像中的ROI区域</h2><p>&emsp;&emsp;提取ROI区域的步骤如下：</p>
<ol>
<li>读取摄像头每一帧图像</li>
<li>对图像进行二值化处理</li>
<li>对图像进行形态学处理</li>
<li>设置限制条件寻找目标区域，并框选（这一步是重点）</li>
</ol>
<h4 id="2-1-读取摄像头图像"><a href="#2-1-读取摄像头图像" class="headerlink" title="2.1 读取摄像头图像"></a>2.1 读取摄像头图像</h4><p>&emsp;&emsp;摄像头的读取原理在之前的文章中已有介绍<a href="https://blog.csdn.net/weixin_44543463/article/details/119054844">《摄像头视频的读取与存储》</a>。主要使用函数为 <code>capture.read()</code>，此函数用于捕获视频的每一帧，并返回刚刚捕获的帧。示例程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;	<span class="comment">//创建VideoCapture类，打开电脑默认摄像头传参0，如果有外置摄像头参数为1</span></span><br><span class="line">    <span class="keyword">int</span> frame_width = capture.<span class="built_in">get</span>(CAP_PROP_FRAME_WIDTH);	<span class="comment">//获取摄像头的宽、高、帧数、FPS</span></span><br><span class="line">    <span class="keyword">int</span> frame_height = capture.<span class="built_in">get</span>(CAP_PROP_FRAME_HEIGHT);</span><br><span class="line">    Mat frame;					<span class="comment">//定义Mat对象用于存储每一帧数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (capture.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">        capture.<span class="built_in">read</span>(frame);	<span class="comment">//逐帧读取视频</span></span><br><span class="line">        <span class="comment">//flip(frame, frame, 1);	//将读取的视频左右反转</span></span><br><span class="line">        <span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;	<span class="comment">//如果视频结束或未检测到摄像头则跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Video&quot;</span>, frame);	<span class="comment">//每次循环显示一帧图像，frame就是每帧图像</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> k = <span class="built_in">waitKey</span>(<span class="number">333</span>);	<span class="comment">//两帧读取的间隔时间</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;			<span class="comment">//按下q键退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    capture.<span class="built_in">release</span>();			<span class="comment">//释放视频</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/df626d0de1eb4df4ae1440a60023d155.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" width="70%">

<h4 id="2-2-对图像进行二值化处理"><a href="#2-2-对图像进行二值化处理" class="headerlink" title="2.2 对图像进行二值化处理"></a>2.2 对图像进行二值化处理</h4><p>&emsp;&emsp;通过每个像素的颜色分量将图片进行二值化。正常曝光情况下<strong>A4纸的BGR均为215左右</strong>，<strong>车牌的颜色信息大约为B=138，G=63，R=23</strong>。但是在不同环境下颜色信息可能会有偏差，因此需要将条件在一定程度上放宽，再通过其他一些条件来准确查找目标区域。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图像二值化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryProc</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> pixelB, pixelG, pixelR;  <span class="comment">//记录各通道值</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> DifMax = <span class="number">40</span>;             <span class="comment">//基于颜色区分的阈值设置</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> WhiteMax = <span class="number">50</span>;		   <span class="comment">//判断白色</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> B = <span class="number">215</span>, G = <span class="number">215</span>, R = <span class="number">215</span>; <span class="comment">//各通道的阈值设定，针对与A4纸</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; image.rows; i++)   <span class="comment">//通过颜色分量将图片进行二值化处理</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; image.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			pixelB = image.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>]; <span class="comment">//获取图片各个通道的值</span></span><br><span class="line">			pixelG = image.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>];</span><br><span class="line">			pixelR = image.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((<span class="built_in">abs</span>(B - pixelB) &lt; DifMax) &amp;&amp; (<span class="built_in">abs</span>(G - pixelG) &lt; DifMax) &amp;&amp; (<span class="built_in">abs</span>(R - pixelR) &lt; DifMax) &amp;&amp; <span class="built_in">abs</span>(pixelB - pixelG) &lt; WhiteMax &amp;&amp; <span class="built_in">abs</span>(pixelG - pixelR) &lt; WhiteMax &amp;&amp; <span class="built_in">abs</span>(pixelB - pixelR) &lt; WhiteMax)</span><br><span class="line">			&#123;                                           <span class="comment">//将各个通道的值和各个通道阈值进行比较</span></span><br><span class="line">				image.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = <span class="number">255</span>;     <span class="comment">//符合颜色阈值范围内的设置成白色</span></span><br><span class="line">				image.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">				image.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				image.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = <span class="number">0</span>;        <span class="comment">//不符合颜色阈值范围内的设置为黑色</span></span><br><span class="line">				image.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">				image.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/57af58c3907a42278cb0adc81e2642a2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-3-形态学处理"><a href="#2-3-形态学处理" class="headerlink" title="2.3 形态学处理"></a>2.3 形态学处理</h4><p>&emsp;&emsp;可以看出二值画处理后已经比较明显完整的显示出A4纸区域，但是仍然存在一些噪点，此时进行形态学处理，以消除这些噪点干扰。对图像<strong>先膨胀再腐蚀</strong>，可以填充细小空间，连接临近物体和平滑边界。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形态学处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">morphTreat</span><span class="params">(Mat&amp; binImg)</span> </span>&#123;</span><br><span class="line">	Mat BinOriImg;     <span class="comment">//形态学处理结果图像</span></span><br><span class="line">	Mat element = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>)); <span class="comment">//设置形态学处理窗的大小</span></span><br><span class="line">	<span class="built_in">GaussianBlur</span>(binImg, binImg, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">	<span class="built_in">dilate</span>(binImg, binImg, element);     <span class="comment">//进行多次膨胀操作</span></span><br><span class="line">	<span class="built_in">dilate</span>(binImg, binImg, element);</span><br><span class="line">	<span class="built_in">dilate</span>(binImg, binImg, element);</span><br><span class="line">	<span class="built_in">dilate</span>(binImg, binImg, element);</span><br><span class="line">	<span class="built_in">dilate</span>(binImg, binImg, element);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">erode</span>(binImg, binImg, element);      <span class="comment">//进行多次腐蚀操作</span></span><br><span class="line">	<span class="built_in">erode</span>(binImg, binImg, element);</span><br><span class="line">	<span class="built_in">erode</span>(binImg, binImg, element);</span><br><span class="line">	<span class="built_in">erode</span>(binImg, binImg, element);</span><br><span class="line">	<span class="built_in">erode</span>(binImg, binImg, element);</span><br><span class="line">	<span class="comment">//imshow(&quot;形态学处理后&quot;, BinOriImg);        //显示形态学处理之后的图像</span></span><br><span class="line">	<span class="built_in">cvtColor</span>(binImg, binImg, CV_BGR2GRAY);   <span class="comment">//将形态学处理之后的图像转化为灰度图像</span></span><br><span class="line">	<span class="built_in">threshold</span>(binImg, binImg, <span class="number">100</span>, <span class="number">255</span>, THRESH_BINARY); <span class="comment">//灰度图像二值化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;矩形窗的大小与膨胀腐蚀的次数会影响处理结果，处理完的结果大致如下。</p>
<img src="https://img-blog.csdnimg.cn/d07134964f12426f972d3fcecc1ba1b9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" width="70%">


<h4 id="2-4-设置限制条件寻找目标区域"><a href="#2-4-设置限制条件寻找目标区域" class="headerlink" title="2.4 设置限制条件寻找目标区域"></a>2.4 设置限制条件寻找目标区域</h4><p>&emsp;&emsp;经过形态学处理，图像中已经可以明显看到A4纸所在的区域，但是图像中仍然不可避免存在其他与A4纸颜色接近的物体，在这里也会显示为白色。<strong>这时就需要我们根据A4纸区域的特点设置限制条件，从这些白色区域中找到代表A4纸所在的区域。</strong></p>
<p>&emsp;&emsp;在这里我使用的限制条件主要有以下几个：</p>
<ol>
<li>矩形面积在一定范围内</li>
<li>长宽比A4纸为1.414，一定程度放宽后作为限制条件</li>
<li>短边长度在一定范围内</li>
</ol>
<p>&emsp;&emsp;首先寻找图像中的轮廓，利用轮廓面积初步判断，对轮廓面积符合条件的进一步获取其外接矩形。计算此矩形的各个参数（顶点坐标、长宽、面积、倾斜角度等），然后根据限制条件对此矩形进行判别。<br>&emsp;&emsp;如果矩形区域符合条件，那么就需要将其截取出来，并根据先前计算的倾斜角度将A4纸图像摆正，便于后续对其中的数字进行识别。旋转图像的函数需要一些数学知识，旋转前后的图像的长宽有一定函数关系。（h’、w’为旋转后图像高、宽）</p>
<img src="https://img-blog.csdnimg.cn/db916a18a642404c8d9f998e710ec62f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" width="50%">

<img src="https://img-blog.csdnimg.cn/7288629a7d4244de804a52aaec6807f9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" width="50%">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图像旋转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateProc</span><span class="params">(Mat&amp; image, <span class="keyword">double</span> angle)</span> </span>&#123;</span><br><span class="line">	Mat M;</span><br><span class="line">	<span class="keyword">int</span> h = image.rows;</span><br><span class="line">	<span class="keyword">int</span> w = image.cols;</span><br><span class="line">	M = <span class="built_in">getRotationMatrix2D</span>(<span class="built_in">Point2f</span>(w / <span class="number">2</span>, h / <span class="number">2</span>), angle, <span class="number">1.0</span>);	<span class="comment">//定义变换矩阵M</span></span><br><span class="line">	<span class="keyword">double</span> cos = <span class="built_in">abs</span>(M.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>));	<span class="comment">//求cos值</span></span><br><span class="line">	<span class="keyword">double</span> sin = <span class="built_in">abs</span>(M.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>));	<span class="comment">//求sin值</span></span><br><span class="line">	<span class="keyword">int</span> nw = <span class="built_in">abs</span>(cos * w - sin * h) / <span class="built_in">abs</span>(cos * cos - sin * sin);		<span class="comment">//计算新的长、宽</span></span><br><span class="line">	<span class="keyword">int</span> nh = <span class="built_in">abs</span>(cos * h - sin * w) / <span class="built_in">abs</span>(cos * cos - sin * sin);</span><br><span class="line">	M.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>) += (nw / <span class="number">2</span> - w / <span class="number">2</span>);		<span class="comment">//计算新的中心</span></span><br><span class="line">	M.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>) += (nh / <span class="number">2</span> - h / <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">warpAffine</span>(image, image, M, <span class="built_in">Size</span>(nw, nh), INTER_LINEAR, <span class="number">0</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">	<span class="comment">//imshow(&quot;Rotation&quot;, dst);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************** 提取A4纸区域并识别数字 *****************************/</span></span><br><span class="line">		<span class="keyword">double</span> length, area, rectArea;     <span class="comment">//定义轮廓周长、面积、外界矩形面积</span></span><br><span class="line">		<span class="keyword">double</span> long2Short = <span class="number">0.0</span>;           <span class="comment">//长边/短边</span></span><br><span class="line">		Rect rect;           <span class="comment">//外界矩形</span></span><br><span class="line">		RotatedRect box;  <span class="comment">//外接矩形</span></span><br><span class="line">		CvPoint2D32f pt[<span class="number">4</span>];    <span class="comment">//矩形定点变量</span></span><br><span class="line">		Mat pts;    <span class="comment">//矩形定点变量</span></span><br><span class="line">		<span class="keyword">double</span> axisLong = <span class="number">0.0</span>, axisShort = <span class="number">0.0</span>;<span class="comment">//矩形的长边和短边</span></span><br><span class="line">		<span class="keyword">double</span> Length;     <span class="comment">//中间变量</span></span><br><span class="line">		<span class="keyword">float</span>  angle = <span class="number">0</span>;      <span class="comment">//记录倾斜角度</span></span><br><span class="line">		<span class="keyword">double</span> location_x = <span class="number">0.0</span>;</span><br><span class="line">		<span class="keyword">double</span> location_y = <span class="number">0.0</span>;</span><br><span class="line">		vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">		vector&lt;Vec4i&gt;hierarchy;</span><br><span class="line">		<span class="built_in">findContours</span>(binImg, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//绘制轮廓的最小外接矩形  </span></span><br><span class="line">			length = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);      <span class="comment">//获取轮廓周长</span></span><br><span class="line">			area = <span class="built_in">contourArea</span>(contours[i]);			<span class="comment">//获取轮廓面积</span></span><br><span class="line">			<span class="keyword">if</span> (area &gt; <span class="number">2000</span> &amp;&amp; area &lt; <span class="number">300000</span>)			<span class="comment">//矩形区域面积大小判断，符合条件的继续</span></span><br><span class="line">			&#123;</span><br><span class="line">				rect = <span class="built_in">boundingRect</span>(contours[i]);		<span class="comment">//计算矩形边界</span></span><br><span class="line">				box = <span class="built_in">minAreaRect</span>(contours[i]);		<span class="comment">//获取轮廓的矩形</span></span><br><span class="line">				<span class="built_in">boxPoints</span>(box, pts);				<span class="comment">//获取矩形四个顶点坐标（左上，右上，右下，左下）</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; pts.rows; row++) &#123;		<span class="comment">//从列表中依次读出四个顶点坐标</span></span><br><span class="line">					pt[row].x = pts.at&lt;uchar&gt;(row, <span class="number">0</span>);</span><br><span class="line">					pt[row].y = pts.at&lt;uchar&gt;(row, <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				angle = box.angle;              <span class="comment">//得到倾斜角度</span></span><br><span class="line">				<span class="keyword">if</span> (angle &gt; <span class="number">45</span>) &#123;					<span class="comment">//对于逆时针偏转的情况，倾斜角度为-(90-angle)</span></span><br><span class="line">					angle = angle - <span class="number">90</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				axisLong = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(pt[<span class="number">1</span>].x - pt[<span class="number">0</span>].x, <span class="number">2</span>) + <span class="built_in">pow</span>(pt[<span class="number">1</span>].y - pt[<span class="number">0</span>].y, <span class="number">2</span>));  <span class="comment">//计算长轴（勾股定理）</span></span><br><span class="line">				axisShort = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(pt[<span class="number">2</span>].x - pt[<span class="number">1</span>].x, <span class="number">2</span>) + <span class="built_in">pow</span>(pt[<span class="number">2</span>].y - pt[<span class="number">1</span>].y, <span class="number">2</span>)); <span class="comment">//计算短轴（勾股定理）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (axisShort &gt; axisLong)		<span class="comment">//如果短轴大于长轴，交换数据</span></span><br><span class="line">				&#123;</span><br><span class="line">					Length = axisLong;</span><br><span class="line">					axisLong = axisShort;</span><br><span class="line">					axisShort = Length;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				rectArea = axisLong * axisShort;	<span class="comment">//计算矩形的实际面积</span></span><br><span class="line"></span><br><span class="line">				long2Short = axisLong / axisShort;	<span class="comment">//计算长宽比</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 长宽比A4纸为1.414，利用长宽比、矩形面积和短边长度作为限制条件</span></span><br><span class="line">				<span class="keyword">if</span> (long2Short &gt; <span class="number">1</span> &amp;&amp; long2Short &lt; <span class="number">1.8</span>  &amp;&amp; rectArea &gt; <span class="number">5000</span> &amp;&amp; rectArea &lt; <span class="number">300000</span> &amp;&amp; axisShort &gt; <span class="number">50</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">rectangle</span>(frame, rect, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);		<span class="comment">//在摄像头图像中画出矩形区域</span></span><br><span class="line">					<span class="keyword">if</span> (rect.width &gt; <span class="number">100</span> &amp;&amp; rect.height &gt; <span class="number">100</span> &amp;&amp; axisShort&gt;<span class="number">100</span>) &#123;	<span class="comment">//缩小矩形范围，便于数字识别</span></span><br><span class="line">						rect.x += <span class="number">40</span>;</span><br><span class="line">						rect.y += <span class="number">40</span>;</span><br><span class="line">						rect.width -= <span class="number">40</span>;</span><br><span class="line">						rect.height -= <span class="number">40</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="built_in">imshow</span>(<span class="string">&quot;Video&quot;</span>, frame);					<span class="comment">//显示摄像头拍摄画面</span></span><br><span class="line">					location_x = rect.x + rect.width / <span class="number">2</span>;	<span class="comment">//获得矩形中心坐标，即A4纸中心坐标</span></span><br><span class="line">					location_y = rect.y + rect.height / <span class="number">2</span>;</span><br><span class="line">					Mat a4Img = <span class="built_in">frame</span>(rect);				<span class="comment">//提取A4纸区域</span></span><br><span class="line">					Mat a4binImg;</span><br><span class="line">					<span class="built_in">cvtColor</span>(a4Img, a4binImg, CV_BGR2GRAY);   <span class="comment">//将A4纸区域转化为灰度图像</span></span><br><span class="line">					<span class="built_in">threshold</span>(a4binImg, a4binImg, <span class="number">120</span>, <span class="number">255</span>, THRESH_BINARY); <span class="comment">//灰度图像二值化</span></span><br><span class="line">					<span class="built_in">colorReverse</span>(a4binImg);					<span class="comment">//颜色反转</span></span><br><span class="line">					<span class="built_in">rotateProc</span>(a4binImg, angle);		<span class="comment">//根据前所计算角度，对图像进行旋转，保证数字水平存在</span></span><br><span class="line">					<span class="built_in">imshow</span>(<span class="string">&quot;A4&quot;</span>, a4binImg);</span><br><span class="line"></span><br><span class="line">					<span class="comment">/*******************  数字识别方法  ********************/</span></span><br><span class="line">					</span><br><span class="line">					<span class="comment">//所获得的a4binImg就是经过二值化处理后的A4纸区域</span></span><br><span class="line">					<span class="comment">//使用上面介绍的数字识别方法即可级别</span></span><br><span class="line">					</span><br><span class="line">					<span class="comment">/*****************************************************/</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/8c02ea1502ae4d6293744e5662a63bb4.gif#pic_center" alt="请添加图片描述"><br><img src="https://img-blog.csdnimg.cn/c3c3f1b0a1ea4e909aa835b0dc19e8c9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS系统基本功能的使用详解（基本指令/节点/服务/启动文件/动态参数）</title>
    <url>/2021/09/16/119-ROS%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%E3%80%81%E8%8A%82%E7%82%B9%E3%80%81%E6%9C%8D%E5%8A%A1%E3%80%81%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E3%80%81%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、创建工作空间"><a href="#一、创建工作空间" class="headerlink" title="一、创建工作空间"></a>一、创建工作空间</h2><p><strong>1. 新建文件夹</strong><br>新建一个<code>catkin_ws</code>的文件夹，并在里面创建<code>src</code>子目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/dev/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws/src</span><br></pre></td></tr></table></figure>

<p><strong>2. 初始化工作空间</strong><br>在刚创建的src子目录中，使用如下命令创建工作空间，但此时工作空间中还没有任何功能包，只有CMakeLists.txt。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure>

<p><strong>3. 编译工作空间</strong><br>回到工作空间的顶层目录<code>catkin_ws</code>文件夹中，使用<code>catkin_make</code>命令执行编译。编译完成后使用<code>ll</code>指令可以看到生成了<code>build</code>和<code>devel</code>两个文件夹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>

<p><strong>4. 完成配置</strong><br>重新加载<code>setup.bash</code>文件，完成工作空间创建的最后一步配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure>
<p>其实如果你在<code>~/.bashrc</code>中加入了此命令行，就可以通过重启终端得到同样的效果，添加命令如下，其中<code>noetic</code>是我的ros系统的版本号，如果你的版本不同，务必更改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="二、创建与编译ROS功能包"><a href="#二、创建与编译ROS功能包" class="headerlink" title="二、创建与编译ROS功能包"></a>二、创建与编译ROS功能包</h2><p><strong>1. 创建功能包</strong><br>功能包可以通过手动方式创建，但为了方便，通常会使用<code>catkin_create_pkg</code>命令创建功能包，此命令的格式如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catkin_create_pkg [package_name] [depend1] [depend2] [depend3]</span><br></pre></td></tr></table></figure>
<p>其中的depend依赖项包括：</p>
<ul>
<li><code>std_msgs</code>：包含常见的消息类型，表示基本数据类型和其他基本的消息构造。</li>
<li><code>roscpp</code>：使用C++编写ROS的各种功能。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="built_in">cd</span> ~dev/catkin_ws/src</span><br><span class="line">catkin_create_pkg test_package std_msgs roscpp</span><br></pre></td></tr></table></figure>

<p><strong>2. 编译功能包</strong><br>回到<code>catkin_ws</code>文件夹下执行编译操作，如果没有报错，则说明功能包编译成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>

<h2 id="三、ROS的基本命令"><a href="#三、ROS的基本命令" class="headerlink" title="三、ROS的基本命令"></a>三、ROS的基本命令</h2><h3 id="3-1-节点"><a href="#3-1-节点" class="headerlink" title="3.1 节点"></a>3.1 节点</h3><p><strong>1. rosnode指令</strong><br>rosnode工具可以打印ROS节点的相关信息，具体命令如下：<br>| rosnode指令         | 作用                           |      |<br>| ——————- | —————————— | —- |<br>| <code>rosnode ping NODE</code> | 测试节点的连通性               |      |<br>| <code>rosnode list</code>      | 列出活动节点                   |      |<br>| <code>rosnode info NODE</code> | 输出此节点的信息               |      |<br>| <code>rosnode machine</code>   | 打印运行在特定计算机中的节点   |      |<br>| <code>rosnode kill NODE</code> | 结束节点进程                   |      |<br>| <code>rosnode cleanup</code>   | 将无法访问的节点的注册信息清除 |      |</p>
<p><strong>2. 运行节点</strong><br>首先使用<code>roscore</code>指令启动ros程序，然后再打开一个新的终端窗口执行接下来的操作。</p>
<p>我们可以使用<code>rosrun</code>指令运行一个节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure>
<p>节点成功运行后再次使用<code>rosnode list</code>可以看到正在运行的节点，使用<code>rosnode info /turtlesim</code>可以查看此节点的详细信息，包括发布（Publications）、订阅（Subscriptions）以及节点具有的服务（Services）等。</p>
<h3 id="3-2-主题"><a href="#3-2-主题" class="headerlink" title="3.2 主题"></a>3.2 主题</h3><p><strong>1. rostopic指令</strong><br>节点可以通过发布主题和订阅主题实现数据的传输，通过主题的消息传输不需要节点直接连接，一个主题可以有多个订阅者和多个发布者。要实现主题与节点之间的交互，可以使用rostopic指令。</p>
<table>
<thead>
<tr>
<th>rostopic指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>rostopic bw TOPIC</code></td>
<td>显示主题所用的带宽</td>
</tr>
<tr>
<td><code>rostopic echo TOPIC</code></td>
<td>将主题的消息输出到屏幕</td>
</tr>
<tr>
<td><code>rostopic find TOPIC</code></td>
<td>查找主题</td>
</tr>
<tr>
<td><code>rostopic hz TOPIC</code></td>
<td>显示主题发布频率</td>
</tr>
<tr>
<td><code>rostopic info TOPIC</code></td>
<td>输出主题详细信息</td>
</tr>
<tr>
<td><code>rostopic list TOPIC</code></td>
<td>列出活动主题</td>
</tr>
<tr>
<td><code>rostopic pubs TOPIC</code></td>
<td>将数据发布到主题</td>
</tr>
<tr>
<td><code>rostopic type TOPIC</code></td>
<td>输出主题的类型</td>
</tr>
</tbody></table>
<p><strong>2. 发布主题</strong><br>可以通过<code>rostopic list</code>列出当前节点的主题。通过echo参数可以打印节点发出的消息，如：<code>rostopic echo /turtle1/cmd_vel</code>。</p>
<p>此外，我们也可以直接通过<code>rostopic pub</code>发布主题，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line">rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- <span class="string">&#x27;&#123;linear: &#123;x: 1, y: 0, z: 0&#125;, angular: &#123;x: 0, y: 0, z: 1&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/1f6e2b4e95e546e3a7cc807a8c54ed63.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" width="40%">


<h3 id="3-3-服务"><a href="#3-3-服务" class="headerlink" title="3.3 服务"></a>3.3 服务</h3><p><strong>1. rosservice指令</strong><br>服务是节点之间相互通信的另一种方法，服务允许节点发送请求和接受响应。可以使用rosservice指令操作服务。</p>
<ul>
<li><code>roservice args /service</code>：输出服务参数</li>
<li><code>rosservice call /service</code>：根据命令行参数调用服务</li>
<li><code>rosservice find msgtype</code>：根据服务类型查询服务</li>
<li><code>rosservice info /service</code>：输出服务信息</li>
<li><code>rosservice list</code>：列出活动服务清单</li>
<li><code>rosservice type /service</code>：输出服务类型</li>
<li><code>rosservice uri /service</code>：输出ROSRPC URI服务</li>
</ul>
<p><strong>2. 服务的使用</strong><br>使用<code>rosservice list</code>可以列出所有的服务，使用<code>rosservice call [service] [args]</code>可以调用某个服务，例如<code>rosservice call /clear</code>可以清除海龟图上的线条。</p>
<p>此外，使用<code>rossrv show turtlesim/Spawn</code>可以查看/spawn服务的详细参数。<br><img src="https://img-blog.csdnimg.cn/88aaaecaf3484a70a386822ea71f4409.png#pic_center"><br>通过这些参数就可以调用/spawn服务创建第二只海龟。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosservice call /spawn 3 3 0.5 <span class="string">&quot;new_turtle&quot;</span></span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/ac96dba8d73e4f2b8993c5b3080d68b4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" width="40%">

<h3 id="3-4-参数服务器"><a href="#3-4-参数服务器" class="headerlink" title="3.4 参数服务器"></a>3.4 参数服务器</h3><p><strong>1. rosparam指令</strong><br>参数服务器存储了所有节点都可以访问的共享数据，可以通过rosparam指令管理参数服务器。<br>| rosparam指令                   | 作用             |<br>| —————————— | —————- |<br>| <code>rosparam set parameter value</code> | 设置参数值       |<br>| <code>rosparam get parameter</code>       | 获取参数值       |<br>| <code>rosparam load file</code>           | 从文件加载参数   |<br>| <code>rosparam dump file</code>           | 将参数保存至文件 |<br>| <code>rosparam delete parameter</code>    | 删除参数         |<br>| <code>rosparam list</code>                | 列出所有参数名   |</p>
<p><strong>2. 使用参数服务器</strong><br>以小海龟程序为例，通过rosparam list列出参数列表，可以看到背景background是turtlesim节点的参数，因此我们可以通过get指令获取参数值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam list</span><br><span class="line">rosparam get /turtlesim/background_g</span><br><span class="line">rosparam <span class="built_in">set</span> /turtlesim/background_g 200</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/33a8f5180f684a4da4aa13f558985ebf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" width="40%">

<h2 id="四、节点的创建与运行"><a href="#四、节点的创建与运行" class="headerlink" title="四、节点的创建与运行"></a>四、节点的创建与运行</h2><p>这一部分会以一个具体实验为例，通过创建一个talker和一个listener并实现两者之间的信息交流，进而介绍创建节点的方法。</p>
<h3 id="4-1-创建源文件"><a href="#4-1-创建源文件" class="headerlink" title="4.1 创建源文件"></a>4.1 创建源文件</h3><p>首先进入工作空间<code>~/dev/catkin_ws</code>文件夹中的功能包<code>test_package/src/</code>文件夹中，在这里创建两个cpp文件，分别作为消息的发送方和接收方。在这里我讲两个源文件分别命名<code>talker.cpp</code>和<code>listener.cpp</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//talker.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span>	<span class="comment">//包含ros节点的必要文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/String.h&quot;</span>	<span class="comment">//包含要使用的消息类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;talker&quot;</span>);	<span class="comment">//启动节点并设置名称</span></span><br><span class="line">        ros::NodeHandle n;	<span class="comment">//设置节点进程的句柄</span></span><br><span class="line">        ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(<span class="string">&quot;message&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//将节点设置成发布者，并设置主题名称为message，缓冲区1000个消息</span></span><br><span class="line">        <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//数据发送频率10HZ</span></span><br><span class="line">        <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())&#123;</span><br><span class="line">                std_msgs::String msg;</span><br><span class="line">                std::stringstream ss;</span><br><span class="line">                ss &lt;&lt; <span class="string">&quot;I&#x27;m talker node~~~&quot;</span>;</span><br><span class="line">                msg.data = ss.<span class="built_in">str</span>();		<span class="comment">//创建了一个消息变量</span></span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;%s&quot;</span>, msg.data.<span class="built_in">c_str</span>());	<span class="comment">//屏幕输出消息信息</span></span><br><span class="line">                chatter_pub.<span class="built_in">publish</span>(msg);	<span class="comment">//发布消息</span></span><br><span class="line">                ros::<span class="built_in">spinOnce</span>();			<span class="comment">//如果有订阅者出现，就会更新所有主题</span></span><br><span class="line">                loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//listener.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数，节点每收到一条消息都会调用此函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">messageCallback</span><span class="params">(<span class="keyword">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span>&#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;I am listener, I heard: [%s]&quot;</span>,msg-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;listener&quot;</span>);</span><br><span class="line">        ros::NodeHandle n;</span><br><span class="line">        ros::Subscriber sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;message&quot;</span>, <span class="number">1000</span>, messageCallback);</span><br><span class="line">        <span class="comment">//创建一个订阅者，从message主题获取消息，设置缓冲区1000个消息，处理消息的回调函数为messageCallback</span></span><br><span class="line">        ros::<span class="built_in">spin</span>();	<span class="comment">//消息回调处理，调用后不再返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-2-修改CMakeLists-txt"><a href="#4-2-修改CMakeLists-txt" class="headerlink" title="4.2 修改CMakeLists.txt"></a>4.2 修改CMakeLists.txt</h3><p>编辑<code>catkin_ws/src/test_package/</code>中的CMakeLists.txt，在最后加入如下的内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#include_directories(</span><br><span class="line">        include</span><br><span class="line">        $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 指定编译后可执行文件的名称</span><br><span class="line">add_executable(talker src/talker.cpp)</span><br><span class="line">add_executable(listener src/listener.cpp)</span><br><span class="line"># 定义目标的依赖文件</span><br><span class="line">add_dependencies(talker test_package_generate_messages_cpp)</span><br><span class="line">add_dependencies(listener test_package_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(talker $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">target_link_libraries(listener $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-3-编译节点"><a href="#4-3-编译节点" class="headerlink" title="4.3 编译节点"></a>4.3 编译节点</h3><p>回到工作空间根目录进行编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>

<p>如果出现<code>The dependency target does not exist.</code>的错误，将CMakeLists.txt开头的cmake版本改为2.8.3即可。</p>
<p>编译完成后需要设置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source ~/ros/tr3_6/devel/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h3 id="4-4-运行节点"><a href="#4-4-运行节点" class="headerlink" title="4.4 运行节点"></a>4.4 运行节点</h3><p>然后开始运行节点，首先运行roscore</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>
<p>然后再打开两个窗口分别运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun test_package example1_a</span><br><span class="line">rosrun test_package example1_b</span><br></pre></td></tr></table></figure>
<p>可以看到消息的接受和发送。<br><img src="https://img-blog.csdnimg.cn/077c1fff7021431c8deba12bae8d4abe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="五、服务的创建与使用"><a href="#五、服务的创建与使用" class="headerlink" title="五、服务的创建与使用"></a>五、服务的创建与使用</h2><p>本节将创建两个节点，分别作为服务器和客户端，通过服务的调用实现两个节点的数据传输，并实现数字求和的功能。</p>
<h3 id="5-1-创建msg文件"><a href="#5-1-创建msg文件" class="headerlink" title="5.1 创建msg文件"></a>5.1 创建msg文件</h3><p>使用服务之前，首先需要创建msg和srv文件，它们用于说明传输的数据类型和数据值。<br><strong>1. 首先创建msg文件</strong><br>在<code>test_package</code>功能包下创建<code>msg</code>文件夹，并在<code>msg</code>文件夹中创建一个新的文件<code>test_msg.msg</code>。在文件中输入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int32 num1</span><br><span class="line">int32 num2</span><br><span class="line">int32 num3</span><br></pre></td></tr></table></figure>
<p><strong>2. 编辑package.xml文件</strong><br>在<code>package.xml</code>文件中找到下面两行，取消这两行的注释<code>&lt;!-- --&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;build_depend&gt;message_generation&lt;/build_depend&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3. 编辑CMakeLists.txt文件</strong><br>打开功能包目录下的<code>CMakeLists.txt</code>文件。</p>
<p>找到<code>find_package()</code>，在其中加入<code>message_generation</code>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>找到如下的两段，取消注释，并将刚才创建的<code>test_message.msg</code>消息名称加入其中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">## Generate messages in the <span class="string">&#x27;msg&#x27;</span> <span class="function">folder</span></span><br><span class="line"><span class="function"><span class="title">add_message_files</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  FILES</span></span></span><br><span class="line"><span class="params"><span class="function">  test_msg.msg</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">## <span class="function">Generate added messages <span class="keyword">and</span> services with any dependencies listed here</span></span><br><span class="line"><span class="function"><span class="title">generate_messages</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DEPENDENCIES</span></span></span><br><span class="line"><span class="params"><span class="function">  std_msgs</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>4. 编译测试</strong><br>进行完以上的步骤后，使用下面的命令进行编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>编译完成后，要检查刚才创建的msg文件是否成功编译，使用<code>rosmsg show</code>指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosmsg show test_package/test_msg</span><br></pre></td></tr></table></figure>
<p>如果输出内容与<code>test_msg.msg</code>文件内的内容一致，说明编译正确。</p>
<h3 id="5-2-创建srv文件"><a href="#5-2-创建srv文件" class="headerlink" title="5.2 创建srv文件"></a>5.2 创建srv文件</h3><p><strong>1. 创建srv文件</strong><br>在<code>test_package</code>功能包下创建<code>srv</code>文件夹，并在<code>srv</code>文件夹中创建一个新的文件<code>test_srv.srv</code>。在文件中输入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int32 num1</span><br><span class="line">int32 num2</span><br><span class="line">int32 num3</span><br><span class="line">---</span><br><span class="line">int32 sum</span><br></pre></td></tr></table></figure>
<p><strong>2. 编辑package.xml文件</strong><br>在创建msg文件时已经完成了package.xml文件的编辑，这里不需要额外的修改。</p>
<p><strong>3. 编辑CMakeLists.txt</strong><br>找到<code>catkin_package</code>，将其注释取消，并加入正确的数据如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES test_package</span><br><span class="line">#  CATKIN_DEPENDS roscpp std_msgs</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">  CATKIN_DEPENDS message_runtime</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>取消<code>add_service_files</code>的注释，并添加刚创建的服务文件的名字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">## Generate services in the <span class="string">&#x27;srv&#x27;</span> <span class="function">folder</span></span><br><span class="line"><span class="function"><span class="title">add_service_files</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  FILES</span></span></span><br><span class="line"><span class="params"><span class="function">  test_srv.srv</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>4. 编译测试</strong><br>完成上面的文件创建和修改后，使用下面的命令进行编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>编译完成后，要检测服务文件编译是否正确，可以使用<code>rossrv show</code>指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rossrv show test_package/test_srv.srv</span><br></pre></td></tr></table></figure>
<p>如果打印内容与<code>test_srv.srv</code>文件内的内容一致，说明编译正确。</p>
<h3 id="5-3-创建-cpp源文件"><a href="#5-3-创建-cpp源文件" class="headerlink" title="5.3 创建.cpp源文件"></a>5.3 创建.cpp源文件</h3><p><strong>1. 创建源文件</strong><br>在功能包文件夹中的src目录下<code>catkin_ws/test_package/src</code>，创建两个<code>.cpp</code>文件，分别为<code>server.cpp</code>和<code>client.cpp</code>，分别作为服务器和客户端。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test_package/test_srv.h&quot;</span>	<span class="comment">//包含创建的srv文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对三个变量求和，并将计算结果发送给其他节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(test_package::test_srv::Request &amp;req, test_package::test_srv::Response &amp;res)</span></span>&#123;</span><br><span class="line">        res.sum = req.num1 + req.num2 + req.num3;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;request: num1=%ld, num2=%ld, num3=%ld&quot;</span>, (<span class="keyword">int</span>)req.num1, (<span class="keyword">int</span>)req.num2, (<span class="keyword">int</span>)req.num3);</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;sending back response: [%ld]&quot;</span>, (<span class="keyword">int</span>)res.sum);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;add_3_ints_server&quot;</span>);</span><br><span class="line">        ros::NodeHandle n;</span><br><span class="line">        <span class="comment">//创建服务&quot;add_3_ints&quot;的服务端，并在ROS中广播</span></span><br><span class="line">        ros::ServiceServer service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;add_3_ints&quot;</span>, add);</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to add 3 ints!&quot;</span>);</span><br><span class="line">        ros::<span class="built_in">spin</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test_package/test_srv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;add_3_ints_client&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(argc != <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;usage: add_3_ints_client num1 num2 num3&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ros::NodeHandle n;</span><br><span class="line">        <span class="comment">//以&quot;add_3_ints&quot;为名称创建客户端</span></span><br><span class="line">        ros::ServiceClient client = n.serviceClient&lt;test_package::test_srv&gt;(<span class="string">&quot;add_3_ints&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建srv文件的一个实例，并在其中加入需要发送的数据值</span></span><br><span class="line">        test_package::test_srv srv;</span><br><span class="line">        srv.request.num1 = <span class="built_in">atoll</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        srv.request.num2 = <span class="built_in">atoll</span>(argv[<span class="number">2</span>]);</span><br><span class="line">        srv.request.num3 = <span class="built_in">atoll</span>(argv[<span class="number">3</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用服务并发送数据，如果调用成功，服务端会返回true，否则返回false</span></span><br><span class="line">        <span class="keyword">if</span>(client.<span class="built_in">call</span>(srv))&#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Sum: %ld&quot;</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)srv.response.sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Failed to call service add_3_ints&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>2. 编辑CMakeLists.txt</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add_executable(server src/server.cpp)</span><br><span class="line">add_executable(client src/client.cpp)</span><br><span class="line"></span><br><span class="line">add_dependencies(server test_package_generate_messages_cpp)</span><br><span class="line">add_dependencies(client test_package_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(server $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">target_link_libraries(client $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-4-测试程序"><a href="#5-4-测试程序" class="headerlink" title="5.4 测试程序"></a>5.4 测试程序</h3><p>回到<code>catkin_ws</code>工作空间中，进行编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>

<p>编译完成后，先打开一个终端，运行<code>roscore</code>，然后再打开两个新终端窗口，分别运行如下代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun test_package server</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun test_package client 6 4 2</span><br></pre></td></tr></table></figure>
<p>可以看到服务端和客户端实现了消息的通信，完成了三个数字的求和计算。</p>
<p><img src="https://img-blog.csdnimg.cn/8c301a56d58c41f9a33f52a02d593c99.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="六、启动文件的配置"><a href="#六、启动文件的配置" class="headerlink" title="六、启动文件的配置"></a>六、启动文件的配置</h2><p>在前面，我们已经实现了节点的创建和使用，但是每个节点都需要打开不同的命令行窗口执行，如果节点数目更多，那么启动节点将会是一件非常麻烦的事情。</p>
<p>通过启动文件我们可以在命令行窗口实现启动多个节点，只需要运行后缀名为<code>.launch</code>的文件即可启动多个节点。</p>
<h3 id="6-1-创建-launch文件"><a href="#6-1-创建-launch文件" class="headerlink" title="6.1 创建.launch文件"></a>6.1 创建.launch文件</h3><p>首先在功能包内创建一个名为<code>launch</code>的文件夹，并在其中创建<code>test.launch</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscd test_package</span><br><span class="line">mkdir launch</span><br><span class="line"><span class="built_in">cd</span> launch</span><br><span class="line">vim test.launch</span><br></pre></td></tr></table></figure>

<p>在<code>test.launch</code>文件内输入如下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;talker&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;test_package&quot;</span> <span class="attr">type</span>=<span class="string">&quot;talker&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;listener&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;test_package&quot;</span> <span class="attr">type</span>=<span class="string">&quot;listener&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-启动节点"><a href="#6-2-启动节点" class="headerlink" title="6.2 启动节点"></a>6.2 启动节点</h3><p>上面编写的启动文件可以启动前文实验的<code>talker</code>和<code>listener</code>两个节点，启动命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roslaunch test_package test.launch</span><br></pre></td></tr></table></figure>
<p>系统会输出以下信息，说明启动成功。<br><img src="https://img-blog.csdnimg.cn/de6d8a001f384aceb50e973c736e3ee0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>使用<code>rosnode list</code>可以列出活动的节点，可以看到我们已经成功启动了<code>talker</code>和<code>listener</code>两个节点。<br><img src="https://img-blog.csdnimg.cn/f10806210a514c809307b447cde9822d.png#pic_center" alt="在这里插入图片描述"><br>如果想看到两个节点传递的信息，可以使用<code>rqt_console</code><br><img src="https://img-blog.csdnimg.cn/9ff1b204910148698e88e59d3588d59c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="七、动态参数的使用"><a href="#七、动态参数的使用" class="headerlink" title="七、动态参数的使用"></a>七、动态参数的使用</h2><p>一般情况下，我们编写一个节点时，只能以数据初始化节点内的变量，如果我们想要改变这些变量值，可以使用主题，服务或参数服务器，但这种方式无法在线动态更新，如果listener不主动查询，我们无法知道参数是否更新。有时我们需要在线动态更新参数，这时就需要使用动态参数。</p>
<h3 id="7-1-创建配置文件"><a href="#7-1-创建配置文件" class="headerlink" title="7.1 创建配置文件"></a>7.1 创建配置文件</h3><p>首先在功能包内新建一个名为<code>cfg</code>的文件夹，并在其内创建一个<code>test.cfg</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscd test_package</span><br><span class="line">mkdir cfg</span><br><span class="line"><span class="built_in">cd</span> cfg</span><br><span class="line">vim test.cfg</span><br></pre></td></tr></table></figure>
<p>在<code>test.cfg</code>内添加如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化ROS并导入参数生成器</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line">PACKAGE = <span class="string">&quot;test_package&quot;</span></span><br><span class="line"><span class="keyword">from</span> dynamic_reconfigure.parameter_generator_catkin <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化参数生成器，通过gen我们可以添加参数</span></span><br><span class="line">gen = ParameterGenerator()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入不同的参数类型并设置默认值、描述、取值范围等</span></span><br><span class="line"><span class="comment"># gen.add(name, type, level, description, default, min, max)</span></span><br><span class="line">gen.add(<span class="string">&quot;double_param&quot;</span>, double_t, <span class="number">0</span>, <span class="string">&quot;A double parameter&quot;</span>, <span class="number">.1</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">gen.add(<span class="string">&quot;str_param&quot;</span>, str_t, <span class="number">0</span>, <span class="string">&quot;A string parameter&quot;</span>, <span class="string">&quot;test_default_string&quot;</span>)</span><br><span class="line">gen.add(<span class="string">&quot;int_param&quot;</span>, int_t, <span class="number">0</span>, <span class="string">&quot;An Integer parameter&quot;</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">gen.add(<span class="string">&quot;bool_param&quot;</span>, bool_t, <span class="number">0</span>, <span class="string">&quot;A Boolean parameter&quot;</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">size_enum = gen.enum([gen.const(<span class="string">&quot;Low&quot;</span>, int_t, <span class="number">0</span>, <span class="string">&quot;Low is 0&quot;</span>), gen.const(<span class="string">&quot;Medium&quot;</span>, int_t, <span class="number">1</span>, <span class="string">&quot;Medium is 1&quot;</span>), gen.const(<span class="string">&quot;High&quot;</span>, int_t, <span class="number">2</span>, <span class="string">&quot;High is 2&quot;</span>), gen.const(<span class="string">&quot;Exlarge&quot;</span>, int_t, <span class="number">3</span>, <span class="string">&quot;Exlarge is 3&quot;</span>)], <span class="string">&quot;Select from the list&quot;</span>)</span><br><span class="line"></span><br><span class="line">gen.add(<span class="string">&quot;size&quot;</span>, int_t, <span class="number">0</span>, <span class="string">&quot;Select from the list&quot;</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, edit_method=size_enum)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成必要的文件并退出程序</span></span><br><span class="line">exit(gen.generate(PACKAGE, <span class="string">&quot;test_package&quot;</span>, <span class="string">&quot;test_&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于<code>test.cfg</code>是由ROS执行的可执行文件，因此我们需要改变文件权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod a+x test.cfg</span><br></pre></td></tr></table></figure>

<h3 id="7-2-修改CMakeLists-txt添加配置文件的编译"><a href="#7-2-修改CMakeLists-txt添加配置文件的编译" class="headerlink" title="7.2 修改CMakeLists.txt添加配置文件的编译"></a>7.2 修改CMakeLists.txt添加配置文件的编译</h3><p>打开<code>CMakeLists.txt</code>，找到<code>find_package</code>，在最后加入<code>dynamic_reconfigure</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">  dynamic_reconfigure</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>找到<code>generate_dynamic_reconfigure_options</code>，取消注释，并将内部的配置文件改为刚创建的配置文件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">## Generate dynamic reconfigure parameters in the <span class="string">&#x27;cfg&#x27;</span> <span class="function">folder</span></span><br><span class="line"><span class="function"><span class="title">generate_dynamic_reconfigure_options</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  cfg/test.cfg</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="7-3-创建节点"><a href="#7-3-创建节点" class="headerlink" title="7.3 创建节点"></a>7.3 创建节点</h3><p>接下来需要创建一个具有动态配置支持的新节点。</p>
<p>在<code>src</code>文件夹下创建一个新文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscd test_package</span><br><span class="line">vim src/dynamic_param.cpp</span><br></pre></td></tr></table></figure>
<p>在文件中写入如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dynamic_reconfigure/server.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;test_package/test_Config.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数将输出参数的新值，参数名称必须与test.cfg配置文件相同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(test_package::test_Config &amp;config, <span class="keyword">uint32_t</span> level)</span></span>&#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Reconfigure Request: %d %f %s %s %d&quot;</span>, config.int_param, config.double_param, config.str_param.<span class="built_in">c_str</span>(), config.bool_param?<span class="string">&quot;True&quot;</span>:<span class="string">&quot;False&quot;</span>, config.size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;test_dynamic_reconfigure&quot;</span>);</span><br><span class="line">        <span class="comment">//初始化服务器</span></span><br><span class="line">        dynamic_reconfigure::Server&lt;test_package::test_Config&gt; server;</span><br><span class="line">		<span class="comment">//向服务器发送回调函数，当服务器得到重新配置请求，会调用回调函数        </span></span><br><span class="line">        dynamic_reconfigure::Server&lt;test_package::test_Config&gt;::CallbackType f;</span><br><span class="line">        f = boost::<span class="built_in">bind</span>(&amp;callback, _1, _2);</span><br><span class="line">        server.<span class="built_in">setCallback</span>(f);</span><br><span class="line"></span><br><span class="line">        ros::<span class="built_in">spin</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h3 id="7-4-修改CMakeLists-txt添加节点的编译"><a href="#7-4-修改CMakeLists-txt添加节点的编译" class="headerlink" title="7.4 修改CMakeLists.txt添加节点的编译"></a>7.4 修改CMakeLists.txt添加节点的编译</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(dynamic_param src/dynamic_param.cpp)</span><br><span class="line"><span class="built_in">add_dependencies</span>(dynamic_param test_package_gencfg)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(dynamic_param $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="7-5-运行配置"><a href="#7-5-运行配置" class="headerlink" title="7.5 运行配置"></a>7.5 运行配置</h3><p>打开三个终端命令行窗口，分别运行如下的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun test_package dynamic_param</span><br><span class="line">rosrun rqt_reconfigure rqt_reconfigure</span><br></pre></td></tr></table></figure>
<p>执行完成后，会看到一个<code>rqt_reconfigure</code>窗口，在这个窗口中就可以动态的配置节点的参数，并且在调整参数时，可以看到命令行打印参数的改变。<br><img src="https://img-blog.csdnimg.cn/1f2a8933f74748ada76eeb1eaa1df4fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>数字化方法基础教程</title>
    <url>/2019/10/24/001-%E6%95%B0%E5%AD%97%E5%8C%96%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>如果觉得这篇太长，可到以下各单独blog<br>（1）<a href="https://blog.csdn.net/weixin_44543463/article/details/102727427">数字化方法基础（一）_基础操作与生成四面体（Chapter 1-3）</a><br>（2）<a href="https://blog.csdn.net/weixin_44543463/article/details/102727368">数字化方法基础（二）_点的投影（Chapter 4-5）</a><br>（3）<a href="https://blog.csdn.net/weixin_44543463/article/details/102727404">数字化方法基础（三）_导入本地模型（Chapter 6）</a><br>（4）<a href="https://blog.csdn.net/weixin_44543463/article/details/102727509">数字化方法基础（四）_矩阵操作（Chapter 7）</a></strong></p>
<p> ps.<a href="https://blog.csdn.net/weixin_44543463/article/details/102808548"><strong>常用函数请看这里</strong></a></p>
<p><strong>最近一次的代码（全）百度网盘：</strong><br><a href="https://pan.baidu.com/s/1cmQwrqrWzPwYdklb7snTkg">https://pan.baidu.com/s/1cmQwrqrWzPwYdklb7snTkg</a></p>
<h1 id="Chapter1-VisualStudio2010-Express如何创建新工程"><a href="#Chapter1-VisualStudio2010-Express如何创建新工程" class="headerlink" title="Chapter1  VisualStudio2010 Express如何创建新工程"></a>Chapter1  VisualStudio2010 Express如何创建新工程</h1><p>   1、新建一个win32 Console Application工程，选择建立一个空项目（带预编译头的也可以，只不过大多数人不太习惯）<img src="https://img-blog.csdnimg.cn/20191020160526371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Alt"><img src="https://img-blog.csdnimg.cn/20191020160700922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Alt"><br>   2、在左侧解决方案资源管理器中右击Source-add-New item，创建一个C++文件<img src="https://img-blog.csdnimg.cn/20191020160828359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Alt"><br>   3、这样就用VS2010创建好了一个简单的工程！</p>
<h1 id="Chapter2-SB-WinSRC的使用方法"><a href="#Chapter2-SB-WinSRC的使用方法" class="headerlink" title="Chapter2 SB-WinSRC的使用方法"></a>Chapter2 SB-WinSRC的使用方法</h1><p>1、解压压缩包，得到一个SB-WinSRC文件夹<br>2、打开SB-WinSrc\examples\projects\microsoft\chapt05\shinyjet文件夹中的shinyjet.vcproj文件，如出现以下对话框则一直Next到最后<br> <img src="https://img-blog.csdnimg.cn/20191020161143715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>3、打开shinyjet.cpp并进行编译（Build solution生成解决方案）<br> <img src="https://img-blog.csdnimg.cn/20191020161209539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>4、出现图示错误<br> <img src="https://img-blog.csdnimg.cn/20191020161233400.png#pic_center" alt="Huffie"><br>5、打开目录\SB-WinSrc\examples\src\shared，找到freeglut_static.lib文件，将它复制到之前打开的shinyjet文件夹内<br> <img src="https://img-blog.csdnimg.cn/2019102016125668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br> <img src="https://img-blog.csdnimg.cn/20191020161309892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>6、再次进行编译（Build solution生成解决方案），出现下图错误<br> <img src="https://img-blog.csdnimg.cn/20191020161335972.png#pic_center" alt="Huffie"><br>7、在左侧Solution Explorer（解决方案资源管理器）中右击shinyjet打开属性，将Linker-Input-忽略特定默认库一栏中输入LIBC.lib<br> <img src="https://img-blog.csdnimg.cn/20191020161356328.png#pic_center" alt="Huffie"><br>8、再次编译，成功！</p>
<h1 id="Chapter3-用OpenGL生成四面体"><a href="#Chapter3-用OpenGL生成四面体" class="headerlink" title="Chapter3  用OpenGL生成四面体"></a>Chapter3  用OpenGL生成四面体</h1><h2 id="已知3点求法向量"><a href="#已知3点求法向量" class="headerlink" title="已知3点求法向量"></a>已知3点求法向量</h2><p>1、具体思路为先根据已知3点做差求出两个向量，利用两个向量叉乘运算求出法向量，实现过程中尽量避免将所有代码集中到一个函数中，因为后续的操作（如投影点的计算）还需用到求法向量的函数，到时可直接调用。<br>2、已知2点求向量的函数十分简单，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getvector</span><span class="params">(<span class="keyword">float</span> a[<span class="number">3</span>],<span class="keyword">float</span> b[<span class="number">3</span>],<span class="keyword">float</span> vec[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">		vec[i] = a[i] - b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、调用两次上述函数即可获得两个向量，接下来要做的就是拿这两个向量进行叉乘，以得到法向量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数中的法向量n[3]是提前在函数外定义的，通过调用函数给n[3]赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crossproject</span><span class="params">(<span class="keyword">float</span> vec1[<span class="number">3</span>],<span class="keyword">float</span> vec2[<span class="number">3</span>],<span class="keyword">float</span> n[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n[<span class="number">0</span>] = vec1[<span class="number">1</span>]*vec2[<span class="number">2</span>]-vec1[<span class="number">2</span>]*vec2[<span class="number">1</span>];</span><br><span class="line">	n[<span class="number">1</span>] = vec1[<span class="number">2</span>]*vec2[<span class="number">0</span>]-vec1[<span class="number">0</span>]*vec2[<span class="number">2</span>];</span><br><span class="line">	n[<span class="number">2</span>] = vec1[<span class="number">0</span>]*vec2[<span class="number">1</span>]-vec1[<span class="number">1</span>]*vec2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、将上面两个函数简单封装一下如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数中的法向量n[3]是提前在函数外定义的，通过调用函数给n[3]赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">project</span><span class="params">(<span class="keyword">float</span> point1[<span class="number">3</span>],<span class="keyword">float</span> b[<span class="number">3</span>],<span class="keyword">float</span> c[<span class="number">3</span>],<span class="keyword">float</span> n[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> vec1[<span class="number">3</span>],vec2[<span class="number">3</span>];</span><br><span class="line">	getvector(a,b,vec1);</span><br><span class="line">	getvector(b,c,vec2);</span><br><span class="line">	crossproject(vec1,vec2,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、这样一个求法向量的函数就写好了，使用方法如下例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a[<span class="number">3</span>] = &#123;<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> b[<span class="number">3</span>] = &#123;<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> c[<span class="number">3</span>] = &#123;<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> n[<span class="number">3</span>];</span><br><span class="line">project(a,b,c,n);</span><br><span class="line"><span class="comment">//调用过project()函数之后，n[3]数组内的值即为法向量</span></span><br></pre></td></tr></table></figure>
<h2 id="生成四面体"><a href="#生成四面体" class="headerlink" title="生成四面体"></a>生成四面体</h2><p>1、使用OpenGL生成四面体的基本方法为，<strong>给定三个点和一个法向量</strong>，调用OpenDL的库函数，即可<strong>生成一个由这三点围成的三角形平面</strong>，<strong>四个三角形平面即可组成一个四面体</strong>。<br>2、将课上的shinyjet.cpp模板复制到src相应的文件夹中（\SB-WinSrc\examples\src\chapt05\shinyjet），然后回到project对应文件夹中，打开shinyjet.vcxproj工程，点击调试，成功后出来的应该为一个蓝绿色底的对话框。<br><img src="https://img-blog.csdnimg.cn/20191020165015109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br><img src="https://img-blog.csdnimg.cn/20191020165314158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>3、在RenderSenen()函数中的下图位置 <strong>写入glBegin()与glEnd()函数，并在二者之间插入画三角形的代码</strong>。<img src="https://img-blog.csdnimg.cn/20191020165836169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> rgfPoints4[<span class="number">12</span>] = &#123;<span class="number">-0.6f</span>,<span class="number">-0.6f</span>,<span class="number">-0.6f</span>,</span><br><span class="line">						<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,</span><br><span class="line">						<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,</span><br><span class="line">						<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="comment">//这是定义了一个长为12的数组，每3个元素代表一个点坐标，共4个点</span></span><br><span class="line">glColor3ub(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置要生成图形的颜色</span></span><br><span class="line">glBegin(GL_TRIANGLES);</span><br><span class="line"><span class="comment">//开始生成三角形</span></span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">6</span>);</span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">3</span>);</span><br><span class="line">DrawTriangle(rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">6</span>);</span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">6</span>,rgfPoints4+<span class="number">9</span>);</span><br><span class="line"><span class="comment">//↑函数功能：给定3个点生成一个三角形，调用4次生成4个三角形组成四面体</span></span><br><span class="line">   glEnd();</span><br><span class="line">   <span class="comment">//结束</span></span><br></pre></td></tr></table></figure>
<p>4、在这里，glColor3ub、glBegin，glEnd均是OpenGL的库函数，不需要我们定义，直接调用即可，<strong>需要我们写的是DrawTriangle函数</strong>，接下来我们就开始定义DrawTriangle()，前面已经提到，需要用<strong>3个点和一个法向量</strong>来确定一个平面，因此我们把第一节中生成法向量的函数复制到此文件的开头处，以便调用。<br><img src="https://img-blog.csdnimg.cn/20191020171413456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>5、画三角形的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawTriangle</span><span class="params">(<span class="keyword">float</span> a[<span class="number">3</span>],<span class="keyword">float</span> b[<span class="number">3</span>],<span class="keyword">float</span> c[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> n[<span class="number">3</span>];	<span class="comment">//定义一个数组用来存放法向量</span></span><br><span class="line">	project(a,b,c,n);	<span class="comment">//调用生成法向量的函数由a,b,c三点生成法向量n</span></span><br><span class="line">	glNormal3fv(n);</span><br><span class="line">	glVertex3fv(a);</span><br><span class="line">	glVertex3fv(b);</span><br><span class="line">	glVertex3fv(c);		<span class="comment">//此四行为利用用库函数，由法向量n和三个点abc生成一个平面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、完成上述步骤后，进行调试，即可得到一个四面体<br><img src="https://img-blog.csdnimg.cn/20191020171854203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"></p>
<h1 id="Chapter4-用OpenGL生成点的投影"><a href="#Chapter4-用OpenGL生成点的投影" class="headerlink" title="Chapter4  用OpenGL生成点的投影"></a>Chapter4  用OpenGL生成点的投影</h1><h2 id="计算点的投影的基本原理"><a href="#计算点的投影的基本原理" class="headerlink" title="计算点的投影的基本原理"></a>计算点的投影的基本原理</h2><p><img src="https://img-blog.csdnimg.cn/20191020192801898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"></p>
<h2 id="如何编写程序实现点的投影"><a href="#如何编写程序实现点的投影" class="headerlink" title="如何编写程序实现点的投影"></a>如何编写程序实现点的投影</h2><p>1、我们要实现点的投影就要知道投影点的坐标，由上一节可知，需要计算<strong>P0P1矢量</strong>（这个直接调用上一讲求向量的函数），<strong>en向量</strong>（需要写一个单位化函数），<strong>向量点乘</strong>的函数<br>2、单位化，即将向量各个坐标除以它的模，函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Normalize</span><span class="params">(<span class="keyword">float</span> n[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> length;</span><br><span class="line">	length = <span class="built_in">sqrt</span>(n[<span class="number">0</span>]*n[<span class="number">0</span>]+n[<span class="number">1</span>]*n[<span class="number">1</span>]+n[<span class="number">2</span>]*n[<span class="number">2</span>]);</span><br><span class="line">	<span class="comment">//求向量的模</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">		n[i] /= length;</span><br><span class="line">	<span class="comment">//函数执行过后n[3]即变成单位法向量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、进行向量点乘计算，并求N点坐标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProjectPointtoPoint</span><span class="params">(<span class="keyword">float</span> point[<span class="number">3</span>],<span class="keyword">float</span> a[<span class="number">3</span>],<span class="keyword">float</span> n[<span class="number">3</span>], <span class="keyword">float</span> ProjectPoint[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> vector_a_p[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">float</span> distance;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">		vector_a_p[i] = point[i] - a[i];</span><br><span class="line">	<span class="comment">//求面内一点与面外一点的向量,即P0P1</span></span><br><span class="line">	distance = vector_a_p[<span class="number">0</span>]*n[<span class="number">0</span>]+vector_a_p[<span class="number">1</span>]*n[<span class="number">1</span>]+vector_a_p[<span class="number">2</span>]*n[<span class="number">2</span>];</span><br><span class="line">	<span class="comment">//做点乘运算求点到平面距离，即图中|P0N|</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">		ProjectPoint[j] = point[j] - n[j]*distance;</span><br><span class="line">	<span class="comment">//N点坐标=P0坐标 - en * |P0N|</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、经过上述步骤之后就获得投影点坐标，然后就可调用库函数显示投影点，以下为显示一个点的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPoint</span><span class="params">(<span class="keyword">float</span> a[<span class="number">3</span>],<span class="keyword">float</span> b[<span class="number">3</span>],<span class="keyword">float</span> c[<span class="number">3</span>],<span class="keyword">float</span> point[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> n[<span class="number">3</span>];</span><br><span class="line">	project(a,b,c,n);</span><br><span class="line">	<span class="comment">//求abc平面法向量</span></span><br><span class="line">	Normalize(n);</span><br><span class="line">	<span class="comment">//单位化法向量</span></span><br><span class="line">	<span class="keyword">float</span> ProjectPoint[<span class="number">3</span>];</span><br><span class="line">	<span class="comment">//定义一个数组用来存放投影点坐标</span></span><br><span class="line">	ProjectPointtoPoint(point,a,n,ProjectPoint);</span><br><span class="line">	<span class="comment">//获得投影点坐标</span></span><br><span class="line">	glVertex3fv(ProjectPoint);</span><br><span class="line">	<span class="comment">//显示投影点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、同三角形，在RenderSenen()函数中的画三角形的glEnd()后面 <strong>再次写入glBegin()与glEnd()函数，并在二者之间插入显示点的代码</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> point[<span class="number">3</span>] = &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;;</span><br><span class="line"><span class="comment">//定义要投影的点</span></span><br><span class="line">glColor3ub(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//显示的点的颜色</span></span><br><span class="line">glPointSize(<span class="number">6.0f</span>);</span><br><span class="line"><span class="comment">//显示的点的大小</span></span><br><span class="line">glBegin(GL_POINTS);</span><br><span class="line"><span class="comment">//开始生成点</span></span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">6</span>,point);</span><br><span class="line"><span class="comment">//根据第一个面3个点，画第一个投影点</span></span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">3</span>,point);</span><br><span class="line">DrawPoint(rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">6</span>,point);</span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">6</span>,rgfPoints4+<span class="number">9</span>,point);</span><br><span class="line">glEnd();</span><br></pre></td></tr></table></figure>
<p>6、调试成功，显示如图<br><img src="https://img-blog.csdnimg.cn/20191020190700117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffir"></p>
<h1 id="Chapter5-如何使用VS2010的调试功能"><a href="#Chapter5-如何使用VS2010的调试功能" class="headerlink" title="Chapter5  如何使用VS2010的调试功能"></a>Chapter5  如何使用VS2010的调试功能</h1><p> 假如我写完程序调试后发现点没有显示，那么可以一步步调试，找出错误的地方。<br> 1、设置断点，在觉得可能出问题的代码处设置断点<br><img src="https://img-blog.csdnimg.cn/20191020190926284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>2、点击调试，下图红框内左面按键为单步执行，点一下执行一句话，如果遇到函数就进入函数内部执行函数体的第一句；右面的按键，点一下执行一句，在遇到函数是直接将整个函数执行完，即将函数也当成一句话。<br><img src="https://img-blog.csdnimg.cn/20191020191040439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>3、这里选择左面按键进入函数内部查看,黄色箭头表示当前执行到哪一句<br><img src="https://img-blog.csdnimg.cn/20191020191502654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>4、按第二个按键将这个函数执行完（但不要退出这个函数，否则函数内部的变量内存会被释放，无法查看变量的值）<br><img src="https://img-blog.csdnimg.cn/20191020191717196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>5、此时可以看到下面的监视窗口可以看到变量，单击+即可看到变量的值，图中展开的为第一个面的法向量和投影点坐标<br><img src="https://img-blog.csdnimg.cn/20191020191851486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>第二个面的法向量和投影点坐标<br><img src="https://img-blog.csdnimg.cn/20191020192033599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>第三个面<br><img src="https://img-blog.csdnimg.cn/20191020192148203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>第四个<br><img src="https://img-blog.csdnimg.cn/20191020192223839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"></p>
<h1 id="Chapter-6-导入本地模型"><a href="#Chapter-6-导入本地模型" class="headerlink" title="Chapter 6  导入本地模型"></a>Chapter 6  导入本地模型</h1><p>图形的生成需要消耗一定的时间，简单的模型可能没有什么感觉，但是在模型十分复杂时，模型的生成就需要相当长的时间，这是我们不能忍受的。因此，将模型保存为本地文件，使用时直接加载进来，这就变得十分必要了，本节主要讲如何将创建一个列表以及如何加载一个列表。</p>
<h2 id="如何创建一个列表"><a href="#如何创建一个列表" class="headerlink" title="如何创建一个列表"></a>如何创建一个列表</h2><p>列表的基本原理就是将之前写的<strong>从glPolygonMode、glBegin开始，到glEnd</strong>将这些代码<strong>用一行glCallList(DrawList)代替</strong>，其中DrawList内存放的就是之前生成四面体的代码了。glCallList就相当于把原来的四面体代码加载进来。<br>那如何将原来的四面体代码创建为一个列表供glCallList读取呢，过程十分简单，只需要按以下步骤即可：<br>1、在整个文件开头部分<strong>定义一个GLuint类型的全局变量</strong>（因为这个变量要在不同的函数使用，故须定义为全局变量）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GLuint DrawList;</span><br></pre></td></tr></table></figure>
<p>2、将RenderScene函数（就是之前写glbegin和glEnd的地方）中的<strong>有关三角形的代码全部用glCallList函数代替</strong><img src="https://img-blog.csdnimg.cn/20191022183312604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>3、在SetupRC函数中的最后<strong>新建列表</strong>，<strong>框架</strong>如下<br><img src="https://img-blog.csdnimg.cn/20191022190234315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>4、框架写好之后在图中注释位置<strong>插入画四面体的代码</strong>，插入后结果如下图<br><img src="https://img-blog.csdnimg.cn/20191022190538150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>5、至此一个存有四面体列表就新建好了，点击调试运行即可看到和以前一样的四面体。<br><img src="https://img-blog.csdnimg.cn/20191022190817973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"></p>
<h2 id="如何读取本地模型"><a href="#如何读取本地模型" class="headerlink" title="如何读取本地模型"></a>如何读取本地模型</h2><p>当我们需要读取本地文件中的模型时，如何操作呢<br>1、既然要读取文件中的模型，首先肯定要打开文件，在创建列表的代码之前插入如下三行代码<br><img src="https://img-blog.csdnimg.cn/20191022191736138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>（注意，if stream的括号内为文件的路径，其中的\都要写成\，因为在C语言字符串中，\表示转义，\\才表示一个\）<br>（注意，ifstream若要使用需要先在开头插入以下两行引入头文件同时设置环境）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<p>2、在定义几个数组用来存放一会要读取的数据<br><img src="https://img-blog.csdnimg.cn/20191022192655701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>3、然后，将之前画四面体的代码，更改为读取文件的代码，更换后的框架如下，其中in每次读取一串字符（到空格或换行停止），<strong>in &gt;&gt; String0指的是将读取到的字符存入String0中</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	DrawList = <span class="built_in">glGenLists</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">glNewList</span>(DrawList,GL_COMPILE);</span><br><span class="line">	<span class="built_in">glPolygonMode</span>(GL_BACK,GL_LINE);</span><br><span class="line">	<span class="comment">//在↓插入代码</span></span><br><span class="line">	in &gt;&gt; String0 &gt;&gt; String0;<span class="comment">//这就表示将两个字符串先后存入到String0中</span></span><br><span class="line">	<span class="comment">//因为如下图在读取到有用数据之前有两个没用的单词，需要读取两次</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">strcmp</span>(String0,<span class="string">&quot;end&quot;</span>))<span class="comment">//读到的字符串为end则退出循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		in &gt;&gt; Points[<span class="number">0</span>] &gt;&gt; Points[<span class="number">1</span>] &gt;&gt; Points[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//因为刚才已经读掉了前两个没用的字符串，因此直接读取三个坐标到Points里</span></span><br><span class="line">		in &gt;&gt; String0 &gt;&gt; Points[<span class="number">3</span>] &gt;&gt; Points[<span class="number">4</span>] &gt;&gt; Points[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//如下图读完第一组坐标后会遇到 vertex这个单词，需要读到垃圾桶（String0）里再读坐标</span></span><br><span class="line">		in &gt;&gt; String0 &gt;&gt; Points[<span class="number">6</span>] &gt;&gt; Points[<span class="number">7</span>] &gt;&gt; Points[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">		<span class="built_in">glColor3ub</span>(<span class="number">200</span>,<span class="number">200</span>,<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">glBegin</span>(GL_TRIANGLES);</span><br><span class="line">		<span class="built_in">DrawTriangle</span>(Points,Points+<span class="number">3</span>,Points+<span class="number">6</span>);</span><br><span class="line"><span class="comment">//这三行时画一个三角形，根据刚才读到的三个点</span></span><br><span class="line">		in &gt;&gt; String0;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在↑插入代码</span></span><br><span class="line">	<span class="built_in">glEndList</span>();</span><br></pre></td></tr></table></figure>
<p>（因为用到了strcmp函数，需要引入头文件#include&lt;string.h&gt;）<br><img src="https://img-blog.csdnimg.cn/20191022193921836.png" alt="Huffie"><br><img src="https://img-blog.csdnimg.cn/20191022194106777.png" alt="Huffie"><br>注意一下，计算机里的图像<strong>无论是平面还是曲面，都是由无数个三角形组成的</strong>，只不过三角形数量无比多时，我们看起来它就是一个曲面，Part1.TXT文件中也是，每读取到三个点就画一个三角形，许许多多个三角形就会组成一个立体图形。<br>4、至此，如何从文件中导入立体模型就完成了，点击调试，即可看到一个正方体<br>6、那么对于给定的STL文件如何读取？首先右击Part2.STL，用记事本打开，看到文件内容如下<br><img src="https://img-blog.csdnimg.cn/20191022200005791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>这看起来和之前差不多，只是他多给了一个法向量，没用的字符串多了一些而已，你可以不用他给的法向量，只读取三个坐标然后自己计算法向量，也可以读取法向量，这个时候 DrawTriangle函数就不需要计算法向量了，直接四行代码就ok，和之前一样，每一次in &gt;&gt; String0操作就读掉一个没用的字符串，自己编写代码就可实现将STL文件中的所有点全部读取出来<br>需要注意的是，<strong>每次循环结束</strong>的时候都要保证<strong>String内存放</strong>的是<strong>facet或者最后的endsolid</strong>这个单词，以保证循环可以正常退出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawTriangle</span><span class="params">(<span class="keyword">float</span> a[<span class="number">3</span>],<span class="keyword">float</span> b[<span class="number">3</span>],<span class="keyword">float</span> c[<span class="number">3</span>],<span class="keyword">float</span> n[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//float n[3];</span></span><br><span class="line">	<span class="comment">//project(a,b,c,n);</span></span><br><span class="line">	<span class="built_in">glNormal3fv</span>(n);</span><br><span class="line">	<span class="built_in">glVertex3fv</span>(a);</span><br><span class="line">	<span class="built_in">glVertex3fv</span>(b);</span><br><span class="line">	<span class="built_in">glVertex3fv</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS.如果程序出现错误，如何进行调试呢，首先在while循环里第一句前面设置断点，如下图<br><img src="https://img-blog.csdnimg.cn/2019102322202536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>然后点击单步执行第二个按钮<br><img src="https://img-blog.csdnimg.cn/20191023222126398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>每次循环读9个点,查看你读取到的点的值是否与文件中的坐标值一一对应，其中012对应第一行3个点，345对应第二行三个点，678对应第三行。<br><img src="https://img-blog.csdnimg.cn/20191023222235402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"></p>
<h1 id="Chapter-7-矩阵操作"><a href="#Chapter-7-矩阵操作" class="headerlink" title="Chapter 7 矩阵操作"></a>Chapter 7 矩阵操作</h1><h2 id="利用矩阵实现向量平移"><a href="#利用矩阵实现向量平移" class="headerlink" title="利用矩阵实现向量平移"></a>利用矩阵实现向量平移</h2><p>1、基本原理:如图，任意给定一个点的坐标（列向量）x,y,z。设置一个矩阵，利用矩阵的乘法运算即可将三个坐标进行平移<br>注意：过程中所设置的矩阵为单位阵的最后一列加上偏移量Tx，Ty，Tz。如下图，大家自己试一下矩阵乘法即可验证。<br><img src="https://img-blog.csdnimg.cn/20191024160119165.png" alt="Huffie"><br>2、在了解了如何将一个列向量进行平移之后，我们就可以编写程序进行向量的平移操作了，我们打开生成螺旋线的程序，注意到螺旋线是由许许多多点组成的，下面这个for循环就是每次生成一个点，我们只需要吧每个点的坐标向量进行平移即可使整个螺旋线平移。<br><img src="https://img-blog.csdnimg.cn/20191024160915725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70" alt="Huffie"><br>3、现在就开始写程序了，首先明确一下程序执行过程</p>
<p> <strong>1. 获得一个点的坐标存入P0数组内<br> 2. 设置一个矩阵Translation用来将坐标平移<br> 3. 将上述两个矩阵相乘得到的结果存入P1数组内，此即为平移后的点的坐标</strong></p>
<p>4、第一步，获得一个点的坐标存入P0数组内，这一步十分简单（注：除函数定义外，其余代码均在for循环内）<code>float P0[3] = &#123;x,y,z&#125;;</code><br>5、第二步，设置一个矩阵Translation用来将坐标平移，我们需要一个下面这样的矩阵<br><img src="https://img-blog.csdnimg.cn/2019102416270440.png" alt="Huffie"><br>如何操作呢，首先先初始化一个单位矩阵，然后将单位矩阵的最后一列赋值为需要偏移的量（我的代码十分简单粗暴，当然也可单独另写一个函数用于初始化一个单位矩阵）<br>注意：在OpenGL中，矩阵是按列数的，就是说我定义的I[16]中的前四个元素I[1]、I[2]、I[3]、I[4]实际上是矩阵的第一列，最后的I[12]、I[13]、I[14]、I[15]是矩阵的最后一列，而非上学期C语言中理解的最后一行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Translate</span><span class="params">(<span class="keyword">float</span> fx,<span class="keyword">float</span> fy,<span class="keyword">float</span> fz,<span class="keyword">float</span> Translation[<span class="number">16</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> I[<span class="number">16</span>] = &#123;<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>&#125;;<span class="comment">//定义一个四阶单位阵</span></span><br><span class="line">	I[<span class="number">12</span>] = fx;<span class="comment">//将第四列第一行的元素赋fx</span></span><br><span class="line">	I[<span class="number">13</span>] = fy;<span class="comment">//第四列第二行赋fy</span></span><br><span class="line">	I[<span class="number">14</span>] = fz;<span class="comment">//第四列第三行赋fz</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">16</span>;i++)</span><br><span class="line">		Translation[i] = I[i];<span class="comment">//将I数组的值循环赋给Translation数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样操作之后就获得了如上面图片中的数组了。<br>6、第三步，将上述两个矩阵相乘得到的结果存入P1数组内，此即为平移后的点的坐标，So我们要做的就是定义一个P1数组<code>float P1[3];</code>这十分简单，然后就是写一个矩阵乘法的运算，用Translation*P0，结果存入P1中。<br>实现代码如下，注意translation为4*4矩阵，P0为3*1矩阵，P1为4*1矩阵，<br>（为什么要四阶矩阵是因为我们需要矩阵运算平移，只有多加一行一列才能实现，而P0和P1我们实际只用前3个元素，）<br>故我们让P0的“第四个”元素默认为1，即下面代码中最后一项为1*translation[i+12]。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ApplyMatrix</span><span class="params">(<span class="keyword">float</span> *P0,<span class="keyword">float</span> *translation,<span class="keyword">float</span> *P1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;++i)</span><br><span class="line">		P1[i] = P0[<span class="number">0</span>]*translation[i]+P0[<span class="number">1</span>]*translation[i+<span class="number">4</span>]+P0[<span class="number">2</span>]*translation[i+<span class="number">8</span>]+translation[i+<span class="number">12</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、有了设置操作矩阵的函数Translate，和矩阵相乘的函数ApplyMatrix，我们就可以平移点了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">		y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// Specify the point and move the Z value up a little	</span></span><br><span class="line">		glVertex3f(x, y, z);</span><br><span class="line">		<span class="keyword">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;	<span class="comment">//定义P0存放平移之前的点</span></span><br><span class="line">		<span class="keyword">float</span> P1[<span class="number">3</span>];			<span class="comment">//定义P1存放平移之后的点</span></span><br><span class="line">		<span class="keyword">float</span> Translation[<span class="number">16</span>];	<span class="comment">//存放一个4*4的操作矩阵</span></span><br><span class="line"></span><br><span class="line">		Translate(<span class="number">0.0f</span>,<span class="number">30.0f</span>,<span class="number">0.0f</span>,Translation);	</span><br><span class="line">		<span class="comment">//设置操作矩阵为我们想要的格式（单位阵-&gt;最后一列赋值）</span></span><br><span class="line">		ApplyMatrix(P0,Translation,P1);</span><br><span class="line">		<span class="comment">//操作矩阵和P0点相乘，结果放在P1内</span></span><br><span class="line">		glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line">		<span class="comment">//显示平移之后的点</span></span><br><span class="line">		z += <span class="number">0.5f</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>以上为螺旋线平移步骤</p>
<h2 id="使用矩阵实现向量旋转"><a href="#使用矩阵实现向量旋转" class="headerlink" title="使用矩阵实现向量旋转"></a>使用矩阵实现向量旋转</h2><p>1、如何进行向量旋转<br>首先了解一下二维坐标的旋转，设一个向量a的坐标是（x,y），长度为r，与x轴正向夹角为α，则：<br>            xa = r cos α,<br>            ya = r sin α.<br>如果把向量旋转一个角度φ，则新的向量b的坐标是<br>xb = r cos(α + φ) = r cos α cos φ - r sin α sin φ,<br>yb = r sin(α + φ) = r sin α cos φ + r cos α sin φ.<br><img src="https://img-blog.csdnimg.cn/20191027172646860.png" alt="Huffie"><br>又因为xa = r cos α，ya = r sin α.所以容易看出来<br>xb = xa cos φ - ya sin φ,<br>yb = ya cos φ + xa sin φ.<br>而等式右边，又可写成两个矩阵的乘积<br><img src="https://img-blog.csdnimg.cn/20191027172755173.png" alt="Huffie"><br>由此可知，等式中<strong>由sin和cos组成的二阶方阵</strong>，就<strong>可以实现将向量(xa ya,)旋转为(xb,yb,)<strong>，暂且叫做二阶的旋转操作矩阵<br>由此推导至三阶，</strong>三阶的旋转操作矩阵为以下三种</strong>（分别为绕x，y，z轴旋转），大家带入检验一下即可知道，<br><img src="https://img-blog.csdnimg.cn/20191027172919386.png" alt="Huffie"><br>而为了与之前的平移操作统一，因此我们也把这个三阶旋转操作矩阵扩展为四阶的，如下<br><img src="https://img-blog.csdnimg.cn/20191027172943354.png" alt="Huffie"><br>2、如何编写函数实现向量旋转呢<br>由刚才的推导我们知道，用旋转操作矩阵左乘一个列向量即可实现向量的旋转操作<br>现在我们来编写函数，以绕x轴为例，我们先来看一下“主函数”，这是生成螺旋线的那个循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">		y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// Specify the point and move the Z value up a little	</span></span><br><span class="line">		glVertex3f(x, y, z);</span><br><span class="line">		<span class="keyword">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line">		<span class="keyword">float</span> P1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//定义一个数组（用于存放旋转操作矩阵）</span></span><br><span class="line"><span class="comment">//这里也可生成一个单位阵，那样就不用初始化为0了</span></span><br><span class="line">		Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line"><span class="comment">//给定一个角度（-90°），生成旋转操作矩阵</span></span><br><span class="line">		ApplyMatrix(P0,multi,P1);</span><br><span class="line"><span class="comment">//用旋转操作矩阵左乘P0，得到的结果P1即为旋转完成的向量坐标</span></span><br><span class="line">		glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//显示旋转后的坐标对应的点</span></span><br><span class="line">		z += <span class="number">0.5f</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们需要做的就是<strong>写一个函数</strong>，<strong>由参数（角度）生成一个旋转操作矩阵</strong>，这里需要注意的是，math.h头文件中有sin和cos的函数，直接sin（angle）即可调用，其中angle为弧度值，代码如下<br>（注意，函数里用到的PI是在开头宏定义的<code>#define PI 3.14159</code>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rotate_x</span><span class="params">(<span class="keyword">float</span> angle,<span class="keyword">float</span> *rotation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	angle = angle/<span class="number">180.0</span>*PI;</span><br><span class="line"><span class="comment">//将角度值转换为弧度值</span></span><br><span class="line">	rotation[<span class="number">5</span>] = <span class="built_in">cos</span>(angle);</span><br><span class="line">	rotation[<span class="number">6</span>] = <span class="built_in">sin</span>(angle);</span><br><span class="line">	rotation[<span class="number">9</span>] = -<span class="built_in">sin</span>(angle);</span><br><span class="line">	rotation[<span class="number">10</span>] = <span class="built_in">cos</span>(angle);</span><br><span class="line">	rotation[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	rotation[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//配置各个位置的数值，注意矩阵下标是竖着数的，第一行位置为0、4、8、12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们得到了旋转操作矩阵，经“主函数”调用即可实现向量的旋转</p>
<h2 id="如何让图形既平移又旋转"><a href="#如何让图形既平移又旋转" class="headerlink" title="如何让图形既平移又旋转"></a>如何让图形既平移又旋转</h2><p>一个很简单的思路就是<strong>先后调用平移和旋转操作的函数</strong>，像下面这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">		y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// Specify the point and move the Z value up a little	</span></span><br><span class="line">		glVertex3f(x, y, z);</span><br><span class="line">		<span class="keyword">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line">		<span class="keyword">float</span> P1[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">float</span> P2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">		Translate(<span class="number">0.0f</span>,<span class="number">60.0f</span>,<span class="number">0.0f</span>,Translation);</span><br><span class="line">ApplyMatrix(P0,Translation,P1);</span><br><span class="line"><span class="comment">//进行平移操作，P0平移后为P1</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line">ApplyMatrix(P1,Rotation,P2);</span><br><span class="line"><span class="comment">//进行旋转操作，P1旋转后为P2</span></span><br><span class="line"></span><br><span class="line">		glVertex3f(P2[<span class="number">0</span>], P2[<span class="number">1</span>], P2[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//最后输出P2的点即可</span></span><br><span class="line">		z += <span class="number">0.5f</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>但是这显然不是我们想要的，我们想一步就完成平移操作，不需要中间P1的出现，那么就需要<strong>将平移操作矩阵和旋转操作矩阵相乘，得到的仍为一个四阶矩阵，再拿这个新的四阶矩阵左乘列向量xy，即可将列向量既平移又旋转</strong>。<br><strong>如何理解？</strong><br>我们知道平移操作矩阵和旋转操作矩阵都是可逆矩阵（det Rx ≠ 0，det T ≠ 0）<br><img src="https://img-blog.csdnimg.cn/20191027173422645.png" alt="Huffie"><br>那么这两个矩阵都可以写成许多个初等矩阵的乘积，即<br>Rx = R1*R2*R3<em>……Rn * I<br>T = R1’*R2’*R3’……Rn’ * I<br>（其中R1，R1’……Rn，Rn’都为初等矩阵，初等矩阵还记得吧，刚学过的线代，只进行一次初等变换的矩阵；初等矩阵左乘一个矩阵即对他行变换）<br>那么我们知道平移操作为<br><img src="https://img-blog.csdnimg.cn/20191027173638419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>同理旋转操作也可以写成<br><img src="https://img-blog.csdnimg.cn/20191027173739886.png" alt="Huffie"><br>那么先平移，然后把平移得到的矩阵旋转就可以写成如下的形式<br><img src="https://img-blog.csdnimg.cn/20191027173802375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="Huffie"><br>又因为Rx = R1</em>R2<em>R3</em>……Rn，T = R1’<em>R2’</em>R3’……Rn’<br>所以 Rx<em>T</em>列向量 就代表把列向量平移又旋转<br>那么我们现在要做的就是写一个四阶矩阵的乘法函数，以获取Rx*T的结果，拿这结果左乘列向量即一步实现平移旋转。<br>四阶矩阵的乘法代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">float</span> *rotation,<span class="keyword">float</span> *translation,<span class="keyword">float</span> *tran)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)</span><br><span class="line">				tran[<span class="number">4</span>*i+j] += rotation[<span class="number">4</span>*k+j]*translation[<span class="number">4</span>*i+k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个是用16个元素的变量代表一个矩阵，下标表示比较麻烦，大家可以在纸上写一下<br>代码写法不唯一，也可以把它拆成四个循环单独写，当然也可以直接把每个元素赋值，赋值16次就完了<br>然后按照刚才的逻辑在“主函数”里调用一下就可以了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">		y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// Specify the point and move the Z value up a little	</span></span><br><span class="line">		glVertex3f(x, y, z);</span><br><span class="line">		<span class="keyword">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line">		<span class="keyword">float</span> P1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">		Translate(<span class="number">0.0f</span>,<span class="number">60.0f</span>,<span class="number">0.0f</span>,Translation);</span><br><span class="line"><span class="comment">//获得平移操作矩阵</span></span><br><span class="line">		<span class="keyword">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line"><span class="comment">//获得旋转操作矩阵</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> multi[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		mul(Rotation,Translation,multi);</span><br><span class="line"><span class="comment">//两矩阵相乘获得平移+旋转操作矩阵</span></span><br><span class="line">		ApplyMatrix(P0,multi,P1);</span><br><span class="line"><span class="comment">//用平移+旋转操作矩阵左乘P0即可得到被平移且旋转之后的矩阵P1</span></span><br><span class="line">		glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line">		z += <span class="number">0.5f</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>以上即利用矩阵实现向量的平移与旋转操作</p>
<h2 id="坐标系的旋转"><a href="#坐标系的旋转" class="headerlink" title="坐标系的旋转"></a>坐标系的旋转</h2><p><strong>1、目标</strong>：<br>给定一个向量（如(1,1,1)），将原坐标系旋转为以此向量为Z轴的坐标系。<br><strong>2、基本概念</strong>：<br>如图，左面的三阶方阵内每一列为新坐标轴的三个单位向量，用这个<strong>三阶方阵左乘一个原坐标系的点</strong>，即可<strong>将这个点坐标旋转为新坐标系的对应坐标</strong><br>由此，我们只需要生成一个左面的旋转坐标系的矩阵即可。<br><img src="https://img-blog.csdnimg.cn/20191029203029723.png" alt="Huffie"><br><strong>3、如何生成Ruvw矩阵</strong><br>法一：<br>（1）先单位化已知矢量z<br>（2）然后把已知矢量z中的其中一个坐标变为1，这样就获得了两个在同一平面的向量<br>（3）然后用这两个向量叉乘，得到的结果就是和已知矢量z垂直的矢量y<br>（4）然后再用已知矢量z叉乘刚获得的向量y，得到与这两个向量都垂直的向量x。<br>（5）如此，将得到的三个坐标轴矢量组合成的形式（u为新x轴，v为新y轴，w为新z轴）<br><img src="https://img-blog.csdnimg.cn/20191029203154309.png" alt="Huffie"><br>法二：知道给定矢量的三个坐标(Zx,Zy,Zz),则和这个矢量垂直的向量之一的坐标是(Zy,-Zx,0)，这样同样可以获得两个相互垂直的矢量，然后这俩矢量叉乘得到第三个矢量，即为三坐标轴。将得到的三个坐标轴矢量组合成的形式（u为新x轴，v为新y轴，w为新z轴）<br>（注：代表新坐标轴的三个矢量均需要单位化）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此为法二的代码，其中Rotation+4等地方用到了指针的技巧</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RotateCoor</span><span class="params">(<span class="keyword">float</span> *z,<span class="keyword">float</span> *Rotation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Rotation[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">	Rotation[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line">	Normalize(z);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">		Rotation[<span class="number">8</span>+i] = z[i];</span><br><span class="line">	Rotation[<span class="number">4</span>] = -z[<span class="number">1</span>];</span><br><span class="line">	Rotation[<span class="number">5</span>] = z[<span class="number">0</span>];</span><br><span class="line">	Normalize(Rotation+<span class="number">4</span>);</span><br><span class="line">	crossproject(z,Rotation+<span class="number">4</span>,Rotation);</span><br><span class="line">	Normalize(Rotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191029203612608.png" alt="在这里插入图片描述"><br>上图矩阵即为坐标系旋转操作矩阵，<strong>和之前平移与旋转一样</strong>，用<strong>这个矩阵×P0点</strong>，即可得到<strong>坐标轴旋转后的点P1</strong></p>
<h2 id="让图形显示在屏幕中心且绕中心转动"><a href="#让图形显示在屏幕中心且绕中心转动" class="headerlink" title="让图形显示在屏幕中心且绕中心转动"></a>让图形显示在屏幕中心且绕中心转动</h2><p>1.首先我们要知道，OpenGL生成的对话框的长和宽是可以设置的，我们需要让对话框的宽高比与我们要生成的图像的宽高比相同，并且对话框要比图像稍大一些。<br>2、具体如下思路：<br>设模型的高为ModelHeight，宽为ModelWidth，生成的空间高为h，宽为w<br><strong>如果ModelHeight/h &gt; ModelWidth/w，说明对话框比较高（模型比较宽），因此要尽可能满足模型的宽</strong>，比如让<strong>对话框的宽为模型宽的2.5倍</strong>（让对话框稍大一些），则<strong>对话框的高就为 对话框的高/模型的高 * 模型的宽</strong>。<br>同理对话框比较扁也可以得到对称的结论，因此，用计算得到的对话框的宽和高就可生成一个合适的对话框。<br>3、如何编程更改对话框大小：<br>打开之前加载泵体的那个文件(chapt05\shinyjet)更改ChangeSize函数为以下形式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangeSize</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    GLfloat fAspect;</span><br><span class="line">    GLfloat lightPos[] = &#123; <span class="number">-50.f</span>, <span class="number">50.0f</span>, <span class="number">100.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent a divide by zero</span></span><br><span class="line">    <span class="keyword">if</span>(h == <span class="number">0</span>)</span><br><span class="line">        h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set Viewport to window dimensions</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset coordinate system</span></span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fAspect = (GLfloat) w / (GLfloat) h;</span><br><span class="line">	<span class="comment">// Establish clipping volume (left, right, bottom, top, near, far)</span></span><br><span class="line">	<span class="comment">//aspectRatio = (GLfloat)w / (GLfloat)h;</span></span><br><span class="line"><span class="comment">//这之上都不用动</span></span><br><span class="line">	<span class="keyword">float</span> scale = <span class="number">2.5</span>;</span><br><span class="line"><span class="comment">//对话框与模型大小比例为2.5倍</span></span><br><span class="line">	<span class="keyword">float</span> ScaleHeight,ScaleWidth,ModelWidth,ModelHeight;</span><br><span class="line"><span class="comment">//定义对话框的宽高，模型的宽高</span></span><br><span class="line">	ModelWidth = PointMax[<span class="number">0</span>]-PointMin[<span class="number">0</span>];</span><br><span class="line">	ModelHeight = PointMax[<span class="number">1</span>]-PointMin[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//模型宽的计算可由模型上最右的点坐标减最左点的坐标</span></span><br><span class="line">	<span class="keyword">if</span>(w*ModelHeight &gt; h*ModelWidth)</span><br><span class="line">	&#123;<span class="comment">//当ModelHeight/h &gt; ModelWidth/w时，模型比较宽，对话框比较高</span></span><br><span class="line">		ScaleHeight = scale * ModelHeight;</span><br><span class="line"><span class="comment">//设置对话框的宽为模型宽的2.5倍</span></span><br><span class="line">		ScaleWidth =  scale * ModelHeight * w / h;</span><br><span class="line"><span class="comment">//对话框的高为 对话框的高/模型的高 * 模型的宽</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ScaleWidth =  scale * ModelWidth;</span><br><span class="line">		ScaleHeight = scale * ModelWidth * h / w;</span><br><span class="line">	&#125;</span><br><span class="line">	glOrtho(<span class="number">0.5</span> * (PointMax[<span class="number">0</span>] - PointMin[<span class="number">0</span>]) - <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">0</span>] - PointMin[<span class="number">0</span>]) + <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">1</span>] - PointMin[<span class="number">1</span>]) - <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">1</span>] - PointMin[<span class="number">1</span>]) + <span class="number">0.5</span> * ScaleWidth,<span class="number">-2.0</span>,<span class="number">2.0</span>);</span><br><span class="line"><span class="comment">//定出模型的中心坐标，下面代码就根据中心坐标生成一个与模型中心位置相同的对话框</span></span><br><span class="line"><span class="comment">//这之下都不用动</span></span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    </span><br><span class="line">    glLightfv(GL_LIGHT0,GL_POSITION,lightPos);</span><br><span class="line">    <span class="comment">//glTranslatef(0.0f, 0.0f, -150.0f);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>4、如何编程找出模型上对角线的两个点<br>将之前写过的读取文件里点的坐标的那个while循环中添加一部分内容，改成如下形式，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">		<span class="keyword">while</span>(<span class="built_in">strcmp</span>(String0,<span class="string">&quot;endsolid&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			in &gt;&gt; String0;</span><br><span class="line">			in &gt;&gt; n[<span class="number">0</span>] &gt;&gt; n[<span class="number">1</span>] &gt;&gt; n[<span class="number">2</span>];</span><br><span class="line">			in &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; Points[<span class="number">0</span>] &gt;&gt; Points[<span class="number">1</span>] &gt;&gt; Points[<span class="number">2</span>];</span><br><span class="line">			in &gt;&gt; String0 &gt;&gt; Points[<span class="number">3</span>] &gt;&gt; Points[<span class="number">4</span>] &gt;&gt; Points[<span class="number">5</span>];</span><br><span class="line">			in &gt;&gt; String0 &gt;&gt; Points[<span class="number">6</span>] &gt;&gt; Points[<span class="number">7</span>] &gt;&gt; Points[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//以下为新加内容，作用为找到对角线上的两个点，存到PointMin和PointMax里</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">float</span> * point = Points + <span class="number">3</span>;point &lt; Points + <span class="number">11</span>;point += <span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(Points[j]&lt;PointMin[j])</span><br><span class="line">					&#123;</span><br><span class="line">						PointMin[j] = Points[j];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(Points[j]&gt;PointMax[j])</span><br><span class="line">					&#123;</span><br><span class="line">						PointMax[j] = Points[j];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//以上为新加内容</span></span><br><span class="line">			glColor3ub(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line">			glBegin(GL_TRIANGLES);</span><br><span class="line">			DrawTriangle(Points,Points+<span class="number">3</span>,Points+<span class="number">6</span>,n);</span><br><span class="line">			glEnd();</span><br><span class="line">			in &gt;&gt; String0 &gt;&gt; String0&gt;&gt; String0;</span><br><span class="line">		&#125;</span><br><span class="line">（注意，因为PointMin和PointMax既在SetupRC函数里使用又在Changesize函数里使用，故需要定义为全局变量，如下<span class="keyword">float</span> PointMin[<span class="number">3</span>] = &#123;<span class="number">1.0e38</span>f,<span class="number">1.0e38</span>f,<span class="number">1.0e38</span>f&#125;;<span class="keyword">float</span> PointMax[<span class="number">3</span>] = &#123;<span class="number">1.0e-38</span>f,<span class="number">1.0e-38</span>f,<span class="number">1.0e-38</span>f&#125;;）</span><br></pre></td></tr></table></figure>
<p>5、现在看起来可以了，我们把对话框设置成了和模型等比例，对称中心重合，但还需要更改一个地方就是，我们生成的<strong>模型中心和我们旋转轴的中心不是重合的</strong>，我们如何实现按下键盘时，让模型绕原点转动，而不是绕其他轴运动。<br>具体思路就是，我们<strong>要让模型绕自己中心旋转，可以先把模型平移到坐标轴原点处（原点与模型中心重合），进行旋转，然后在平移回原来位置，这样看上去就是模型绕自己中心旋转了</strong>，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderScene</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	<span class="comment">// Clear the window with current clearing color</span></span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save the matrix state and do the rotations</span></span><br><span class="line">	glPushMatrix();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">	Translate(<span class="number">0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">	glRotatef(xRot,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">	glRotatef(yRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">	Translate(<span class="number">-0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">	glCallList(DrawList);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Restore the matrix state</span></span><br><span class="line">	glPopMatrix();</span><br><span class="line">	<span class="comment">// Display the results</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>经过修改这三个地方就实现了让模型能够正常的显示在屏幕中心且绕模型自己的中心转动</p>
<h1 id="Chapter-8-造小车"><a href="#Chapter-8-造小车" class="headerlink" title="Chapter 8 造小车"></a>Chapter 8 造小车</h1><h2 id="装配一个小车"><a href="#装配一个小车" class="headerlink" title="装配一个小车"></a>装配一个小车</h2><p>组装小车开始了<br>在学习本节内容之前，<strong>请先掌握装载泵体模型的相关操作</strong><br>1.原理部分：我们知道了如何将一个模型文件装载进来同时显示出来，主要步骤是<strong>先新建一个列表DrawList</strong>，然后<strong>将模型存入此列表中</strong>，最后在<strong>通过glCallList()函数召唤列表即可生成一个模型</strong>。现在我们要做的就是同时生成许多个模型，那么<strong>如何同时生成许多模型呢，只要新建许多列表，然后把它们一个一个召唤出来（glCallList）就可以了</strong>。<br>2.既然我们需要新建好多个列表，那么我们最好定义一个函数用于生成列表，不然一大段代码赋值五六遍可不是一般的长。把之前在SetupRC函数里的新建列表的代码移出来，稍加修改封装成一个函数。新建列表的代码如下说明一下，函数第一个参数是文件名，也就是””F:\Works\Practice\数字化方法\Shove\Shovel.STL”像这样的字符串，后面三个参数是RGB颜色，用于设置生成的模型的颜色，毕竟你也不想让整个小车变成一个颜色吧。最后一个参数是定义的列表变量的地址，或者说列表变量的指针<br>（注：为什么要用指针呢，我jo得这个可以参考上学期C++课上的内容，函数的形参只在函数体内有效，比如在主函数里定义了一个变量，把它传给一个函数并在函数内部改变它的值，主函数内的变量的值不会发生改变，因此只有把地址传过去才可以正常新建列表）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatGLList</span><span class="params">(<span class="keyword">char</span> *filename,<span class="keyword">int</span> R,<span class="keyword">int</span> G,<span class="keyword">int</span> B,GLuint *listname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">in</span><span class="params">(filename)</span></span>;</span><br><span class="line"><span class="comment">//要读取的文件是filename，例如如果参数是</span></span><br><span class="line"><span class="comment">//&quot;F:\\Works\\Practice\\数字化方法\\Shove\\Shovel.STL&quot;，</span></span><br><span class="line"><span class="comment">//那么会读取F:\\Works\\Practice\\数字化方法\\Shove这个目录下的Shove1.STL文件。</span></span><br><span class="line">	<span class="keyword">if</span> (!in)</span><br><span class="line">		_ASSERT(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> String0[<span class="number">30</span>];</span><br><span class="line">	in &gt;&gt; String0 &gt;&gt; String0&gt;&gt; String0;</span><br><span class="line"></span><br><span class="line">	*listname = glGenLists(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//参数listname是一个指针，*listname才是列表变量</span></span><br><span class="line">	<span class="keyword">float</span> Points[<span class="number">12</span>];</span><br><span class="line">	<span class="keyword">float</span> n[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	glNewList(*listname,GL_COMPILE);</span><br><span class="line">		glPolygonMode(GL_BACK,GL_LINE);</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">strcmp</span>(String0,<span class="string">&quot;endsolid&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			in &gt;&gt; String0;</span><br><span class="line">			in &gt;&gt; n[<span class="number">0</span>] &gt;&gt; n[<span class="number">1</span>] &gt;&gt; n[<span class="number">2</span>];</span><br><span class="line">			in &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; Points[<span class="number">0</span>] &gt;&gt; Points[<span class="number">1</span>] &gt;&gt; Points[<span class="number">2</span>];</span><br><span class="line">			in &gt;&gt; String0 &gt;&gt; Points[<span class="number">3</span>] &gt;&gt; Points[<span class="number">4</span>] &gt;&gt; Points[<span class="number">5</span>];</span><br><span class="line">			in &gt;&gt; String0 &gt;&gt; Points[<span class="number">6</span>] &gt;&gt; Points[<span class="number">7</span>] &gt;&gt; Points[<span class="number">8</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">float</span> * point = Points + <span class="number">3</span>;point &lt; Points + <span class="number">11</span>;point += <span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(Points[j]&lt;PointMin[j])</span><br><span class="line">					&#123;</span><br><span class="line">						PointMin[j] = Points[j];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(Points[j]&gt;PointMax[j])</span><br><span class="line">					&#123;</span><br><span class="line">						PointMax[j] = Points[j];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			glColor3ub(R,G,B);</span><br><span class="line"><span class="comment">//根据函数的参数设置模型颜色</span></span><br><span class="line">			glBegin(GL_TRIANGLES);</span><br><span class="line">			DrawTriangle(Points,Points+<span class="number">3</span>,Points+<span class="number">6</span>);</span><br><span class="line">			glEnd();</span><br><span class="line">			in &gt;&gt; String0 &gt;&gt; String0&gt;&gt; String0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	glEndList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.我们有了新建列表的函数之后，然后就可以加载文件了……吗？注意，<strong>在使用函数之前先在文件开头定义几个列表变量（GLuint类型变量）</strong>，这个几个变量是用来存放各个模型的，没有这些变量就调用函数，软件会在参数上划红线，也就是它不知道把模型读取进来之后存到哪里去。<br><img src="https://img-blog.csdnimg.cn/20191105211559493.png" alt="huffie"><br>做好了这两个准备工作之后就可以开始新建模型列表and召唤模型列表了。在SetupRC函数原来加载文件的那个地方就可以用一句简单的CreatGLList(“F:\Works\Practice\数字化方法\Shove\Shovel.STL”,255,255,0,&amp;Shove);代替了。<strong>新建六个模型列表就用六次这个函数就可以了</strong>，比直接复制一大段读取模型的文件简化了不少。就像下面这样<br><img src="https://img-blog.csdnimg.cn/20191105211649988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="huffie"><br>建好了这六个模型列表，那我们就可以直接召唤它们了，在RenderScene函数里直接调用六个glCallList就可以把这六个模型召唤出来了<br><img src="https://img-blog.csdnimg.cn/20191105211739868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="huffie"><br>这么召唤神龙，sorry召唤模型，出来就直接是装配好的小车的样子，（虽然我也不知是为什么<br>这一节到此为止。</p>
<h2 id="让小车动起来"><a href="#让小车动起来" class="headerlink" title="让小车动起来"></a>让小车动起来</h2><p>本节的目的是让小车动起来！难度稍大，各位仔细听我娓娓道来<br>1、理论部分，我们想让这个模型通过按键盘上不同的按键让他动起来，肯定要有<strong>函数用来读取按键</strong>，<strong>读取之后利用平移旋转之类的矩阵各个部分运动起来</strong>。<br>2、键盘部分：在写函数之前先在文件开头定义一些全局变量（各部分的转动角度），用于以后的旋转矩阵。<br><img src="https://img-blog.csdnimg.cn/20191105211909861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="huffie"><br>然后我们先写一下读取按键的函数。请大家先在最下方main函数里添加如下的一行代码，这个是库函数，用于读取按键的。<br><img src="https://img-blog.csdnimg.cn/20191105211940834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="huffie"><br>然后在前面我们定义一个函数名叫keyboard，函数内容如下，函数体是有重复的代码组成的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyboard</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> key,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">float</span> ShoveStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="comment">//定义一个静态变量（下一次进入函数，变量内容保持不变）</span></span><br><span class="line"><span class="comment">//步长为3.0f，即设定按一下按键角度变化3度</span></span><br><span class="line">	<span class="keyword">if</span>(ShoveRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">		ShoveRot = <span class="number">-3.0f</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ShoveRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">		ShoveRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="comment">//这里作用是防止模型出现失真（比如铲子转着转着转到驾驶舱里去了）</span></span><br><span class="line">	<span class="keyword">switch</span>(key)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:ShoveRot+=ShoveStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:ShoveRot-=ShoveStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//判断是否是“某一按键”，是的话相应部分的转动角度增加（减少）一个步长。</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">float</span> MainLinkStep = <span class="number">3.0f</span>;</span><br><span class="line">	<span class="keyword">if</span>(MainLinkRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">		MainLinkRot = <span class="number">-3.0f</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(MainLinkRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">		MainLinkRot = <span class="number">3.0f</span>;</span><br><span class="line">	<span class="keyword">switch</span>(key)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:MainLinkRot+=MainLinkStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:MainLinkRot-=MainLinkStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">float</span> MainBodyStep = <span class="number">3.0f</span>;</span><br><span class="line">	<span class="keyword">if</span>(MainBodyRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">		MainBodyRot = <span class="number">-3.0f</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(MainBodyRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">		MainBodyRot = <span class="number">3.0f</span>;</span><br><span class="line">	<span class="keyword">switch</span>(key)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;j&#x27;</span>:MainBodyRot+=MainBodyStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:MainBodyRot-=MainBodyStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">float</span> GroundStep = <span class="number">3.0f</span>;</span><br><span class="line">	<span class="keyword">if</span>(GroundRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">		GroundRot = <span class="number">-3.0f</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(GroundRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">		GroundRot = <span class="number">3.0f</span>;</span><br><span class="line">	<span class="keyword">switch</span>(key)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:GroundRot+=GroundStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:GroundRot-=GroundStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">float</span> FrontWheelsStep = <span class="number">3.0f</span>;</span><br><span class="line">	<span class="keyword">if</span>(FrontWheelsRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">		FrontWheelsRot = <span class="number">-3.0f</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(FrontWheelsRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">		FrontWheelsRot = <span class="number">3.0f</span>;</span><br><span class="line">	<span class="keyword">switch</span>(key)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>:FrontWheelsRot+=FrontWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:FrontWheelsRot-=FrontWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">float</span> BackWheelsStep = <span class="number">3.0f</span>;</span><br><span class="line">	<span class="keyword">if</span>(BackWheelsRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">		BackWheelsRot = <span class="number">-3.0f</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(BackWheelsRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">		BackWheelsRot = <span class="number">3.0f</span>;</span><br><span class="line">	<span class="keyword">switch</span>(key)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:BackWheelsRot+=BackWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:BackWheelsRot-=BackWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就成功的读取到了按键并能够根据按键的不同，相应的角度变量发生改变（函数中的按键可以自己设置，根据个人喜好）<br>3、矩阵操作部分<br>首先来了解一下几个函数的用法<br><strong>glLoadIdentity();生成一个单位阵并设置为当前阵<br>glPushMatrix();保存当前的矩阵到一个不知名的地方<br>glPopMatrix();设置之前保存的矩阵为当前阵<br>glMultMatrixf(A);用A矩阵乘当前阵，结果设置为当前阵<br>glRotatef(角度值,0.0f,1.0f,0.0f);后面三个参数若第一个为1，则绕x轴旋转，第二个为1则绕y轴旋转，第三个为1则绕z轴旋转。</strong><br>还有一个平移的库函数我没记住；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderScene</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	<span class="comment">// Clear the window with current clearing color</span></span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save the matrix state and do the rotations</span></span><br><span class="line">	glPushMatrix();</span><br><span class="line"></span><br><span class="line">	Translate(<span class="number">0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">	glRotatef(xRot,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">10.0f</span>);</span><br><span class="line">	glRotatef(yRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">	Translate(<span class="number">-0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">	glPushMatrix();</span><br><span class="line">	glCallList(MainBody);</span><br><span class="line"></span><br><span class="line">	glPopMatrix();</span><br><span class="line">	glPushMatrix();</span><br><span class="line">	Translate(<span class="number">0</span>,<span class="keyword">float</span>(<span class="number">-4.89</span>/<span class="number">1000.0</span>),<span class="keyword">float</span>(<span class="number">-39.75</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line">	Rotate_x(ShoveRot,Rotation);</span><br><span class="line">	glMultMatrixf(Rotation);</span><br><span class="line">	Translate(<span class="number">0</span>,<span class="keyword">float</span>(<span class="number">4.89</span>/<span class="number">1000.0</span>),<span class="keyword">float</span>(<span class="number">39.75</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line">	glCallList(BackWheels);</span><br><span class="line"></span><br><span class="line">	glLoadIdentity();</span><br><span class="line">	Translate(<span class="number">0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line">	glRotatef(xRot,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">10.0f</span>);</span><br><span class="line">	glRotatef(yRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">	Translate(<span class="number">-0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line">	glPushMatrix();</span><br><span class="line">	Translate(<span class="number">0</span>,<span class="keyword">float</span>(<span class="number">-6.63</span>/<span class="number">1000.0</span>),<span class="keyword">float</span>(<span class="number">16.50</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line">	Rotate_x(ShoveRot,Rotation);</span><br><span class="line">	glMultMatrixf(Rotation);</span><br><span class="line">	Translate(<span class="number">0</span>,<span class="keyword">float</span>(<span class="number">6.63</span>/<span class="number">1000.0</span>),<span class="keyword">float</span>(<span class="number">-16.50</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line">	glCallList(FrontWheels);</span><br><span class="line"></span><br><span class="line">    glPopMatrix();</span><br><span class="line">	Translate(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">float</span>(<span class="number">-10</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line">	glRotatef(GroundRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">	Translate(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">float</span>(<span class="number">10</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line">	glCallList(Ground);</span><br><span class="line"></span><br><span class="line">	Translate(<span class="number">0</span>,<span class="keyword">float</span>(<span class="number">21.74</span>/<span class="number">1000</span>),<span class="keyword">float</span>(<span class="number">4.06</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line">	Rotate_x(MainLinkRot,Rotation);</span><br><span class="line">	glMultMatrixf(Rotation);</span><br><span class="line">	Translate(<span class="number">0</span>,<span class="keyword">float</span>(<span class="number">-21.74</span>/<span class="number">1000</span>),<span class="keyword">float</span>(<span class="number">-4.06</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line">	glCallList(MainLink);</span><br><span class="line"></span><br><span class="line">	Translate(<span class="number">0</span>,<span class="keyword">float</span>(<span class="number">31.74</span>/<span class="number">1000.0</span>),<span class="keyword">float</span>(<span class="number">53.46</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line">	Rotate_x(ShoveRot,Rotation);</span><br><span class="line">	glMultMatrixf(Rotation);</span><br><span class="line">	Translate(<span class="number">0</span>,<span class="keyword">float</span>(<span class="number">-31.74</span>/<span class="number">1000.0</span>),<span class="keyword">float</span>(<span class="number">-53.46</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">	glMultMatrixf(Translation);</span><br><span class="line">	glCallList(Shove);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Restore the matrix state</span></span><br><span class="line">	glPopMatrix();</span><br><span class="line">	<span class="comment">// Display the results</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码都可在博客开头的网盘里自行提取<br><img src="https://img-blog.csdnimg.cn/20191105212142324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SHVmZmllX0hlYnV0CumprOa1qemjniDmsrPljJflt6XkuJrlpKflraY=,size_16,color_FFFFFF,t_70#pic_center" alt="huffie"><br>（2）主体和两个轮子要和（1）分开，因为他们的位移没有叠加关系，具体可用glPushMatrix();和glPopMatrix();实现<br>这部分程序我自己理解的并不是很透彻，如有问题or不懂的请单独找我。</p>
<p><em><strong>Continue……</strong></em></p>
]]></content>
      <categories>
        <category>机器人</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
</search>
